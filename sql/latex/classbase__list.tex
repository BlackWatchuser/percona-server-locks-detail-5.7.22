\hypertarget{classbase__list}{}\section{base\+\_\+list Class Reference}
\label{classbase__list}\index{base\+\_\+list@{base\+\_\+list}}
Inheritance diagram for base\+\_\+list\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=12.000000cm]{classbase__list}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classbase__list_ab3bc6913d78bce50142783bd8834f9e8}\label{classbase__list_ab3bc6913d78bce50142783bd8834f9e8}} 
bool {\bfseries operator==} (const \mbox{\hyperlink{classbase__list}{base\+\_\+list}} \&rhs) const
\item 
\mbox{\Hypertarget{classbase__list_ad11dad8c428de9a770fcdc708c1a058f}\label{classbase__list_ad11dad8c428de9a770fcdc708c1a058f}} 
void {\bfseries empty} ()
\item 
\mbox{\hyperlink{classbase__list_a24d6d72225c4f733291ddaca494cf84a}{base\+\_\+list}} (const \mbox{\hyperlink{classbase__list}{base\+\_\+list}} \&tmp)
\item 
\mbox{\Hypertarget{classbase__list_a80344dfb97b5355f62984bb57a292a4f}\label{classbase__list_a80344dfb97b5355f62984bb57a292a4f}} 
\mbox{\hyperlink{classbase__list}{base\+\_\+list}} \& {\bfseries operator=} (const \mbox{\hyperlink{classbase__list}{base\+\_\+list}} \&tmp)
\item 
\mbox{\hyperlink{classbase__list_a3a29753a509aeb6df2ea457796fab004}{base\+\_\+list}} (const \mbox{\hyperlink{classbase__list}{base\+\_\+list}} \&rhs, M\+E\+M\+\_\+\+R\+O\+OT $\ast$mem\+\_\+root)
\item 
\mbox{\Hypertarget{classbase__list_aaba06a42b7fa3290600c8c0494903f43}\label{classbase__list_aaba06a42b7fa3290600c8c0494903f43}} 
{\bfseries base\+\_\+list} (bool error)
\item 
\mbox{\Hypertarget{classbase__list_a0f84912f81a0db456b03c4c457485ba5}\label{classbase__list_a0f84912f81a0db456b03c4c457485ba5}} 
bool {\bfseries push\+\_\+back} (void $\ast$info)
\item 
\mbox{\Hypertarget{classbase__list_a64f7a8472d00005d55451482641a24d5}\label{classbase__list_a64f7a8472d00005d55451482641a24d5}} 
bool {\bfseries push\+\_\+back} (void $\ast$info, M\+E\+M\+\_\+\+R\+O\+OT $\ast$mem\+\_\+root)
\item 
\mbox{\Hypertarget{classbase__list_a3d594fbbb23c7b5030fd2f3e7126fb61}\label{classbase__list_a3d594fbbb23c7b5030fd2f3e7126fb61}} 
bool {\bfseries push\+\_\+front} (void $\ast$info)
\item 
\mbox{\Hypertarget{classbase__list_afd5da65506b5c7f83707a64ea1268586}\label{classbase__list_afd5da65506b5c7f83707a64ea1268586}} 
bool {\bfseries push\+\_\+front} (void $\ast$info, M\+E\+M\+\_\+\+R\+O\+OT $\ast$mem\+\_\+root)
\item 
\mbox{\Hypertarget{classbase__list_acafc881d265b00261f580b0911601962}\label{classbase__list_acafc881d265b00261f580b0911601962}} 
void {\bfseries remove} (\mbox{\hyperlink{structlist__node}{list\+\_\+node}} $\ast$$\ast$prev)
\item 
\mbox{\Hypertarget{classbase__list_a2a0e4f2a67ce14b5f93118ff2f1a9801}\label{classbase__list_a2a0e4f2a67ce14b5f93118ff2f1a9801}} 
void {\bfseries concat} (\mbox{\hyperlink{classbase__list}{base\+\_\+list}} $\ast$list)
\item 
\mbox{\Hypertarget{classbase__list_a9ceedc9fbf54473ccb50612b5fe0ffa7}\label{classbase__list_a9ceedc9fbf54473ccb50612b5fe0ffa7}} 
void $\ast$ {\bfseries pop} (void)
\item 
\mbox{\Hypertarget{classbase__list_a1c92e19ba89bc98c61f64c415e84a232}\label{classbase__list_a1c92e19ba89bc98c61f64c415e84a232}} 
void {\bfseries disjoin} (\mbox{\hyperlink{classbase__list}{base\+\_\+list}} $\ast$list)
\item 
\mbox{\Hypertarget{classbase__list_ad7d612f8132a1d6643b667a0fbef1cbf}\label{classbase__list_ad7d612f8132a1d6643b667a0fbef1cbf}} 
void {\bfseries prepand} (\mbox{\hyperlink{classbase__list}{base\+\_\+list}} $\ast$list)
\item 
void \mbox{\hyperlink{classbase__list_a6248247a8f1560022bfae0327076dc1b}{sort}} (Node\+\_\+cmp\+\_\+func cmp, void $\ast$arg)
\begin{DoxyCompactList}\small\item\em Sort the list. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classbase__list_a5f4318d70a12a85932c5daacf0015f73}{swap}} (\mbox{\hyperlink{classbase__list}{base\+\_\+list}} \&rhs)
\item 
\mbox{\Hypertarget{classbase__list_a7b64ad8250cf3bd4e36164d9f24eb9d1}\label{classbase__list_a7b64ad8250cf3bd4e36164d9f24eb9d1}} 
\mbox{\hyperlink{structlist__node}{list\+\_\+node}} $\ast$ {\bfseries last\+\_\+node} ()
\item 
\mbox{\Hypertarget{classbase__list_ac8fc2be57de00a3b90a3fb3036d0263f}\label{classbase__list_ac8fc2be57de00a3b90a3fb3036d0263f}} 
\mbox{\hyperlink{structlist__node}{list\+\_\+node}} $\ast$ {\bfseries first\+\_\+node} ()
\item 
\mbox{\Hypertarget{classbase__list_adf3b6fd5080d29df05d6157aeddb0b61}\label{classbase__list_adf3b6fd5080d29df05d6157aeddb0b61}} 
void $\ast$ {\bfseries head} ()
\item 
\mbox{\Hypertarget{classbase__list_a1464bf67435ed3fede7f3fc7103d26ee}\label{classbase__list_a1464bf67435ed3fede7f3fc7103d26ee}} 
void $\ast$$\ast$ {\bfseries head\+\_\+ref} ()
\item 
\mbox{\Hypertarget{classbase__list_aa5cff200b9fab3104356362400c86917}\label{classbase__list_aa5cff200b9fab3104356362400c86917}} 
bool {\bfseries is\+\_\+empty} () const
\item 
\mbox{\Hypertarget{classbase__list_ae3420603a3381c0868adb9f9a5be769f}\label{classbase__list_ae3420603a3381c0868adb9f9a5be769f}} 
\mbox{\hyperlink{structlist__node}{list\+\_\+node}} $\ast$ {\bfseries last\+\_\+ref} ()
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classbase__list_acc70abb4b59e61f26b10dadd42a01d51}\label{classbase__list_acc70abb4b59e61f26b10dadd42a01d51}} 
uint {\bfseries elements}
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classbase__list_a78d98a8c70e6614125bcfd0e541d1a59}\label{classbase__list_a78d98a8c70e6614125bcfd0e541d1a59}} 
void {\bfseries after} (void $\ast$info, \mbox{\hyperlink{structlist__node}{list\+\_\+node}} $\ast$node)
\item 
\mbox{\Hypertarget{classbase__list_ae5dcc0e45427bdd68b1b16104bdaf56a}\label{classbase__list_ae5dcc0e45427bdd68b1b16104bdaf56a}} 
bool {\bfseries after} (void $\ast$info, \mbox{\hyperlink{structlist__node}{list\+\_\+node}} $\ast$node, M\+E\+M\+\_\+\+R\+O\+OT $\ast$mem\+\_\+root)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classbase__list_aea45af9bfceb7c81a0821d3761d78bf2}\label{classbase__list_aea45af9bfceb7c81a0821d3761d78bf2}} 
\mbox{\hyperlink{structlist__node}{list\+\_\+node}} $\ast$ {\bfseries first}
\item 
\mbox{\Hypertarget{classbase__list_ae0005bbe47515f418cd32e3ed0d60fd0}\label{classbase__list_ae0005bbe47515f418cd32e3ed0d60fd0}} 
\mbox{\hyperlink{structlist__node}{list\+\_\+node}} $\ast$$\ast$ {\bfseries last}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classbase__list_ae96dee6b0b1d984625808c8b7bebd3f6}\label{classbase__list_ae96dee6b0b1d984625808c8b7bebd3f6}} 
class {\bfseries base\+\_\+list\+\_\+iterator}
\item 
\mbox{\Hypertarget{classbase__list_a2a207022234994711ffaf2ff6c58d2aa}\label{classbase__list_a2a207022234994711ffaf2ff6c58d2aa}} 
class {\bfseries error\+\_\+list}
\item 
\mbox{\Hypertarget{classbase__list_a7251d6207a206c654ca359fde3dd4060}\label{classbase__list_a7251d6207a206c654ca359fde3dd4060}} 
class {\bfseries error\+\_\+list\+\_\+iterator}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classbase__list_a24d6d72225c4f733291ddaca494cf84a}\label{classbase__list_a24d6d72225c4f733291ddaca494cf84a}} 
\index{base\+\_\+list@{base\+\_\+list}!base\+\_\+list@{base\+\_\+list}}
\index{base\+\_\+list@{base\+\_\+list}!base\+\_\+list@{base\+\_\+list}}
\subsubsection{\texorpdfstring{base\+\_\+list()}{base\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily base\+\_\+list\+::base\+\_\+list (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classbase__list}{base\+\_\+list}} \&}]{tmp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

This is a shallow copy constructor that implicitly passes the ownership from the source list to the new instance. The old instance is not updated, so both objects end up sharing the same nodes. If one of the instances then adds or removes a node, the other becomes out of sync (\textquotesingle{}last\textquotesingle{} pointer), while still operational. Some old code uses and relies on this behaviour. This logic is quite tricky\+: please do not use it in any new code. \mbox{\Hypertarget{classbase__list_a3a29753a509aeb6df2ea457796fab004}\label{classbase__list_a3a29753a509aeb6df2ea457796fab004}} 
\index{base\+\_\+list@{base\+\_\+list}!base\+\_\+list@{base\+\_\+list}}
\index{base\+\_\+list@{base\+\_\+list}!base\+\_\+list@{base\+\_\+list}}
\subsubsection{\texorpdfstring{base\+\_\+list()}{base\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily base\+\_\+list\+::base\+\_\+list (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classbase__list}{base\+\_\+list}} \&}]{rhs,  }\item[{M\+E\+M\+\_\+\+R\+O\+OT $\ast$}]{mem\+\_\+root }\end{DoxyParamCaption})}

Construct a deep copy of the argument in memory root mem\+\_\+root. The elements themselves are copied by pointer. If you also need to copy elements by value, you should employ list\+\_\+copy\+\_\+and\+\_\+replace\+\_\+each\+\_\+value after creating a copy. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classbase__list_a6248247a8f1560022bfae0327076dc1b}\label{classbase__list_a6248247a8f1560022bfae0327076dc1b}} 
\index{base\+\_\+list@{base\+\_\+list}!sort@{sort}}
\index{sort@{sort}!base\+\_\+list@{base\+\_\+list}}
\subsubsection{\texorpdfstring{sort()}{sort()}}
{\footnotesize\ttfamily void base\+\_\+list\+::sort (\begin{DoxyParamCaption}\item[{Node\+\_\+cmp\+\_\+func}]{cmp,  }\item[{void $\ast$}]{arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sort the list. 


\begin{DoxyParams}{Parameters}
{\em cmp} & node comparison function \\
\hline
{\em arg} & additional info to be passed to comparison function\\
\hline
\end{DoxyParams}
The function sorts list nodes by an exchange sort algorithm. The order of list nodes isn\textquotesingle{}t changed, values of info fields are swapped instead. Due to this, list iterators that are initialized before sort could be safely used after sort, i.\+e they wouldn\textquotesingle{}t cause a crash. As this isn\textquotesingle{}t an effective algorithm the list to be sorted is supposed to be short. \mbox{\Hypertarget{classbase__list_a5f4318d70a12a85932c5daacf0015f73}\label{classbase__list_a5f4318d70a12a85932c5daacf0015f73}} 
\index{base\+\_\+list@{base\+\_\+list}!swap@{swap}}
\index{swap@{swap}!base\+\_\+list@{base\+\_\+list}}
\subsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily void base\+\_\+list\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classbase__list}{base\+\_\+list}} \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Swap two lists. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
sql\+\_\+list.\+h\item 
sql\+\_\+list.\+cc\end{DoxyCompactItemize}
