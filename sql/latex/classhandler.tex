\hypertarget{classhandler}{}\section{handler Class Reference}
\label{classhandler}\index{handler@{handler}}


{\ttfamily \#include $<$handler.\+h$>$}

Inheritance diagram for handler\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classhandler}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classhandler_ab5b14b11876fb5ac53a4cc7aceea6a2d}\label{classhandler_ab5b14b11876fb5ac53a4cc7aceea6a2d}} 
enum {\bfseries enum\+\_\+range\+\_\+scan\+\_\+direction} \{ {\bfseries R\+A\+N\+G\+E\+\_\+\+S\+C\+A\+N\+\_\+\+A\+SC}, 
{\bfseries R\+A\+N\+G\+E\+\_\+\+S\+C\+A\+N\+\_\+\+D\+E\+SC}
 \}
\item 
\mbox{\Hypertarget{classhandler_ab68580c3751fc08427f5ac48ef4b2d69}\label{classhandler_ab68580c3751fc08427f5ac48ef4b2d69}} 
enum \{ {\bfseries N\+O\+NE} =0, 
{\bfseries I\+N\+D\+EX}, 
{\bfseries R\+ND}
 \}
\item 
\mbox{\Hypertarget{classhandler_a67af5473a36655c922682399d4c5b6ec}\label{classhandler_a67af5473a36655c922682399d4c5b6ec}} 
typedef ulonglong {\bfseries Table\+\_\+flags}
\item 
typedef void($\ast$ \mbox{\hyperlink{classhandler_ad4c241e50948859d98ceae6e39066838}{my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t}}) (const \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$, void $\ast$)
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classhandler_a72cfeaceefd05a2f700c138c194770fc}\label{classhandler_a72cfeaceefd05a2f700c138c194770fc}} 
virtual void {\bfseries unbind\+\_\+psi} ()
\item 
\mbox{\Hypertarget{classhandler_a1e335a403d8203854bc5b94111992b79}\label{classhandler_a1e335a403d8203854bc5b94111992b79}} 
virtual void {\bfseries rebind\+\_\+psi} ()
\item 
void \mbox{\hyperlink{classhandler_a6cadefb8724982848541e06a394917e8}{start\+\_\+psi\+\_\+batch\+\_\+mode}} ()
\item 
void \mbox{\hyperlink{classhandler_ab6a860cb6d6cb731416080acc8f179e0}{end\+\_\+psi\+\_\+batch\+\_\+mode}} ()
\item 
\mbox{\Hypertarget{classhandler_a9ae8f7f7b4f67773b73906143238dc9f}\label{classhandler_a9ae8f7f7b4f67773b73906143238dc9f}} 
{\bfseries handler} (\mbox{\hyperlink{structhandlerton}{handlerton}} $\ast$ht\+\_\+arg, \mbox{\hyperlink{structTABLE__SHARE}{T\+A\+B\+L\+E\+\_\+\+S\+H\+A\+RE}} $\ast$share\+\_\+arg)
\item 
\mbox{\Hypertarget{classhandler_a97fc340039f5cf37a26e7c3b53685794}\label{classhandler_a97fc340039f5cf37a26e7c3b53685794}} 
virtual \mbox{\hyperlink{classhandler}{handler}} $\ast$ {\bfseries clone} (const char $\ast$name, M\+E\+M\+\_\+\+R\+O\+OT $\ast$mem\+\_\+root)
\item 
void \mbox{\hyperlink{classhandler_ab1ad6edb66592b200a7c7ac0f947dc66}{init}} ()
\item 
virtual bool \mbox{\hyperlink{classhandler_a6b6facc9d1d0bda98c814660eaa9bad7}{init\+\_\+with\+\_\+fields}} ()
\item 
int \mbox{\hyperlink{classhandler_ab5e02829386929734724b143391e0a11}{ha\+\_\+open}} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$table, const char $\ast$name, int mode, int test\+\_\+if\+\_\+locked)
\begin{DoxyCompactList}\small\item\em Open database-\/handler. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classhandler_ae28824cdff2c1812e282463c908e84c2}{ha\+\_\+close}} (void)
\item 
int \mbox{\hyperlink{classhandler_a0af23462b249041a0db03c1c7139d76b}{ha\+\_\+index\+\_\+init}} (uint idx, bool sorted)
\item 
int \mbox{\hyperlink{classhandler_afa6bd01057c6cdd86d2ea2ee4ea65ca3}{ha\+\_\+index\+\_\+end}} ()
\item 
int \mbox{\hyperlink{classhandler_afb5c99736cb400350e007578889b8375}{ha\+\_\+rnd\+\_\+init}} (bool scan)
\item 
int \mbox{\hyperlink{classhandler_ad4d9bf34ac0a004d8c5c32267f20842f}{ha\+\_\+rnd\+\_\+end}} ()
\item 
int \mbox{\hyperlink{classhandler_ad3743f3a48e7be751dbb2691be4c992a}{ha\+\_\+rnd\+\_\+next}} (uchar $\ast$buf)
\item 
int \mbox{\hyperlink{classhandler_abcd8615219b3e692e7d484d2ba6cfa86}{ha\+\_\+rnd\+\_\+pos}} (uchar $\ast$buf, uchar $\ast$pos)
\item 
int \mbox{\hyperlink{classhandler_a729d9c9c011527b81287574294887bf3}{ha\+\_\+index\+\_\+read\+\_\+map}} (uchar $\ast$buf, const uchar $\ast$key, key\+\_\+part\+\_\+map keypart\+\_\+map, enum ha\+\_\+rkey\+\_\+function find\+\_\+flag)
\item 
\mbox{\Hypertarget{classhandler_a3fa9be09b8d0b1c03c96eb95f79dd7c9}\label{classhandler_a3fa9be09b8d0b1c03c96eb95f79dd7c9}} 
int {\bfseries ha\+\_\+index\+\_\+read\+\_\+last\+\_\+map} (uchar $\ast$buf, const uchar $\ast$key, key\+\_\+part\+\_\+map keypart\+\_\+map)
\item 
int \mbox{\hyperlink{classhandler_ac831321e8d33958db4fd4968de932acf}{ha\+\_\+index\+\_\+read\+\_\+idx\+\_\+map}} (uchar $\ast$buf, uint index, const uchar $\ast$key, key\+\_\+part\+\_\+map keypart\+\_\+map, enum ha\+\_\+rkey\+\_\+function find\+\_\+flag)
\item 
int \mbox{\hyperlink{classhandler_a4c99e96a8350ff577a94529be9387a30}{ha\+\_\+index\+\_\+next}} (uchar $\ast$buf)
\item 
int \mbox{\hyperlink{classhandler_abb977dac0435158be227e45e04c8b798}{ha\+\_\+index\+\_\+prev}} (uchar $\ast$buf)
\item 
int \mbox{\hyperlink{classhandler_abd574a3025588e9b0cd49e0d6908e3b8}{ha\+\_\+index\+\_\+first}} (uchar $\ast$buf)
\item 
int \mbox{\hyperlink{classhandler_a2a7415f1744039a51ef15e923ef7da1b}{ha\+\_\+index\+\_\+last}} (uchar $\ast$buf)
\item 
int \mbox{\hyperlink{classhandler_a3f79360a45d50c6b558feb1c308c4157}{ha\+\_\+index\+\_\+next\+\_\+same}} (uchar $\ast$buf, const uchar $\ast$key, uint keylen)
\item 
int \mbox{\hyperlink{classhandler_a53d38f167906d8aaa9e560c71e595a42}{ha\+\_\+reset}} ()
\begin{DoxyCompactList}\small\item\em Check handler usage and reset state of file to after \textquotesingle{}open\textquotesingle{}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classhandler_a6e1ef9b6ab27156116f91bf50b1ac19f}\label{classhandler_a6e1ef9b6ab27156116f91bf50b1ac19f}} 
int {\bfseries ha\+\_\+index\+\_\+or\+\_\+rnd\+\_\+end} ()
\item 
Table\+\_\+flags \mbox{\hyperlink{classhandler_a6b3015577f49008561db1d34ae750e70}{ha\+\_\+table\+\_\+flags}} () const
\item 
int \mbox{\hyperlink{classhandler_a9a99b5f8ae28bc5c374919396f8dcf08}{ha\+\_\+external\+\_\+lock}} (T\+HD $\ast$thd, int lock\+\_\+type)
\item 
\mbox{\Hypertarget{classhandler_ad8e651543ba0dbb2257a50dc1cdb5ea9}\label{classhandler_ad8e651543ba0dbb2257a50dc1cdb5ea9}} 
int {\bfseries ha\+\_\+write\+\_\+row} (uchar $\ast$buf)
\item 
\mbox{\Hypertarget{classhandler_a1f6bb19636dda0f1537fe780b6aca17a}\label{classhandler_a1f6bb19636dda0f1537fe780b6aca17a}} 
int {\bfseries ha\+\_\+update\+\_\+row} (const uchar $\ast$old\+\_\+data, uchar $\ast$new\+\_\+data)
\item 
\mbox{\Hypertarget{classhandler_a3f0e3b24f5bb5b2a8fa0c45732db8cdd}\label{classhandler_a3f0e3b24f5bb5b2a8fa0c45732db8cdd}} 
int {\bfseries ha\+\_\+delete\+\_\+row} (const uchar $\ast$buf)
\item 
\mbox{\Hypertarget{classhandler_abfbcbef5b9b8ed0f76d700a29091ad3f}\label{classhandler_abfbcbef5b9b8ed0f76d700a29091ad3f}} 
void {\bfseries ha\+\_\+release\+\_\+auto\+\_\+increment} ()
\item 
int \mbox{\hyperlink{classhandler_a234580f9765751ce185182dd1edc3bdb}{check\+\_\+collation\+\_\+compatibility}} ()
\item 
\mbox{\Hypertarget{classhandler_a79a8030a4a3928d216599e1c03e9b28c}\label{classhandler_a79a8030a4a3928d216599e1c03e9b28c}} 
int {\bfseries ha\+\_\+check\+\_\+for\+\_\+upgrade} (\mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
int \mbox{\hyperlink{classhandler_a56545ec9967544c80d5612f8ac9b8e6e}{ha\+\_\+check}} (T\+HD $\ast$thd, \mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
int \mbox{\hyperlink{classhandler_ad28d70543d9566894b5a81d25eca2e8e}{ha\+\_\+repair}} (T\+HD $\ast$thd, \mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
void \mbox{\hyperlink{classhandler_a3f09a15d46c019a621b0a65bb1ec89d3}{ha\+\_\+start\+\_\+bulk\+\_\+insert}} (ha\+\_\+rows rows)
\item 
int \mbox{\hyperlink{classhandler_a30f3cbf4a769155c994ed39f76433106}{ha\+\_\+end\+\_\+bulk\+\_\+insert}} ()
\item 
int \mbox{\hyperlink{classhandler_a49c8ce82a564b0cbf6340dc9b74a9c23}{ha\+\_\+bulk\+\_\+update\+\_\+row}} (const uchar $\ast$old\+\_\+data, uchar $\ast$new\+\_\+data, uint $\ast$dup\+\_\+key\+\_\+found)
\item 
int \mbox{\hyperlink{classhandler_a1fef228137a11565f7d52a60ad802004}{ha\+\_\+delete\+\_\+all\+\_\+rows}} ()
\item 
int \mbox{\hyperlink{classhandler_a25394328a49d42bb45b3b263009f02c7}{ha\+\_\+truncate}} ()
\item 
int \mbox{\hyperlink{classhandler_a980a8a7650a41fd9a05a32521826ccd5}{ha\+\_\+optimize}} (T\+HD $\ast$thd, \mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
int \mbox{\hyperlink{classhandler_a66cc9e4971b8e768c102398da0656a7f}{ha\+\_\+analyze}} (T\+HD $\ast$thd, \mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
bool \mbox{\hyperlink{classhandler_a169d5287bdf480f8cd20f758bb2d9bd1}{ha\+\_\+check\+\_\+and\+\_\+repair}} (T\+HD $\ast$thd)
\item 
int \mbox{\hyperlink{classhandler_aeeb079b3dc59160ba828ef89b4463921}{ha\+\_\+disable\+\_\+indexes}} (uint mode)
\item 
int \mbox{\hyperlink{classhandler_a36e9c53758728e07eb37cbb65ea3ab50}{ha\+\_\+enable\+\_\+indexes}} (uint mode)
\item 
int \mbox{\hyperlink{classhandler_a1f75cf982985d21907140a17521cd6c5}{ha\+\_\+discard\+\_\+or\+\_\+import\+\_\+tablespace}} (my\+\_\+bool discard)
\item 
int \mbox{\hyperlink{classhandler_a6ee228a60527e81efd9a49ddfdd4850d}{ha\+\_\+rename\+\_\+table}} (const char $\ast$from, const char $\ast$to)
\item 
int \mbox{\hyperlink{classhandler_a28700a3bf1af24f9a31ebae51bf877db}{ha\+\_\+delete\+\_\+table}} (const char $\ast$name)
\item 
void \mbox{\hyperlink{classhandler_a6bcc37ec84386f5d6cc86448781666cb}{ha\+\_\+drop\+\_\+table}} (const char $\ast$name)
\item 
int \mbox{\hyperlink{classhandler_a14af5825a427ba6baac74b13223637f8}{ha\+\_\+create}} (const char $\ast$name, \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$form, \mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$info)
\item 
int \mbox{\hyperlink{classhandler_a722462d7e71059a8ed1f43d0fb28366b}{ha\+\_\+create\+\_\+handler\+\_\+files}} (const char $\ast$name, const char $\ast$old\+\_\+name, int action\+\_\+flag, \mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$info)
\item 
\mbox{\Hypertarget{classhandler_ad4c090210fefb7e95d885688f5717028}\label{classhandler_ad4c090210fefb7e95d885688f5717028}} 
void {\bfseries adjust\+\_\+next\+\_\+insert\+\_\+id\+\_\+after\+\_\+explicit\+\_\+value} (ulonglong nr)
\item 
\mbox{\Hypertarget{classhandler_a8a7d2f9da11425e388640206b4d22241}\label{classhandler_a8a7d2f9da11425e388640206b4d22241}} 
int {\bfseries update\+\_\+auto\+\_\+increment} ()
\item 
virtual void \mbox{\hyperlink{classhandler_afda4f1390385a4dc0bfd2981fee23e6c}{print\+\_\+error}} (int error, myf errflag)
\item 
virtual bool \mbox{\hyperlink{classhandler_afce8ffd064ce683481494c7503ef820c}{get\+\_\+error\+\_\+message}} (int error, String $\ast$buf)
\item 
uint \mbox{\hyperlink{classhandler_ad5eede0999f8273864faa40c5e181793}{get\+\_\+dup\+\_\+key}} (int error)
\item 
virtual bool \mbox{\hyperlink{classhandler_a20878b1fb8d31b91dbf53ac963d90f78}{get\+\_\+foreign\+\_\+dup\+\_\+key}} (char $\ast$child\+\_\+table\+\_\+name, uint child\+\_\+table\+\_\+name\+\_\+len, char $\ast$child\+\_\+key\+\_\+name, uint child\+\_\+key\+\_\+name\+\_\+len)
\item 
\mbox{\Hypertarget{classhandler_a2b117a976fc9423d2337da59f35d128c}\label{classhandler_a2b117a976fc9423d2337da59f35d128c}} 
virtual void {\bfseries change\+\_\+table\+\_\+ptr} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$table\+\_\+arg, \mbox{\hyperlink{structTABLE__SHARE}{T\+A\+B\+L\+E\+\_\+\+S\+H\+A\+RE}} $\ast$share)
\item 
virtual double \mbox{\hyperlink{classhandler_a65f8e5188e2bd9636a564bbc0c3fef86}{scan\+\_\+time}} ()
\item 
virtual double \mbox{\hyperlink{classhandler_a061b519fb16fbff126b0e21530973c2e}{read\+\_\+time}} (uint index, uint ranges, ha\+\_\+rows rows)
\item 
virtual double \mbox{\hyperlink{classhandler_a4a2ac6b2908a899c0ce230818bb7a993}{index\+\_\+only\+\_\+read\+\_\+time}} (uint keynr, double \mbox{\hyperlink{classhandler_ae5b7b96354fd25da35a940e656d91940}{records}})
\item 
virtual \mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} \mbox{\hyperlink{classhandler_a5e9380355a7eea5386ef061f36479258}{table\+\_\+scan\+\_\+cost}} ()
\item 
virtual \mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} \mbox{\hyperlink{classhandler_a5575d58c0acbb1924f7f3d3eb756612a}{index\+\_\+scan\+\_\+cost}} (uint index, double ranges, double rows)
\item 
virtual \mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} \mbox{\hyperlink{classhandler_a196d85fe55a71cc09c642592e771b662}{read\+\_\+cost}} (uint index, double ranges, double rows)
\item 
virtual longlong \mbox{\hyperlink{classhandler_a475f7fbe39f6ff0e9da2ac6c3d6c629e}{get\+\_\+memory\+\_\+buffer\+\_\+size}} () const
\item 
double \mbox{\hyperlink{classhandler_a171927b3afde9e800755b834bd8d31bd}{table\+\_\+in\+\_\+memory\+\_\+estimate}} () const
\item 
double \mbox{\hyperlink{classhandler_a375fdfc86f021f336777324dd5a98a02}{index\+\_\+in\+\_\+memory\+\_\+estimate}} (uint keyno) const
\item 
virtual ha\+\_\+rows \mbox{\hyperlink{classhandler_a5ee356d2340552eb121d423fc01597f8}{multi\+\_\+range\+\_\+read\+\_\+info\+\_\+const}} (uint keyno, \mbox{\hyperlink{structst__range__seq__if}{R\+A\+N\+G\+E\+\_\+\+S\+E\+Q\+\_\+\+IF}} $\ast$seq, void $\ast$seq\+\_\+init\+\_\+param, uint n\+\_\+ranges, uint $\ast$bufsz, uint $\ast$flags, \mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} $\ast$cost)
\item 
virtual ha\+\_\+rows \mbox{\hyperlink{classhandler_a5add40a6cd7088ffef25a3816294b624}{multi\+\_\+range\+\_\+read\+\_\+info}} (uint keyno, uint n\+\_\+ranges, uint keys, uint $\ast$bufsz, uint $\ast$flags, \mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} $\ast$cost)
\item 
virtual int \mbox{\hyperlink{classhandler_a33e8899f4bae262b6b91c7284f1d946e}{multi\+\_\+range\+\_\+read\+\_\+init}} (\mbox{\hyperlink{structst__range__seq__if}{R\+A\+N\+G\+E\+\_\+\+S\+E\+Q\+\_\+\+IF}} $\ast$seq, void $\ast$seq\+\_\+init\+\_\+param, uint n\+\_\+ranges, uint mode, \mbox{\hyperlink{structst__handler__buffer}{H\+A\+N\+D\+L\+E\+R\+\_\+\+B\+U\+F\+F\+ER}} $\ast$buf)
\item 
virtual int \mbox{\hyperlink{classhandler_a3419071f3d4abf183dac95ef565adfff}{multi\+\_\+range\+\_\+read\+\_\+next}} (char $\ast$$\ast$range\+\_\+info)
\item 
\mbox{\Hypertarget{classhandler_a29c43b5f1fb4c515d2c5842dcbc24fac}\label{classhandler_a29c43b5f1fb4c515d2c5842dcbc24fac}} 
virtual const \mbox{\hyperlink{classBitmap_3_0164_01_4}{key\+\_\+map}} $\ast$ {\bfseries keys\+\_\+to\+\_\+use\+\_\+for\+\_\+scanning} ()
\item 
\mbox{\Hypertarget{classhandler_a08686bccb46c2be2cc92ff2f75ab9540}\label{classhandler_a08686bccb46c2be2cc92ff2f75ab9540}} 
bool {\bfseries has\+\_\+transactions} () const
\item 
\mbox{\Hypertarget{classhandler_a27fd434bc44b88f4e47f44f02c877c91}\label{classhandler_a27fd434bc44b88f4e47f44f02c877c91}} 
virtual uint {\bfseries extra\+\_\+rec\+\_\+buf\+\_\+length} () const
\item 
virtual bool \mbox{\hyperlink{classhandler_a39c5919d6a3f3098353f4517e2c81037}{is\+\_\+ignorable\+\_\+error}} (int error)
\begin{DoxyCompactList}\small\item\em Determine whether an error can be ignored or not. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{classhandler_a37413b5d60b340ffe26a6713b65bab75}{is\+\_\+fatal\+\_\+error}} (int error)
\begin{DoxyCompactList}\small\item\em Determine whether an error is fatal or not. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{classhandler_a9fe4a9e78c818aa2823c302f0fe65522}{ha\+\_\+records}} (ha\+\_\+rows $\ast$num\+\_\+rows)
\item 
virtual ha\+\_\+rows \mbox{\hyperlink{classhandler_ae59e9a1d36d852f4dd5dd00bff5f1ae4}{estimate\+\_\+rows\+\_\+upper\+\_\+bound}} ()
\item 
virtual enum row\+\_\+type \mbox{\hyperlink{classhandler_a163a360c0cd4575ae207553b8d5c918d}{get\+\_\+row\+\_\+type}} () const
\item 
\mbox{\Hypertarget{classhandler_a1e51a7f02396ce5cef9cbe41a4a0a888}\label{classhandler_a1e51a7f02396ce5cef9cbe41a4a0a888}} 
virtual const char $\ast$ {\bfseries index\+\_\+type} (uint key\+\_\+number)
\item 
virtual void \mbox{\hyperlink{classhandler_a4de97045e5381007565fd2b0da235c07}{column\+\_\+bitmaps\+\_\+signal}} ()
\begin{DoxyCompactList}\small\item\em My\+S\+QL signal that it changed the column bitmap. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classhandler_aacdf0aed6539181d465676ebc661f2b5}\label{classhandler_aacdf0aed6539181d465676ebc661f2b5}} 
uint {\bfseries get\+\_\+index} (void) const
\item 
virtual bool \mbox{\hyperlink{classhandler_a7488245f51aa4676c872bb0564dbe71f}{start\+\_\+bulk\+\_\+update}} ()
\item 
virtual bool \mbox{\hyperlink{classhandler_acdaf7319a6498f655f8f07b1b34b12fc}{start\+\_\+bulk\+\_\+delete}} ()
\item 
virtual int \mbox{\hyperlink{classhandler_a886bf2fbf16de7e200e3ebc0765fb6e4}{exec\+\_\+bulk\+\_\+update}} (uint $\ast$dup\+\_\+key\+\_\+found)
\item 
virtual void \mbox{\hyperlink{classhandler_a2bf6c46d66ca282a4cbd6118e4c99e03}{end\+\_\+bulk\+\_\+update}} ()
\item 
virtual int \mbox{\hyperlink{classhandler_af5f9f1ca2b5efc0b41e96c6b793d9bb1}{end\+\_\+bulk\+\_\+delete}} ()
\item 
virtual int \mbox{\hyperlink{classhandler_ad17ab5ed40c1eab55ce74ce2465c9bff}{prepare\+\_\+index\+\_\+scan}} (void)
\item 
virtual int \mbox{\hyperlink{classhandler_aa111c313513f50300e9740aeb3e4cfc4}{prepare\+\_\+range\+\_\+scan}} (const key\+\_\+range $\ast$start\+\_\+key, const key\+\_\+range $\ast$end\+\_\+key)
\item 
int \mbox{\hyperlink{classhandler_a4906703169a1e43358e2d95f0d90e911}{prepare\+\_\+index\+\_\+key\+\_\+scan\+\_\+map}} (const uchar $\ast$key, key\+\_\+part\+\_\+map keypart\+\_\+map)
\item 
virtual bool \mbox{\hyperlink{classhandler_a7605ac9185a544f444604f11d61f6722}{has\+\_\+gap\+\_\+locks}} () const
\item 
virtual bool \mbox{\hyperlink{classhandler_af0be0637dfaf4fc4a2dc89334c350ec7}{rpl\+\_\+can\+\_\+handle\+\_\+stm\+\_\+event}} () const
\item 
virtual int \mbox{\hyperlink{classhandler_a3a0d596ff3ddc77b4f0ad990c4c4cb4b}{read\+\_\+range\+\_\+first}} (const key\+\_\+range $\ast$start\+\_\+key, const key\+\_\+range $\ast$end\+\_\+key, bool eq\+\_\+range, bool sorted)
\begin{DoxyCompactList}\small\item\em Read first row between two ranges. Store ranges for future calls to read\+\_\+range\+\_\+next. \end{DoxyCompactList}\item 
virtual int \mbox{\hyperlink{classhandler_ae4632aa56c9c66a57558f849f8e01271}{read\+\_\+range\+\_\+next}} ()
\begin{DoxyCompactList}\small\item\em Read next row between two endpoints. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhandler_a4b7dfb95a0da2e828ac018aa2b4abe3a}{set\+\_\+end\+\_\+range}} (const key\+\_\+range $\ast$range, enum\+\_\+range\+\_\+scan\+\_\+direction direction)
\item 
int \mbox{\hyperlink{classhandler_af0ef38e7407e87ba5d1ccde59c3e94bb}{compare\+\_\+key}} (key\+\_\+range $\ast$range)
\item 
\mbox{\Hypertarget{classhandler_ab767345668267e3c8881fab6e351e6c8}\label{classhandler_ab767345668267e3c8881fab6e351e6c8}} 
int {\bfseries compare\+\_\+key\+\_\+icp} (const key\+\_\+range $\ast$range) const
\item 
int \mbox{\hyperlink{classhandler_aeac3d9b9796d3bfb18b96a1989d6f516}{compare\+\_\+key\+\_\+in\+\_\+buffer}} (const uchar $\ast$buf) const
\item 
\mbox{\Hypertarget{classhandler_ab734678f90b9e7cc6b000047f7c89bb1}\label{classhandler_ab734678f90b9e7cc6b000047f7c89bb1}} 
virtual int {\bfseries ft\+\_\+init} ()
\item 
\mbox{\Hypertarget{classhandler_a72693b6e25765a4290f531f578bcf2eb}\label{classhandler_a72693b6e25765a4290f531f578bcf2eb}} 
void {\bfseries ft\+\_\+end} ()
\item 
\mbox{\Hypertarget{classhandler_a109448e09ee2c456b1471b74bb9eb8e6}\label{classhandler_a109448e09ee2c456b1471b74bb9eb8e6}} 
virtual F\+T\+\_\+\+I\+N\+FO $\ast$ {\bfseries ft\+\_\+init\+\_\+ext} (uint flags, uint inx, String $\ast$key)
\item 
\mbox{\Hypertarget{classhandler_a9ceb6075e1b3ad667596b30eea85feb6}\label{classhandler_a9ceb6075e1b3ad667596b30eea85feb6}} 
virtual F\+T\+\_\+\+I\+N\+FO $\ast$ {\bfseries ft\+\_\+init\+\_\+ext\+\_\+with\+\_\+hints} (uint inx, String $\ast$key, \mbox{\hyperlink{classFt__hints}{Ft\+\_\+hints}} $\ast$hints)
\item 
\mbox{\Hypertarget{classhandler_a0c965ae56bcceee3cf63ce0320a5d31b}\label{classhandler_a0c965ae56bcceee3cf63ce0320a5d31b}} 
virtual int {\bfseries ft\+\_\+read} (uchar $\ast$buf)
\item 
virtual int \mbox{\hyperlink{classhandler_ac2be2fa5d347252f8a28dce931654b76}{rnd\+\_\+pos\+\_\+by\+\_\+record}} (uchar $\ast$record)
\item 
virtual int \mbox{\hyperlink{classhandler_aff50b704d53d715d6b0fd3534c6107d8}{read\+\_\+first\+\_\+row}} (uchar $\ast$buf, uint primary\+\_\+key)
\item 
\mbox{\Hypertarget{classhandler_a33ac874ad6fd5a2e6b97376befacb165}\label{classhandler_a33ac874ad6fd5a2e6b97376befacb165}} 
virtual ha\+\_\+rows {\bfseries records\+\_\+in\+\_\+range} (uint inx, key\+\_\+range $\ast$min\+\_\+key, key\+\_\+range $\ast$max\+\_\+key)
\item 
\mbox{\Hypertarget{classhandler_ad3c1515e7a936fa9cbc19f93d43495b6}\label{classhandler_ad3c1515e7a936fa9cbc19f93d43495b6}} 
virtual void {\bfseries position} (const uchar $\ast$record)=0
\item 
\mbox{\Hypertarget{classhandler_ab39a38e4a875151379cacd0da1a789c8}\label{classhandler_ab39a38e4a875151379cacd0da1a789c8}} 
virtual int {\bfseries info} (uint)=0
\item 
\mbox{\Hypertarget{classhandler_a7e746c224b70d3b03b2886ecf4563394}\label{classhandler_a7e746c224b70d3b03b2886ecf4563394}} 
virtual uint32 {\bfseries calculate\+\_\+key\+\_\+hash\+\_\+value} (\mbox{\hyperlink{classField}{Field}} $\ast$$\ast$field\+\_\+array)
\item 
\mbox{\Hypertarget{classhandler_a2b7687330aaf0d97540db07ab436e349}\label{classhandler_a2b7687330aaf0d97540db07ab436e349}} 
virtual int {\bfseries extra} (enum ha\+\_\+extra\+\_\+function operation)
\item 
\mbox{\Hypertarget{classhandler_a6b7e72da94a7f5577f00ab5c89204ec1}\label{classhandler_a6b7e72da94a7f5577f00ab5c89204ec1}} 
virtual int {\bfseries extra\+\_\+opt} (enum ha\+\_\+extra\+\_\+function operation, ulong cache\+\_\+size)
\item 
virtual bool \mbox{\hyperlink{classhandler_a3e2428788c2437e4e33c4b390cc697f7}{start\+\_\+read\+\_\+removal}} (void)
\item 
virtual ha\+\_\+rows \mbox{\hyperlink{classhandler_a517d99c283e85e8d97460f07a781dabf}{end\+\_\+read\+\_\+removal}} (void)
\item 
virtual bool \mbox{\hyperlink{classhandler_a54d92f647a4ca5a3b7867fa5538242a6}{was\+\_\+semi\+\_\+consistent\+\_\+read}} ()
\item 
virtual void \mbox{\hyperlink{classhandler_ab3e767094bff139a26743e9314df8476}{try\+\_\+semi\+\_\+consistent\+\_\+read}} (bool)
\item 
\mbox{\Hypertarget{classhandler_a48e6fd090f73a8e7e5e94769c9a10733}\label{classhandler_a48e6fd090f73a8e7e5e94769c9a10733}} 
virtual void {\bfseries unlock\+\_\+row} ()
\item 
\mbox{\Hypertarget{classhandler_a90c625117fcff640b7af11e7018519cd}\label{classhandler_a90c625117fcff640b7af11e7018519cd}} 
virtual int {\bfseries start\+\_\+stmt} (T\+HD $\ast$thd, thr\+\_\+lock\+\_\+type lock\+\_\+type)
\item 
virtual void \mbox{\hyperlink{classhandler_aaf6af760a4ef09984a5cc1dc58db9a40}{get\+\_\+auto\+\_\+increment}} (ulonglong offset, ulonglong increment, ulonglong nb\+\_\+desired\+\_\+values, ulonglong $\ast$first\+\_\+value, ulonglong $\ast$nb\+\_\+reserved\+\_\+values)
\item 
\mbox{\Hypertarget{classhandler_ab6f9bf8ee63f3b8312fdc31be3819ede}\label{classhandler_ab6f9bf8ee63f3b8312fdc31be3819ede}} 
void {\bfseries set\+\_\+next\+\_\+insert\+\_\+id} (ulonglong id)
\item 
\mbox{\Hypertarget{classhandler_a15b51670b2497f01f19f587a4a969386}\label{classhandler_a15b51670b2497f01f19f587a4a969386}} 
void {\bfseries restore\+\_\+auto\+\_\+increment} (ulonglong \mbox{\hyperlink{handler_8cc_ae9f796d8fbc7dc812557a17547b8e69e}{prev\+\_\+insert\+\_\+id}})
\item 
\mbox{\Hypertarget{classhandler_ae15661ad009adb5b5b616928ba57c1a3}\label{classhandler_ae15661ad009adb5b5b616928ba57c1a3}} 
virtual void {\bfseries adjust\+\_\+create\+\_\+info\+\_\+for\+\_\+frm} (\mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$create\+\_\+info)
\item 
\mbox{\Hypertarget{classhandler_a58141e7b51aaf97bdf63ea68c411f401}\label{classhandler_a58141e7b51aaf97bdf63ea68c411f401}} 
virtual void {\bfseries update\+\_\+create\+\_\+info} (\mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$create\+\_\+info)
\item 
\mbox{\Hypertarget{classhandler_a1abc92ca74cd6aca9a6070a186ced4cb}\label{classhandler_a1abc92ca74cd6aca9a6070a186ced4cb}} 
int {\bfseries check\+\_\+old\+\_\+types} ()
\item 
\mbox{\Hypertarget{classhandler_ab1b5fa7360fc536082f495ee7e09bcba}\label{classhandler_ab1b5fa7360fc536082f495ee7e09bcba}} 
virtual int {\bfseries assign\+\_\+to\+\_\+keycache} (T\+HD $\ast$thd, \mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
\mbox{\Hypertarget{classhandler_a0061ab331631179647ccdbd71960ba37}\label{classhandler_a0061ab331631179647ccdbd71960ba37}} 
virtual int {\bfseries preload\+\_\+keys} (T\+HD $\ast$thd, \mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
\mbox{\Hypertarget{classhandler_a8bc45e93a1b669fa750f73a617c46bac}\label{classhandler_a8bc45e93a1b669fa750f73a617c46bac}} 
virtual int {\bfseries indexes\+\_\+are\+\_\+disabled} (void)
\item 
\mbox{\Hypertarget{classhandler_a441afeebcb5b56e598fb7f860c9247d1}\label{classhandler_a441afeebcb5b56e598fb7f860c9247d1}} 
virtual void {\bfseries append\+\_\+create\+\_\+info} (String $\ast$packet)
\item 
virtual bool \mbox{\hyperlink{classhandler_adda33331aacc500b1b974033cb64a869}{is\+\_\+fk\+\_\+defined\+\_\+on\+\_\+table\+\_\+or\+\_\+index}} (uint index)
\item 
\mbox{\Hypertarget{classhandler_a8712abc71df0d89559e2861c100a8e3e}\label{classhandler_a8712abc71df0d89559e2861c100a8e3e}} 
virtual char $\ast$ {\bfseries get\+\_\+foreign\+\_\+key\+\_\+create\+\_\+info} ()
\item 
virtual bool \mbox{\hyperlink{classhandler_a6baab93a22543b707e6e59b9d59810d2}{can\+\_\+switch\+\_\+engines}} ()
\item 
virtual int \mbox{\hyperlink{classhandler_a81064e61d4c08261af409fb6ee34e3ca}{get\+\_\+foreign\+\_\+key\+\_\+list}} (T\+HD $\ast$thd, \mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{structst__foreign__key__info}{F\+O\+R\+E\+I\+G\+N\+\_\+\+K\+E\+Y\+\_\+\+I\+N\+FO}} $>$ $\ast$f\+\_\+key\+\_\+list)
\item 
virtual int \mbox{\hyperlink{classhandler_a9187eea9999eba802ee4ae01f91dda3b}{get\+\_\+parent\+\_\+foreign\+\_\+key\+\_\+list}} (T\+HD $\ast$thd, \mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{structst__foreign__key__info}{F\+O\+R\+E\+I\+G\+N\+\_\+\+K\+E\+Y\+\_\+\+I\+N\+FO}} $>$ $\ast$f\+\_\+key\+\_\+list)
\item 
virtual int \mbox{\hyperlink{classhandler_a683eef70b4481c3bc0b10336e179de27}{get\+\_\+cascade\+\_\+foreign\+\_\+key\+\_\+table\+\_\+list}} (T\+HD $\ast$thd, \mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{structst__handler__tablename}{st\+\_\+handler\+\_\+tablename}} $>$ $\ast$fk\+\_\+table\+\_\+list)
\item 
\mbox{\Hypertarget{classhandler_a28b038c18aeb8114376725e6f8d39871}\label{classhandler_a28b038c18aeb8114376725e6f8d39871}} 
virtual uint {\bfseries referenced\+\_\+by\+\_\+foreign\+\_\+key} ()
\item 
\mbox{\Hypertarget{classhandler_a28dfb73f9401996a25b9cf925db74149}\label{classhandler_a28dfb73f9401996a25b9cf925db74149}} 
virtual void {\bfseries init\+\_\+table\+\_\+handle\+\_\+for\+\_\+\+H\+A\+N\+D\+L\+ER} ()
\item 
\mbox{\Hypertarget{classhandler_aa4457d47baa6d136af65e041da4fe9e0}\label{classhandler_aa4457d47baa6d136af65e041da4fe9e0}} 
virtual void {\bfseries free\+\_\+foreign\+\_\+key\+\_\+create\+\_\+info} (char $\ast$str)
\item 
virtual const char $\ast$ \mbox{\hyperlink{classhandler_ad38f5d3f1e026a0af32b5542aa5ac2f9}{table\+\_\+type}} () const =0
\item 
virtual const char $\ast$$\ast$ \mbox{\hyperlink{classhandler_a748d5e5b6dbbb0681cbac2ad881505c9}{bas\+\_\+ext}} () const =0
\item 
\mbox{\Hypertarget{classhandler_a612375d87a4cbb6e7c190ea7d05cf945}\label{classhandler_a612375d87a4cbb6e7c190ea7d05cf945}} 
virtual ulong {\bfseries index\+\_\+flags} (uint idx, uint part, bool all\+\_\+parts) const =0
\item 
\mbox{\Hypertarget{classhandler_a7ee9c5a03956913d75de1fca3af7833a}\label{classhandler_a7ee9c5a03956913d75de1fca3af7833a}} 
uint {\bfseries max\+\_\+record\+\_\+length} () const
\item 
\mbox{\Hypertarget{classhandler_a493c1ac62569e6cc89cbfde66fea47f3}\label{classhandler_a493c1ac62569e6cc89cbfde66fea47f3}} 
uint {\bfseries max\+\_\+keys} () const
\item 
\mbox{\Hypertarget{classhandler_a1adabba96b635533f31d5e38e6d2a74c}\label{classhandler_a1adabba96b635533f31d5e38e6d2a74c}} 
uint {\bfseries max\+\_\+key\+\_\+parts} () const
\item 
\mbox{\Hypertarget{classhandler_a9e1b1d6fe7e717fe234c18915cb26e87}\label{classhandler_a9e1b1d6fe7e717fe234c18915cb26e87}} 
uint {\bfseries max\+\_\+key\+\_\+length} () const
\item 
\mbox{\Hypertarget{classhandler_a4fa0c2a89e52a27667973c1d5074dca7}\label{classhandler_a4fa0c2a89e52a27667973c1d5074dca7}} 
uint {\bfseries max\+\_\+key\+\_\+part\+\_\+length} () const
\item 
\mbox{\Hypertarget{classhandler_a672a498859c2d47448100e5e703622bb}\label{classhandler_a672a498859c2d47448100e5e703622bb}} 
virtual uint {\bfseries max\+\_\+supported\+\_\+record\+\_\+length} () const
\item 
\mbox{\Hypertarget{classhandler_a9c7b335988ea24ea8b685c4278442cf8}\label{classhandler_a9c7b335988ea24ea8b685c4278442cf8}} 
virtual uint {\bfseries max\+\_\+supported\+\_\+keys} () const
\item 
\mbox{\Hypertarget{classhandler_a25d5b6de2843435371dc9045403e3d07}\label{classhandler_a25d5b6de2843435371dc9045403e3d07}} 
virtual uint {\bfseries max\+\_\+supported\+\_\+key\+\_\+parts} () const
\item 
\mbox{\Hypertarget{classhandler_a0c2216dba316fe13117f00e8d21cbdab}\label{classhandler_a0c2216dba316fe13117f00e8d21cbdab}} 
virtual uint {\bfseries max\+\_\+supported\+\_\+key\+\_\+length} () const
\item 
\mbox{\Hypertarget{classhandler_a9209ad97772dc4c6c0398fe11296d3ac}\label{classhandler_a9209ad97772dc4c6c0398fe11296d3ac}} 
virtual uint {\bfseries max\+\_\+supported\+\_\+key\+\_\+part\+\_\+length} () const
\item 
\mbox{\Hypertarget{classhandler_ab082d2a49764e8548b8104dc514877b3}\label{classhandler_ab082d2a49764e8548b8104dc514877b3}} 
virtual uint {\bfseries min\+\_\+record\+\_\+length} (uint options) const
\item 
\mbox{\Hypertarget{classhandler_a64a20da13aaa177f1a256e5fb63e7c78}\label{classhandler_a64a20da13aaa177f1a256e5fb63e7c78}} 
virtual bool {\bfseries low\+\_\+byte\+\_\+first} () const
\item 
\mbox{\Hypertarget{classhandler_ad00ca688822b5d3c9db5ce5d6a982b44}\label{classhandler_ad00ca688822b5d3c9db5ce5d6a982b44}} 
virtual ha\+\_\+checksum {\bfseries checksum} () const
\item 
\mbox{\Hypertarget{classhandler_a6ea4b726707284210cc365ad454add03}\label{classhandler_a6ea4b726707284210cc365ad454add03}} 
virtual bool {\bfseries is\+\_\+crashed} () const
\item 
\mbox{\Hypertarget{classhandler_aca08387779d587f8d3ea84b965ddc391}\label{classhandler_aca08387779d587f8d3ea84b965ddc391}} 
virtual bool {\bfseries auto\+\_\+repair} () const
\item 
\mbox{\Hypertarget{classhandler_a272b467ea09dc8f1f10389d7238628c1}\label{classhandler_a272b467ea09dc8f1f10389d7238628c1}} 
void {\bfseries update\+\_\+global\+\_\+table\+\_\+stats} ()
\item 
\mbox{\Hypertarget{classhandler_ad44b5d08ef9b62044cf44f0e6674806a}\label{classhandler_ad44b5d08ef9b62044cf44f0e6674806a}} 
void {\bfseries update\+\_\+global\+\_\+index\+\_\+stats} ()
\item 
\mbox{\Hypertarget{classhandler_a1c19b28238d94f029351ecaee0aba007}\label{classhandler_a1c19b28238d94f029351ecaee0aba007}} 
void {\bfseries update\+\_\+index\+\_\+stats} (uint current\+\_\+index)
\item 
virtual uint \mbox{\hyperlink{classhandler_a2447668275a831bcf73b5c00818254a6}{lock\+\_\+count}} (void) const
\item 
virtual T\+H\+R\+\_\+\+L\+O\+C\+K\+\_\+\+D\+A\+TA $\ast$$\ast$ \mbox{\hyperlink{classhandler_a2502e460566f2c4b506cc1b30eb79e0a}{store\+\_\+lock}} (T\+HD $\ast$thd, T\+H\+R\+\_\+\+L\+O\+C\+K\+\_\+\+D\+A\+TA $\ast$$\ast$to, enum thr\+\_\+lock\+\_\+type lock\+\_\+type)=0
\item 
virtual uint8 \mbox{\hyperlink{classhandler_ab4d7cf309121ec10e4150860c8caa12a}{table\+\_\+cache\+\_\+type}} ()
\item 
virtual my\+\_\+bool \mbox{\hyperlink{classhandler_af42324038f030519d7476bf915780341}{register\+\_\+query\+\_\+cache\+\_\+table}} (T\+HD $\ast$thd, char $\ast$table\+\_\+key, size\+\_\+t key\+\_\+length, qc\+\_\+engine\+\_\+callback $\ast$engine\+\_\+callback, ulonglong $\ast$engine\+\_\+data)
\begin{DoxyCompactList}\small\item\em Register a named table with a call back function to the query cache. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{classhandler_a1c885f4b3b5bf6d2878225a188b5599f}{primary\+\_\+key\+\_\+is\+\_\+clustered}} () const
\item 
\mbox{\Hypertarget{classhandler_a4ff2afe807f7e2bbdddb397ee65626ee}\label{classhandler_a4ff2afe807f7e2bbdddb397ee65626ee}} 
virtual int {\bfseries cmp\+\_\+ref} (const uchar $\ast$ref1, const uchar $\ast$ref2)
\item 
virtual const \mbox{\hyperlink{classItem}{Item}} $\ast$ \mbox{\hyperlink{classhandler_a5e765264bd31e0519e03e1bd53d8c6d2}{cond\+\_\+push}} (const \mbox{\hyperlink{classItem}{Item}} $\ast$cond)
\item 
virtual void \mbox{\hyperlink{classhandler_ac3eb8d2966b848ec4beea5a25cba9dea}{cond\+\_\+pop}} ()
\item 
virtual \mbox{\hyperlink{classItem}{Item}} $\ast$ \mbox{\hyperlink{classhandler_a0bb554282443af443fc8aae4533e1407}{idx\+\_\+cond\+\_\+push}} (uint keyno, \mbox{\hyperlink{classItem}{Item}} $\ast$idx\+\_\+cond)
\item 
virtual void \mbox{\hyperlink{classhandler_a41cc6ba204aa4d1bacc35d9d1d75ab15}{cancel\+\_\+pushed\+\_\+idx\+\_\+cond}} ()
\item 
virtual uint \mbox{\hyperlink{classhandler_a86930bf10b20ad19b3df07e07d28116e}{number\+\_\+of\+\_\+pushed\+\_\+joins}} () const
\item 
virtual const \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$ \mbox{\hyperlink{classhandler_a624f6946109f48559e92a9e7c1b86517}{root\+\_\+of\+\_\+pushed\+\_\+join}} () const
\item 
virtual const \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$ \mbox{\hyperlink{classhandler_aaef865015edc575d0a50d1a6f5b13e4a}{parent\+\_\+of\+\_\+pushed\+\_\+join}} () const
\item 
\mbox{\Hypertarget{classhandler_a38213f889f5312cd3e452fc34d11a201}\label{classhandler_a38213f889f5312cd3e452fc34d11a201}} 
virtual int {\bfseries index\+\_\+read\+\_\+pushed} (uchar $\ast$buf, const uchar $\ast$key, key\+\_\+part\+\_\+map keypart\+\_\+map)
\item 
\mbox{\Hypertarget{classhandler_a5f56e97f4fb1faebbc23145492bf541d}\label{classhandler_a5f56e97f4fb1faebbc23145492bf541d}} 
virtual int {\bfseries index\+\_\+next\+\_\+pushed} (uchar $\ast$buf)
\item 
virtual bool \mbox{\hyperlink{classhandler_a36d800c8dafbc9efde9af932305529e4}{check\+\_\+if\+\_\+incompatible\+\_\+data}} (\mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$create\+\_\+info, uint table\+\_\+changes)
\item 
virtual enum\+\_\+alter\+\_\+inplace\+\_\+result \mbox{\hyperlink{classhandler_a67890a9deb89b9ef0128601e7687fcba}{check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter}} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$altered\+\_\+table, \mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$ha\+\_\+alter\+\_\+info)
\item 
bool \mbox{\hyperlink{classhandler_ad0ecf7f9bf265e6801b625768f0f2bbe}{ha\+\_\+prepare\+\_\+inplace\+\_\+alter\+\_\+table}} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$altered\+\_\+table, \mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$ha\+\_\+alter\+\_\+info)
\item 
bool \mbox{\hyperlink{classhandler_a96b182710a133be9561afc149cb6aa8f}{ha\+\_\+inplace\+\_\+alter\+\_\+table}} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$altered\+\_\+table, \mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$ha\+\_\+alter\+\_\+info)
\item 
bool \mbox{\hyperlink{classhandler_a6ec170a4aa71186f9dc17358b55587c7}{ha\+\_\+commit\+\_\+inplace\+\_\+alter\+\_\+table}} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$altered\+\_\+table, \mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$ha\+\_\+alter\+\_\+info, bool commit)
\item 
void \mbox{\hyperlink{classhandler_a5b81b74b0b7b87de4f99ebe20c49dc44}{ha\+\_\+notify\+\_\+table\+\_\+changed}} ()
\item 
\mbox{\Hypertarget{classhandler_acfd590a8a08e54f45fbbc250825764d1}\label{classhandler_acfd590a8a08e54f45fbbc250825764d1}} 
M\+Y\+\_\+\+N\+O\+D\+I\+S\+C\+A\+RD int \mbox{\hyperlink{classhandler_acfd590a8a08e54f45fbbc250825764d1}{ha\+\_\+fast\+\_\+update}} (T\+HD $\ast$thd, \mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{classItem}{Item}} $>$ \&update\+\_\+fields, \mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{classItem}{Item}} $>$ \&update\+\_\+values, \mbox{\hyperlink{classItem}{Item}} $\ast$conds)
\begin{DoxyCompactList}\small\item\em Offload an update to the storage engine. See handler\+::fast\+\_\+update() for details. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classhandler_a84c0b213c30476cce68a11c0f00bb9c3}\label{classhandler_a84c0b213c30476cce68a11c0f00bb9c3}} 
M\+Y\+\_\+\+N\+O\+D\+I\+S\+C\+A\+RD int \mbox{\hyperlink{classhandler_a84c0b213c30476cce68a11c0f00bb9c3}{ha\+\_\+upsert}} (T\+HD $\ast$thd, \mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{classItem}{Item}} $>$ \&update\+\_\+fields, \mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{classItem}{Item}} $>$ \&update\+\_\+values)
\begin{DoxyCompactList}\small\item\em Offload an upsert to the storage engine. See handler\+::upsert() for details. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classhandler_adac21f2d10c4463fb1d7e14882c6314f}{use\+\_\+hidden\+\_\+primary\+\_\+key}} ()
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classhandler_adac21f2d10c4463fb1d7e14882c6314f}{use\+\_\+hidden\+\_\+primary\+\_\+key()}} is called in case of an update/delete when (table\+\_\+flags() and H\+A\+\_\+\+P\+R\+I\+M\+A\+R\+Y\+\_\+\+K\+E\+Y\+\_\+\+R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+F\+O\+R\+\_\+\+D\+E\+L\+E\+TE) is defined but we don\textquotesingle{}t have a primary key \end{DoxyCompactList}\item 
virtual int \mbox{\hyperlink{classhandler_ac8dd7e44bc71120ace1e467ccb02ad06}{bulk\+\_\+update\+\_\+row}} (const uchar $\ast$old\+\_\+data, uchar $\ast$new\+\_\+data, uint $\ast$dup\+\_\+key\+\_\+found)
\item 
virtual int \mbox{\hyperlink{classhandler_ac24fcaab09a75e81702c2e2c34fa0b62}{delete\+\_\+all\+\_\+rows}} ()
\item 
virtual int \mbox{\hyperlink{classhandler_a13fdf15d81c256d3e6a9643532ff2126}{truncate}} ()
\item 
\mbox{\Hypertarget{classhandler_a6916ee6d1e764fa795128fd46164f40d}\label{classhandler_a6916ee6d1e764fa795128fd46164f40d}} 
virtual int {\bfseries optimize} (T\+HD $\ast$thd, \mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
\mbox{\Hypertarget{classhandler_a85dd48aaf0c97e43f02180b45517c4c2}\label{classhandler_a85dd48aaf0c97e43f02180b45517c4c2}} 
virtual int {\bfseries analyze} (T\+HD $\ast$thd, \mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$check\+\_\+opt)
\item 
\mbox{\Hypertarget{classhandler_ac9c1378edb4813d141f666ce2b9382a4}\label{classhandler_ac9c1378edb4813d141f666ce2b9382a4}} 
virtual bool {\bfseries check\+\_\+and\+\_\+repair} (T\+HD $\ast$thd)
\item 
\mbox{\Hypertarget{classhandler_a272e3a0622ad461a5a86c74ddb9289c6}\label{classhandler_a272e3a0622ad461a5a86c74ddb9289c6}} 
virtual int {\bfseries disable\+\_\+indexes} (uint mode)
\item 
\mbox{\Hypertarget{classhandler_a22328b49eac2417561360bd00bbe8299}\label{classhandler_a22328b49eac2417561360bd00bbe8299}} 
virtual int {\bfseries enable\+\_\+indexes} (uint mode)
\item 
\mbox{\Hypertarget{classhandler_a561768da16278d66deec08261111dbef}\label{classhandler_a561768da16278d66deec08261111dbef}} 
virtual int {\bfseries discard\+\_\+or\+\_\+import\+\_\+tablespace} (my\+\_\+bool discard)
\item 
\mbox{\Hypertarget{classhandler_ac61d474cf912188a562e9f419872031e}\label{classhandler_ac61d474cf912188a562e9f419872031e}} 
virtual void {\bfseries drop\+\_\+table} (const char $\ast$name)
\item 
\mbox{\Hypertarget{classhandler_a741fbc5479d9ee0ccca766f3eca3703f}\label{classhandler_a741fbc5479d9ee0ccca766f3eca3703f}} 
virtual int {\bfseries create} (const char $\ast$name, \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$form, \mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$info)=0
\item 
\mbox{\Hypertarget{classhandler_a75fe1bf5cf87a258787ca67a2add8bd1}\label{classhandler_a75fe1bf5cf87a258787ca67a2add8bd1}} 
virtual int {\bfseries create\+\_\+handler\+\_\+files} (const char $\ast$name, const char $\ast$old\+\_\+name, int action\+\_\+flag, \mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$info)
\item 
\mbox{\Hypertarget{classhandler_ae370a0f787c1b936e475a5762b91350c}\label{classhandler_ae370a0f787c1b936e475a5762b91350c}} 
virtual bool {\bfseries set\+\_\+ha\+\_\+share\+\_\+ref} (\mbox{\hyperlink{classHandler__share}{Handler\+\_\+share}} $\ast$$\ast$arg\+\_\+ha\+\_\+share)
\item 
\mbox{\Hypertarget{classhandler_a6a271a4a135d110cf6f22ae8ce664664}\label{classhandler_a6a271a4a135d110cf6f22ae8ce664664}} 
int {\bfseries get\+\_\+lock\+\_\+type} () const
\item 
virtual void \mbox{\hyperlink{classhandler_af07d741fb837dacdddc29c1d7e912204}{update\+\_\+field\+\_\+defs\+\_\+with\+\_\+zip\+\_\+dict\+\_\+info}} (T\+HD $\ast$thd, const char $\ast$part\+\_\+name)
\item 
virtual bool \mbox{\hyperlink{classhandler_a5f01ea7ce530c3a234e5d17363204f13}{rpl\+\_\+lookup\+\_\+rows}} ()
\item 
\mbox{\Hypertarget{classhandler_ade620586d26510ba599c3e7975e8cf39}\label{classhandler_ade620586d26510ba599c3e7975e8cf39}} 
virtual void {\bfseries rpl\+\_\+before\+\_\+write\+\_\+rows} ()
\item 
\mbox{\Hypertarget{classhandler_a5b7bc641b76ed6ba8db016baea0d9f00}\label{classhandler_a5b7bc641b76ed6ba8db016baea0d9f00}} 
virtual void {\bfseries rpl\+\_\+after\+\_\+write\+\_\+rows} ()
\item 
\mbox{\Hypertarget{classhandler_a6f06882513fd3b53eee1d20bd0a90d46}\label{classhandler_a6f06882513fd3b53eee1d20bd0a90d46}} 
virtual void {\bfseries rpl\+\_\+before\+\_\+delete\+\_\+rows} ()
\item 
\mbox{\Hypertarget{classhandler_a6fa3ebfc3bd1ffa26915db17c452837b}\label{classhandler_a6fa3ebfc3bd1ffa26915db17c452837b}} 
virtual void {\bfseries rpl\+\_\+after\+\_\+delete\+\_\+rows} ()
\item 
\mbox{\Hypertarget{classhandler_a7f22d5f23dfc16185c7e8f8776fc7fc3}\label{classhandler_a7f22d5f23dfc16185c7e8f8776fc7fc3}} 
virtual void {\bfseries rpl\+\_\+before\+\_\+update\+\_\+rows} ()
\item 
\mbox{\Hypertarget{classhandler_a44a966e76173a3c1eb0d8afa8a9acce9}\label{classhandler_a44a966e76173a3c1eb0d8afa8a9acce9}} 
virtual void {\bfseries rpl\+\_\+after\+\_\+update\+\_\+rows} ()
\item 
\mbox{\Hypertarget{classhandler_a6dad27a5b6b7320e6270138f7d5a0a30}\label{classhandler_a6dad27a5b6b7320e6270138f7d5a0a30}} 
virtual Partition\+\_\+handler $\ast$ {\bfseries get\+\_\+partition\+\_\+handler} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{classhandler_aa6c449e2194c590eb53b6a6b5dbb362c}{my\+\_\+prepare\+\_\+gcolumn\+\_\+template}} (T\+HD $\ast$thd, const char $\ast$db\+\_\+name, const char $\ast$table\+\_\+name, \mbox{\hyperlink{classhandler_ad4c241e50948859d98ceae6e39066838}{my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t}} myc, void $\ast$ib\+\_\+table)
\item 
static bool \mbox{\hyperlink{classhandler_a32dd6a07c4f58be3273576d0cc813933}{my\+\_\+eval\+\_\+gcolumn\+\_\+expr\+\_\+with\+\_\+open}} (T\+HD $\ast$thd, const char $\ast$db\+\_\+name, const char $\ast$table\+\_\+name, const M\+Y\+\_\+\+B\+I\+T\+M\+AP $\ast$const fields, uchar $\ast$record)
\item 
static bool \mbox{\hyperlink{classhandler_a39b30a208b304f519e8d74070a41ac19}{my\+\_\+eval\+\_\+gcolumn\+\_\+expr}} (T\+HD $\ast$thd, \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$table, const M\+Y\+\_\+\+B\+I\+T\+M\+AP $\ast$const fields, uchar $\ast$record)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classhandler_a395bae75af9e51a116097a788b2cf57f}\label{classhandler_a395bae75af9e51a116097a788b2cf57f}} 
\mbox{\hyperlink{structhandlerton}{handlerton}} $\ast$ {\bfseries ht}
\item 
\mbox{\Hypertarget{classhandler_a53c7037216007ba6140e6cff5162024d}\label{classhandler_a53c7037216007ba6140e6cff5162024d}} 
uchar $\ast$ {\bfseries ref}
\item 
\mbox{\Hypertarget{classhandler_a7501dc41ecb010069e8bc9d035aae6aa}\label{classhandler_a7501dc41ecb010069e8bc9d035aae6aa}} 
uchar $\ast$ {\bfseries dup\+\_\+ref}
\item 
\mbox{\Hypertarget{classhandler_a1df561df4b2b6552a7b42189feb0400a}\label{classhandler_a1df561df4b2b6552a7b42189feb0400a}} 
\mbox{\hyperlink{classha__statistics}{ha\+\_\+statistics}} {\bfseries stats}
\item 
\mbox{\Hypertarget{classhandler_a9ec520eba79eb9f182c534e82c60ebc6}\label{classhandler_a9ec520eba79eb9f182c534e82c60ebc6}} 
range\+\_\+seq\+\_\+t {\bfseries mrr\+\_\+iter}
\item 
\mbox{\Hypertarget{classhandler_a2a51e423645829d3e540c109556931fa}\label{classhandler_a2a51e423645829d3e540c109556931fa}} 
\mbox{\hyperlink{structst__range__seq__if}{R\+A\+N\+G\+E\+\_\+\+S\+E\+Q\+\_\+\+IF}} {\bfseries mrr\+\_\+funcs}
\item 
\mbox{\Hypertarget{classhandler_a52372127bd238a7f622190316ba8124f}\label{classhandler_a52372127bd238a7f622190316ba8124f}} 
\mbox{\hyperlink{structst__handler__buffer}{H\+A\+N\+D\+L\+E\+R\+\_\+\+B\+U\+F\+F\+ER}} $\ast$ {\bfseries multi\+\_\+range\+\_\+buffer}
\item 
\mbox{\Hypertarget{classhandler_a1a476dfe8526807dfc820c4b09f7a6d1}\label{classhandler_a1a476dfe8526807dfc820c4b09f7a6d1}} 
uint {\bfseries ranges\+\_\+in\+\_\+seq}
\item 
\mbox{\Hypertarget{classhandler_adff4dfb21c4583b55afc4fe5aba50389}\label{classhandler_adff4dfb21c4583b55afc4fe5aba50389}} 
bool {\bfseries mrr\+\_\+is\+\_\+output\+\_\+sorted}
\item 
\mbox{\Hypertarget{classhandler_af2632d137c3a17fa583f08db5681e80a}\label{classhandler_af2632d137c3a17fa583f08db5681e80a}} 
bool {\bfseries mrr\+\_\+have\+\_\+range}
\item 
\mbox{\Hypertarget{classhandler_af2347edc229832e533d1fb73b236e32b}\label{classhandler_af2347edc229832e533d1fb73b236e32b}} 
K\+E\+Y\+\_\+\+M\+U\+L\+T\+I\+\_\+\+R\+A\+N\+GE {\bfseries mrr\+\_\+cur\+\_\+range}
\item 
\mbox{\Hypertarget{classhandler_a28d698fe9901f0f487c9618ddbb0f1be}\label{classhandler_a28d698fe9901f0f487c9618ddbb0f1be}} 
key\+\_\+range $\ast$ {\bfseries end\+\_\+range}
\item 
\mbox{\Hypertarget{classhandler_a3186b7c7a70634a8e9758ed51708359c}\label{classhandler_a3186b7c7a70634a8e9758ed51708359c}} 
uint {\bfseries errkey}
\item 
\mbox{\Hypertarget{classhandler_a5ad5efc62f32ef66b55667fd8370ef33}\label{classhandler_a5ad5efc62f32ef66b55667fd8370ef33}} 
uint {\bfseries key\+\_\+used\+\_\+on\+\_\+scan}
\item 
\mbox{\Hypertarget{classhandler_a29f2838eebffef46663c19f85d2ad2cc}\label{classhandler_a29f2838eebffef46663c19f85d2ad2cc}} 
uint {\bfseries active\+\_\+index}
\item 
uint \mbox{\hyperlink{classhandler_a64def328ff0ca7e391b217c2d3a758ec}{ref\+\_\+length}}
\item 
\mbox{\Hypertarget{classhandler_a943005f89e7a6d5cee246e1c5b46e9ab}\label{classhandler_a943005f89e7a6d5cee246e1c5b46e9ab}} 
F\+T\+\_\+\+I\+N\+FO $\ast$ {\bfseries ft\+\_\+handler}
\item 
\mbox{\Hypertarget{classhandler_ae346e9156bcf1dd515eef535c40ca601}\label{classhandler_ae346e9156bcf1dd515eef535c40ca601}} 
enum handler\+:: \{ ... \}  {\bfseries inited}
\item 
\mbox{\Hypertarget{classhandler_afd47d68a7b406d8777396a657095d5e8}\label{classhandler_afd47d68a7b406d8777396a657095d5e8}} 
bool {\bfseries implicit\+\_\+emptied}
\item 
\mbox{\Hypertarget{classhandler_a0ed2f8d7155cb44162bb4181cb09f2f3}\label{classhandler_a0ed2f8d7155cb44162bb4181cb09f2f3}} 
const \mbox{\hyperlink{classItem}{Item}} $\ast$ {\bfseries pushed\+\_\+cond}
\item 
\mbox{\Hypertarget{classhandler_ae9b3d956f73649657bad389acfad5f0b}\label{classhandler_ae9b3d956f73649657bad389acfad5f0b}} 
\mbox{\hyperlink{classItem}{Item}} $\ast$ {\bfseries pushed\+\_\+idx\+\_\+cond}
\item 
\mbox{\Hypertarget{classhandler_a4dc8d81143d1c9c10b976711fe44cf37}\label{classhandler_a4dc8d81143d1c9c10b976711fe44cf37}} 
uint {\bfseries pushed\+\_\+idx\+\_\+cond\+\_\+keyno}
\item 
\mbox{\Hypertarget{classhandler_ae02710c45cf96dacef1109b49de048ee}\label{classhandler_ae02710c45cf96dacef1109b49de048ee}} 
ulonglong {\bfseries rows\+\_\+read}
\item 
\mbox{\Hypertarget{classhandler_a77d78935307f2f6fc1d918ddc30ef8d7}\label{classhandler_a77d78935307f2f6fc1d918ddc30ef8d7}} 
ulonglong {\bfseries rows\+\_\+changed}
\item 
\mbox{\Hypertarget{classhandler_a73622d661f0eb2a305f8bff3a9b99c18}\label{classhandler_a73622d661f0eb2a305f8bff3a9b99c18}} 
ulonglong {\bfseries index\+\_\+rows\+\_\+read} \mbox{[}M\+A\+X\+\_\+\+K\+EY\mbox{]}
\item 
ulonglong \mbox{\hyperlink{classhandler_a62ab295e407d8a5c50087fed0f4fcd18}{next\+\_\+insert\+\_\+id}}
\item 
ulonglong \mbox{\hyperlink{classhandler_a05dd2cafd83ae60562649bf9688aebf1}{insert\+\_\+id\+\_\+for\+\_\+cur\+\_\+row}}
\item 
\mbox{\hyperlink{classDiscrete__interval}{Discrete\+\_\+interval}} \mbox{\hyperlink{classhandler_a1540a47a05c03724f1102aaaa623131e}{auto\+\_\+inc\+\_\+interval\+\_\+for\+\_\+cur\+\_\+row}}
\item 
uint \mbox{\hyperlink{classhandler_acdfcef0738a89138c8f41ded8da17c0a}{auto\+\_\+inc\+\_\+intervals\+\_\+count}}
\item 
P\+S\+I\+\_\+table $\ast$ \mbox{\hyperlink{classhandler_a881e7cba3fe3bf9731a91be82983cc35}{m\+\_\+psi}}
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual int \mbox{\hyperlink{classhandler_ae5b7b96354fd25da35a940e656d91940}{records}} (ha\+\_\+rows $\ast$num\+\_\+rows)
\item 
virtual int \mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map}} (uchar $\ast$buf, const uchar $\ast$key, key\+\_\+part\+\_\+map keypart\+\_\+map, enum ha\+\_\+rkey\+\_\+function find\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Positions an index cursor to the index specified in the handle (\textquotesingle{}active\+\_\+index\textquotesingle{}). Fetches the row if available. If the key value is null, begin at the first key of the index. \end{DoxyCompactList}\item 
virtual int \mbox{\hyperlink{classhandler_acba0c549a00023dd44682cd9452cf830}{index\+\_\+read\+\_\+idx\+\_\+map}} (uchar $\ast$buf, uint index, const uchar $\ast$key, key\+\_\+part\+\_\+map keypart\+\_\+map, enum ha\+\_\+rkey\+\_\+function find\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index. \end{DoxyCompactList}\item 
virtual int \mbox{\hyperlink{classhandler_aca48f687872e10a4fdc35b418d98b761}{index\+\_\+next}} (uchar $\ast$buf)
\item 
virtual int \mbox{\hyperlink{classhandler_a1ab892ae78db6437119d2d25621118b7}{index\+\_\+prev}} (uchar $\ast$buf)
\item 
virtual int \mbox{\hyperlink{classhandler_af37bd518c53c966459632584c34855d0}{index\+\_\+first}} (uchar $\ast$buf)
\item 
virtual int \mbox{\hyperlink{classhandler_aa1d62ffab7408a031b13e547eb58be09}{index\+\_\+last}} (uchar $\ast$buf)
\item 
virtual int \mbox{\hyperlink{classhandler_a5459b92420f74e6f88dec137e1941d22}{index\+\_\+next\+\_\+same}} (uchar $\ast$buf, const uchar $\ast$key, uint keylen)
\item 
virtual int \mbox{\hyperlink{classhandler_ae069d5991214e1fdf14cc44fd865a180}{index\+\_\+read\+\_\+last\+\_\+map}} (uchar $\ast$buf, const uchar $\ast$key, key\+\_\+part\+\_\+map keypart\+\_\+map)
\begin{DoxyCompactList}\small\item\em The following functions works like index\+\_\+read, but it find the last row with the current key value or prefix. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classhandler_a76b748cb37f18c1db0a6dfc016a32b86}\label{classhandler_a76b748cb37f18c1db0a6dfc016a32b86}} 
bool {\bfseries is\+\_\+using\+\_\+full\+\_\+unique\+\_\+key} (uint active\+\_\+index, key\+\_\+part\+\_\+map keypart\+\_\+map, enum ha\+\_\+rkey\+\_\+function find\+\_\+flag) const
\item 
\mbox{\Hypertarget{classhandler_a5fe486748715adbe6f7d6b9a9228cdf4}\label{classhandler_a5fe486748715adbe6f7d6b9a9228cdf4}} 
bool {\bfseries is\+\_\+using\+\_\+prohibited\+\_\+gap\+\_\+locks} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$table, bool using\+\_\+full\+\_\+primary\+\_\+key) const
\item 
virtual int \mbox{\hyperlink{classhandler_a03831da80c8a99422edd4b4ab84fa55a}{prepare\+\_\+index\+\_\+key\+\_\+scan}} (const uchar $\ast$key, uint key\+\_\+len)
\item 
virtual int \mbox{\hyperlink{classhandler_a48cb9c94ca93dbfbb7e92822caba82a1}{rnd\+\_\+next}} (uchar $\ast$buf)=0
\item 
virtual int \mbox{\hyperlink{classhandler_adf659edd9d870e90c8974ae0eba7a082}{rnd\+\_\+pos}} (uchar $\ast$buf, uchar $\ast$pos)=0
\item 
virtual bool \mbox{\hyperlink{classhandler_ab25b3931a457f1821ba55ae9cce79d98}{prepare\+\_\+inplace\+\_\+alter\+\_\+table}} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$altered\+\_\+table, \mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$ha\+\_\+alter\+\_\+info)
\item 
virtual bool \mbox{\hyperlink{classhandler_a90b4c3a8fe1c89c6ccfec1f4b144754a}{inplace\+\_\+alter\+\_\+table}} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$altered\+\_\+table, \mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$ha\+\_\+alter\+\_\+info)
\item 
virtual bool \mbox{\hyperlink{classhandler_a0786a5f57ccd3c97bff07b1afeae9c06}{commit\+\_\+inplace\+\_\+alter\+\_\+table}} (\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$altered\+\_\+table, \mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$ha\+\_\+alter\+\_\+info, bool commit)
\item 
virtual void \mbox{\hyperlink{classhandler_a26aaaf2105e60ca590b79fae82e48960}{notify\+\_\+table\+\_\+changed}} ()
\item 
\mbox{\Hypertarget{classhandler_aad25b44b50ac64192d6cfef591252ed7}\label{classhandler_aad25b44b50ac64192d6cfef591252ed7}} 
void {\bfseries ha\+\_\+statistic\+\_\+increment} (ulonglong S\+S\+V\+::$\ast$offset) const
\item 
\mbox{\Hypertarget{classhandler_a9df65ee64bcedb5a4b34bf752b2fab08}\label{classhandler_a9df65ee64bcedb5a4b34bf752b2fab08}} 
T\+HD $\ast$ {\bfseries ha\+\_\+thd} (void) const
\item 
P\+S\+I\+\_\+table\+\_\+share $\ast$ \mbox{\hyperlink{classhandler_a69803cd29d92bfecd97212354212c516}{ha\+\_\+table\+\_\+share\+\_\+psi}} (const \mbox{\hyperlink{structTABLE__SHARE}{T\+A\+B\+L\+E\+\_\+\+S\+H\+A\+RE}} $\ast$share) const
\item 
virtual int \mbox{\hyperlink{classhandler_a58bf8fa32d87654794e6b1c3b3fb8d32}{rename\+\_\+table}} (const char $\ast$from, const char $\ast$to)
\item 
virtual int \mbox{\hyperlink{classhandler_ae53ec34116b901cc08e5a87f5ec681a6}{delete\+\_\+table}} (const char $\ast$name)
\item 
\mbox{\Hypertarget{classhandler_a4ccf806316a9d88a7130d70e7637e8e5}\label{classhandler_a4ccf806316a9d88a7130d70e7637e8e5}} 
virtual int {\bfseries index\+\_\+read} (uchar $\ast$buf, const uchar $\ast$key, uint key\+\_\+len, enum ha\+\_\+rkey\+\_\+function find\+\_\+flag)
\item 
\mbox{\Hypertarget{classhandler_a90af353b21f935dc95212e1cfef50452}\label{classhandler_a90af353b21f935dc95212e1cfef50452}} 
virtual int {\bfseries index\+\_\+read\+\_\+last} (uchar $\ast$buf, const uchar $\ast$key, uint key\+\_\+len)
\item 
\mbox{\hyperlink{classHandler__share}{Handler\+\_\+share}} $\ast$ \mbox{\hyperlink{classhandler_a13bf21a8ad4be872bbfe94f5cb40abca}{get\+\_\+ha\+\_\+share\+\_\+ptr}} ()
\item 
void \mbox{\hyperlink{classhandler_ab24470ac1d4ac336cedbe7c245d321c9}{set\+\_\+ha\+\_\+share\+\_\+ptr}} (\mbox{\hyperlink{classHandler__share}{Handler\+\_\+share}} $\ast$arg\+\_\+ha\+\_\+share)
\item 
void \mbox{\hyperlink{classhandler_aa3a39db9dc1cca31f4a3ec0e0e1d7300}{lock\+\_\+shared\+\_\+ha\+\_\+data}} ()
\item 
void \mbox{\hyperlink{classhandler_a8059bbed3de416b3bea51c69dc064e79}{unlock\+\_\+shared\+\_\+ha\+\_\+data}} ()
\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classhandler_ae2613bd83c495f55fe2ce05a9df2d86f}\label{classhandler_ae2613bd83c495f55fe2ce05a9df2d86f}} 
static bool {\bfseries is\+\_\+using\+\_\+full\+\_\+key} (key\+\_\+part\+\_\+map keypart\+\_\+map, uint \mbox{\hyperlink{group__Query__Optimizer_ga6609ac0420a8a415d5a57cc6659f460d}{actual\+\_\+key\+\_\+parts}})
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classhandler_a3b094cfe680aa06a7d8b70194415aa3b}\label{classhandler_a3b094cfe680aa06a7d8b70194415aa3b}} 
\mbox{\hyperlink{structTABLE__SHARE}{T\+A\+B\+L\+E\+\_\+\+S\+H\+A\+RE}} $\ast$ {\bfseries table\+\_\+share}
\item 
\mbox{\Hypertarget{classhandler_abb0d051d1ef534891b27612cc4ff56f7}\label{classhandler_abb0d051d1ef534891b27612cc4ff56f7}} 
\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$ {\bfseries table}
\item 
\mbox{\Hypertarget{classhandler_a98743b18a24c8baef7e22a11df74d6c9}\label{classhandler_a98743b18a24c8baef7e22a11df74d6c9}} 
Table\+\_\+flags {\bfseries cached\+\_\+table\+\_\+flags}
\item 
\mbox{\Hypertarget{classhandler_adf44b6a4c101f982cd13a344dce5a870}\label{classhandler_adf44b6a4c101f982cd13a344dce5a870}} 
ha\+\_\+rows {\bfseries estimation\+\_\+rows\+\_\+to\+\_\+insert}
\item 
\mbox{\Hypertarget{classhandler_a011df14ecc738037499572c304d8ee90}\label{classhandler_a011df14ecc738037499572c304d8ee90}} 
\mbox{\hyperlink{classKEY__PART__INFO}{K\+E\+Y\+\_\+\+P\+A\+R\+T\+\_\+\+I\+N\+FO}} $\ast$ {\bfseries range\+\_\+key\+\_\+part}
\item 
\mbox{\Hypertarget{classhandler_a272c3d9b40a9e7c5de20ed390d23a636}\label{classhandler_a272c3d9b40a9e7c5de20ed390d23a636}} 
bool {\bfseries eq\+\_\+range}
\item 
\mbox{\Hypertarget{classhandler_a1a159ca294d8dafe32405e6ad546e6a4}\label{classhandler_a1a159ca294d8dafe32405e6ad546e6a4}} 
bool {\bfseries in\+\_\+range\+\_\+check\+\_\+pushed\+\_\+down}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classhandler_a0e1b518f74dfed5dde6f5f902f264f39}\label{classhandler_a0e1b518f74dfed5dde6f5f902f264f39}} 
class {\bfseries Partition\+\_\+handler}
\item 
\mbox{\Hypertarget{classhandler_a576b2e6999b5b4fbe40abb7870fe33b2}\label{classhandler_a576b2e6999b5b4fbe40abb7870fe33b2}} 
class {\bfseries Ds\+Mrr\+\_\+impl}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
The handler class is the interface for dynamically loadable storage engines. Do not add ifdefs and take care when adding or changing virtual functions to avoid vtable confusion

Functions in this class accept and return table columns data. Two data representation formats are used\+:
\begin{DoxyEnumerate}
\item Table\+Record\+Format -\/ Used to pass \mbox{[}partial\mbox{]} table records to/from storage engine
\item Key\+Tuple\+Format -\/ used to pass index search tuples (aka \char`\"{}keys\char`\"{}) to storage engine. See opt\+\_\+range.\+cc for description of this format.
\end{DoxyEnumerate}

\subsection*{Table\+Record\+Format }

\mbox{[}Warning\+: this description is work in progress and may be incomplete\mbox{]} The table record is stored in a fixed-\/size buffer\+:

record\+: null\+\_\+bytes, column1\+\_\+data, column2\+\_\+data, ...

The offsets of the parts of the buffer are also fixed\+: every column has an offset to its column\{i\}\+\_\+data, and if it is nullable it also has its own bit in null\+\_\+bytes.

The record buffer only includes data about columns that are marked in the relevant column set (table-\/$>$read\+\_\+set and/or table-\/$>$write\+\_\+set, depending on the situation). $<$not-\/sure$>$It could be that it is required that null bits of non-\/present columns are set to 1$<$/not-\/sure$>$

V\+A\+R\+I\+O\+US E\+X\+C\+E\+P\+T\+I\+O\+NS A\+ND S\+P\+E\+C\+I\+AL C\+A\+S\+ES

f the table has no nullable columns, then null\+\_\+bytes is still present, its length is one byte $<$not-\/sure$>$ which must be set to 0x\+FF at all times. $<$/not-\/sure$>$

If the table has columns of type B\+IT, then certain bits from those columns may be stored in null\+\_\+bytes as well. Grep around for \mbox{\hyperlink{classField__bit}{Field\+\_\+bit}} for details.

For blob columns (see \mbox{\hyperlink{classField__blob}{Field\+\_\+blob}}), the record buffer stores length of the data, following by memory pointer to the blob data. The pointer is owned by the storage engine and is valid until the next operation.

If a blob column has N\+U\+LL value, then its length and blob data pointer must be set to 0. 

\subsection{Member Typedef Documentation}
\mbox{\Hypertarget{classhandler_ad4c241e50948859d98ceae6e39066838}\label{classhandler_ad4c241e50948859d98ceae6e39066838}} 
\index{handler@{handler}!my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t@{my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t}}
\index{my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t@{my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t}!handler@{handler}}
\subsubsection{\texorpdfstring{my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t}{my\_gcolumn\_template\_callback\_t}}
{\footnotesize\ttfamily typedef void($\ast$ handler\+::my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t) (const \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$, void $\ast$)}

Callback function that will be called by my\+\_\+prepare\+\_\+gcolumn\+\_\+template once the table has been opened. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classhandler_a748d5e5b6dbbb0681cbac2ad881505c9}\label{classhandler_a748d5e5b6dbbb0681cbac2ad881505c9}} 
\index{handler@{handler}!bas\+\_\+ext@{bas\+\_\+ext}}
\index{bas\+\_\+ext@{bas\+\_\+ext}!handler@{handler}}
\subsubsection{\texorpdfstring{bas\+\_\+ext()}{bas\_ext()}}
{\footnotesize\ttfamily virtual const char$\ast$$\ast$ handler\+::bas\+\_\+ext (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

If frm\+\_\+error() is called then we will use this to find out what file extentions exist for the storage engine. This is also used by the default rename\+\_\+table and delete\+\_\+table method in \mbox{\hyperlink{handler_8cc}{handler.\+cc}}.

For engines that have two file name extentions (separate meta/index file and data file), the order of elements is relevant. First element of engine file name extentions array should be meta/index file extention. Second element -\/ data file extention. This order is assumed by prepare\+\_\+for\+\_\+repair() when R\+E\+P\+A\+IR \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} ... U\+S\+E\+\_\+\+F\+RM is issued. 

Implemented in \mbox{\hyperlink{classha__ndbcluster_ade5341ce688c24b5885145f821cdf249}{ha\+\_\+ndbcluster}}, and \mbox{\hyperlink{classha__ndbinfo_ae7153997d64cb4e94ce23ecfb92714fb}{ha\+\_\+ndbinfo}}.

\mbox{\Hypertarget{classhandler_ac8dd7e44bc71120ace1e467ccb02ad06}\label{classhandler_ac8dd7e44bc71120ace1e467ccb02ad06}} 
\index{handler@{handler}!bulk\+\_\+update\+\_\+row@{bulk\+\_\+update\+\_\+row}}
\index{bulk\+\_\+update\+\_\+row@{bulk\+\_\+update\+\_\+row}!handler@{handler}}
\subsubsection{\texorpdfstring{bulk\+\_\+update\+\_\+row()}{bulk\_update\_row()}}
{\footnotesize\ttfamily virtual int handler\+::bulk\+\_\+update\+\_\+row (\begin{DoxyParamCaption}\item[{const uchar $\ast$}]{old\+\_\+data,  }\item[{uchar $\ast$}]{new\+\_\+data,  }\item[{uint $\ast$}]{dup\+\_\+key\+\_\+found }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

This method is similar to update\+\_\+row, however the handler doesn\textquotesingle{}t need to execute the updates at this point in time. The handler can be certain that another call to bulk\+\_\+update\+\_\+row will occur OR a call to exec\+\_\+bulk\+\_\+update before the set of updates in this query is concluded.

Note\+: If H\+A\+\_\+\+E\+R\+R\+\_\+\+F\+O\+U\+N\+D\+\_\+\+D\+U\+P\+P\+\_\+\+K\+EY is returned, the handler must read all columns of the row so My\+S\+QL can create an error message. If the columns required for the error message are not read, the error message will contain garbage.


\begin{DoxyParams}{Parameters}
{\em old\+\_\+data} & Old record \\
\hline
{\em new\+\_\+data} & New record \\
\hline
{\em dup\+\_\+key\+\_\+found} & Number of duplicate keys found \\
\hline
\end{DoxyParams}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a89cbc7ca67dcd89d07693186f5de7ca5}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a6baab93a22543b707e6e59b9d59810d2}\label{classhandler_a6baab93a22543b707e6e59b9d59810d2}} 
\index{handler@{handler}!can\+\_\+switch\+\_\+engines@{can\+\_\+switch\+\_\+engines}}
\index{can\+\_\+switch\+\_\+engines@{can\+\_\+switch\+\_\+engines}!handler@{handler}}
\subsubsection{\texorpdfstring{can\+\_\+switch\+\_\+engines()}{can\_switch\_engines()}}
{\footnotesize\ttfamily virtual bool handler\+::can\+\_\+switch\+\_\+engines (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Used in A\+L\+T\+ER \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} to check if changing storage engine is allowed.

\begin{DoxyNote}{Note}
Called without holding thr\+\_\+lock.\+c lock.
\end{DoxyNote}

\begin{DoxyRetVals}{Return values}
{\em true} & Changing storage engine is allowed. \\
\hline
{\em false} & Changing storage engine not allowed. \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a3fe3719d8dd1d5f41467250d632abd3c}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a41cc6ba204aa4d1bacc35d9d1d75ab15}\label{classhandler_a41cc6ba204aa4d1bacc35d9d1d75ab15}} 
\index{handler@{handler}!cancel\+\_\+pushed\+\_\+idx\+\_\+cond@{cancel\+\_\+pushed\+\_\+idx\+\_\+cond}}
\index{cancel\+\_\+pushed\+\_\+idx\+\_\+cond@{cancel\+\_\+pushed\+\_\+idx\+\_\+cond}!handler@{handler}}
\subsubsection{\texorpdfstring{cancel\+\_\+pushed\+\_\+idx\+\_\+cond()}{cancel\_pushed\_idx\_cond()}}
{\footnotesize\ttfamily virtual void handler\+::cancel\+\_\+pushed\+\_\+idx\+\_\+cond (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Reset information about pushed index conditions \mbox{\Hypertarget{classhandler_a234580f9765751ce185182dd1edc3bdb}\label{classhandler_a234580f9765751ce185182dd1edc3bdb}} 
\index{handler@{handler}!check\+\_\+collation\+\_\+compatibility@{check\+\_\+collation\+\_\+compatibility}}
\index{check\+\_\+collation\+\_\+compatibility@{check\+\_\+collation\+\_\+compatibility}!handler@{handler}}
\subsubsection{\texorpdfstring{check\+\_\+collation\+\_\+compatibility()}{check\_collation\_compatibility()}}
{\footnotesize\ttfamily int handler\+::check\+\_\+collation\+\_\+compatibility (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Check for incompatible collation changes.


\begin{DoxyRetVals}{Return values}
{\em H\+A\+\_\+\+A\+D\+M\+I\+N\+\_\+\+N\+E\+E\+D\+S\+\_\+\+U\+P\+G\+R\+A\+DE} & Table may have data requiring upgrade. \\
\hline
{\em 0} & No upgrade required. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a36d800c8dafbc9efde9af932305529e4}\label{classhandler_a36d800c8dafbc9efde9af932305529e4}} 
\index{handler@{handler}!check\+\_\+if\+\_\+incompatible\+\_\+data@{check\+\_\+if\+\_\+incompatible\+\_\+data}}
\index{check\+\_\+if\+\_\+incompatible\+\_\+data@{check\+\_\+if\+\_\+incompatible\+\_\+data}!handler@{handler}}
\subsubsection{\texorpdfstring{check\+\_\+if\+\_\+incompatible\+\_\+data()}{check\_if\_incompatible\_data()}}
{\footnotesize\ttfamily virtual bool handler\+::check\+\_\+if\+\_\+incompatible\+\_\+data (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$}]{create\+\_\+info,  }\item[{uint}]{table\+\_\+changes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Part of old, deprecated in-\/place A\+L\+T\+ER A\+PI. \mbox{\Hypertarget{classhandler_a67890a9deb89b9ef0128601e7687fcba}\label{classhandler_a67890a9deb89b9ef0128601e7687fcba}} 
\index{handler@{handler}!check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter@{check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter}}
\index{check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter@{check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter}!handler@{handler}}
\subsubsection{\texorpdfstring{check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter()}{check\_if\_supported\_inplace\_alter()}}
{\footnotesize\ttfamily enum\+\_\+alter\+\_\+inplace\+\_\+result handler\+::check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{altered\+\_\+table,  }\item[{\mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$}]{ha\+\_\+alter\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Check if a storage engine supports a particular alter table in-\/place


\begin{DoxyParams}{Parameters}
{\em altered\+\_\+table} & \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} object for new version of table. \\
\hline
{\em ha\+\_\+alter\+\_\+info} & Structure describing changes to be done by A\+L\+T\+ER \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} and holding data used during in-\/place alter.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+E\+R\+R\+OR} & Unexpected error. \\
\hline
{\em H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+I\+N\+P\+L\+A\+C\+E\+\_\+\+N\+O\+T\+\_\+\+S\+U\+P\+P\+O\+R\+T\+ED} & Not supported, must use copy. \\
\hline
{\em H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+I\+N\+P\+L\+A\+C\+E\+\_\+\+E\+X\+C\+L\+U\+S\+I\+V\+E\+\_\+\+L\+O\+CK} & Supported, but requires X lock. \\
\hline
{\em H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+I\+N\+P\+L\+A\+C\+E\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+L\+O\+C\+K\+\_\+\+A\+F\+T\+E\+R\+\_\+\+P\+R\+E\+P\+A\+RE} & Supported, but requires S\+NW lock during main phase. Prepare phase requires X lock. \\
\hline
{\em H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+I\+N\+P\+L\+A\+C\+E\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+L\+O\+CK} & Supported, but requires S\+NW lock. \\
\hline
{\em H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+I\+N\+P\+L\+A\+C\+E\+\_\+\+N\+O\+\_\+\+L\+O\+C\+K\+\_\+\+A\+F\+T\+E\+R\+\_\+\+P\+R\+E\+P\+A\+RE} & Supported, concurrent reads/writes allowed. However, prepare phase requires X lock. \\
\hline
{\em H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+I\+N\+P\+L\+A\+C\+E\+\_\+\+N\+O\+\_\+\+L\+O\+CK} & Supported, concurrent reads/writes allowed.\\
\hline
\end{DoxyRetVals}
\begin{DoxyNote}{Note}
The default implementation uses the old in-\/place A\+L\+T\+ER A\+PI to determine if the storage engine supports in-\/place A\+L\+T\+ER or not.

Called without holding thr\+\_\+lock.\+c lock. 
\end{DoxyNote}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a178fe8e973508932db3d3d6ca3a625a9}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a4de97045e5381007565fd2b0da235c07}\label{classhandler_a4de97045e5381007565fd2b0da235c07}} 
\index{handler@{handler}!column\+\_\+bitmaps\+\_\+signal@{column\+\_\+bitmaps\+\_\+signal}}
\index{column\+\_\+bitmaps\+\_\+signal@{column\+\_\+bitmaps\+\_\+signal}!handler@{handler}}
\subsubsection{\texorpdfstring{column\+\_\+bitmaps\+\_\+signal()}{column\_bitmaps\_signal()}}
{\footnotesize\ttfamily void handler\+::column\+\_\+bitmaps\+\_\+signal (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



My\+S\+QL signal that it changed the column bitmap. 

Signal that the table-\/$>$read\+\_\+set and table-\/$>$write\+\_\+set table maps changed The handler is allowed to set additional bits in the above map in this call. Normally the handler should ignore all calls until we have done a \mbox{\hyperlink{classhandler_afb5c99736cb400350e007578889b8375}{ha\+\_\+rnd\+\_\+init()}} or \mbox{\hyperlink{classhandler_a0af23462b249041a0db03c1c7139d76b}{ha\+\_\+index\+\_\+init()}}, write\+\_\+row(), update\+\_\+row or delete\+\_\+row() as there may be several calls to this routine.

U\+S\+A\+GE This is for handlers that needs to setup their own column bitmaps. Normally the handler should set up their own column bitmaps in index\+\_\+init() or rnd\+\_\+init() and in any \mbox{\hyperlink{classhandler_a4de97045e5381007565fd2b0da235c07}{column\+\_\+bitmaps\+\_\+signal()}} call after this.

The handler is allowd to do changes to the bitmap after a index\+\_\+init or rnd\+\_\+init() call is made as after this, My\+S\+QL will not use the bitmap for any program logic checking. \mbox{\Hypertarget{classhandler_a0786a5f57ccd3c97bff07b1afeae9c06}\label{classhandler_a0786a5f57ccd3c97bff07b1afeae9c06}} 
\index{handler@{handler}!commit\+\_\+inplace\+\_\+alter\+\_\+table@{commit\+\_\+inplace\+\_\+alter\+\_\+table}}
\index{commit\+\_\+inplace\+\_\+alter\+\_\+table@{commit\+\_\+inplace\+\_\+alter\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{commit\+\_\+inplace\+\_\+alter\+\_\+table()}{commit\_inplace\_alter\_table()}}
{\footnotesize\ttfamily virtual bool handler\+::commit\+\_\+inplace\+\_\+alter\+\_\+table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{altered\+\_\+table,  }\item[{\mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$}]{ha\+\_\+alter\+\_\+info,  }\item[{bool}]{commit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Commit or rollback the changes made during \mbox{\hyperlink{classhandler_ab25b3931a457f1821ba55ae9cce79d98}{prepare\+\_\+inplace\+\_\+alter\+\_\+table()}} and \mbox{\hyperlink{classhandler_a90b4c3a8fe1c89c6ccfec1f4b144754a}{inplace\+\_\+alter\+\_\+table()}} inside the storage engine. Note that in case of rollback the allowed level of concurrency during this operation will be the same as for \mbox{\hyperlink{classhandler_a90b4c3a8fe1c89c6ccfec1f4b144754a}{inplace\+\_\+alter\+\_\+table()}} and thus might be higher than during \mbox{\hyperlink{classhandler_ab25b3931a457f1821ba55ae9cce79d98}{prepare\+\_\+inplace\+\_\+alter\+\_\+table()}}. (For example, concurrent writes were blocked during prepare, but might not be during rollback).

\begin{DoxyNote}{Note}
Storage engines are responsible for reporting any errors by calling my\+\_\+error()/print\+\_\+error()

If this function with commit= true reports error, it will be called again with commit= false.

In case of partitioning, this function might be called for rollback without \mbox{\hyperlink{classhandler_ab25b3931a457f1821ba55ae9cce79d98}{prepare\+\_\+inplace\+\_\+alter\+\_\+table()}} having been called first. Also partitioned tables sets ha\+\_\+alter\+\_\+info-\/$>$group\+\_\+commit\+\_\+ctx to a N\+U\+LL terminated array of the partitions handlers and if all of them are committed as one, then group\+\_\+commit\+\_\+ctx should be set to N\+U\+LL to indicate to the partitioning handler that all partitions handlers are committed. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_ab25b3931a457f1821ba55ae9cce79d98}{prepare\+\_\+inplace\+\_\+alter\+\_\+table()}}.
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em altered\+\_\+table} & \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} object for new version of table. \\
\hline
{\em ha\+\_\+alter\+\_\+info} & Structure describing changes to be done by A\+L\+T\+ER \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} and holding data used during in-\/place alter. \\
\hline
{\em commit} & True =$>$ Commit, False =$>$ Rollback.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & Error \\
\hline
{\em false} & Success \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_af55db4a0efc9c99947b72b4bfc83b8ad}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_af0ef38e7407e87ba5d1ccde59c3e94bb}\label{classhandler_af0ef38e7407e87ba5d1ccde59c3e94bb}} 
\index{handler@{handler}!compare\+\_\+key@{compare\+\_\+key}}
\index{compare\+\_\+key@{compare\+\_\+key}!handler@{handler}}
\subsubsection{\texorpdfstring{compare\+\_\+key()}{compare\_key()}}
{\footnotesize\ttfamily int handler\+::compare\+\_\+key (\begin{DoxyParamCaption}\item[{key\+\_\+range $\ast$}]{range }\end{DoxyParamCaption})}

Compare if found key (in row) is over max-\/value.


\begin{DoxyParams}{Parameters}
{\em range} & range to compare to row. May be 0 for no range\\
\hline
\end{DoxyParams}
key.\+cc\+::key\+\_\+cmp()

\begin{DoxyReturn}{Returns}
The return value is S\+I\+GN(key\+\_\+in\+\_\+row -\/ range\+\_\+key)\+:
\end{DoxyReturn}

\begin{DoxyItemize}
\item 0 \+: \mbox{\hyperlink{classKey}{Key}} is equal to range or \textquotesingle{}range\textquotesingle{} == 0 (no range)
\item -\/1 \+: \mbox{\hyperlink{classKey}{Key}} is less than range
\item 1 \+: \mbox{\hyperlink{classKey}{Key}} is larger than range 
\end{DoxyItemize}\mbox{\Hypertarget{classhandler_aeac3d9b9796d3bfb18b96a1989d6f516}\label{classhandler_aeac3d9b9796d3bfb18b96a1989d6f516}} 
\index{handler@{handler}!compare\+\_\+key\+\_\+in\+\_\+buffer@{compare\+\_\+key\+\_\+in\+\_\+buffer}}
\index{compare\+\_\+key\+\_\+in\+\_\+buffer@{compare\+\_\+key\+\_\+in\+\_\+buffer}!handler@{handler}}
\subsubsection{\texorpdfstring{compare\+\_\+key\+\_\+in\+\_\+buffer()}{compare\_key\_in\_buffer()}}
{\footnotesize\ttfamily int handler\+::compare\+\_\+key\+\_\+in\+\_\+buffer (\begin{DoxyParamCaption}\item[{const uchar $\ast$}]{buf }\end{DoxyParamCaption}) const}

Check if the key in the given buffer (which is not necessarily T\+A\+B\+L\+E\+::record\mbox{[}0\mbox{]}) is within range. Called by the storage engine to avoid reading too many rows.


\begin{DoxyParams}{Parameters}
{\em buf} & the buffer that holds the key \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em -\/1} & if the key is within the range \\
\hline
{\em 0} & if the key is equal to the end\+\_\+range key, and key\+\_\+compare\+\_\+result\+\_\+on\+\_\+equal is 0 \\
\hline
{\em 1} & if the key is outside the range \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_ac3eb8d2966b848ec4beea5a25cba9dea}\label{classhandler_ac3eb8d2966b848ec4beea5a25cba9dea}} 
\index{handler@{handler}!cond\+\_\+pop@{cond\+\_\+pop}}
\index{cond\+\_\+pop@{cond\+\_\+pop}!handler@{handler}}
\subsubsection{\texorpdfstring{cond\+\_\+pop()}{cond\_pop()}}
{\footnotesize\ttfamily virtual void handler\+::cond\+\_\+pop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Pop the top condition from the condition stack of the handler instance.

Pops the top if condition stack, if stack is not empty. 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a0de805435e8251f27ba3394052f6b1c7}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a5e765264bd31e0519e03e1bd53d8c6d2}\label{classhandler_a5e765264bd31e0519e03e1bd53d8c6d2}} 
\index{handler@{handler}!cond\+\_\+push@{cond\+\_\+push}}
\index{cond\+\_\+push@{cond\+\_\+push}!handler@{handler}}
\subsubsection{\texorpdfstring{cond\+\_\+push()}{cond\_push()}}
{\footnotesize\ttfamily virtual const \mbox{\hyperlink{classItem}{Item}}$\ast$ handler\+::cond\+\_\+push (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classItem}{Item}} $\ast$}]{cond }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Push condition down to the table handler.


\begin{DoxyParams}{Parameters}
{\em cond} & Condition to be pushed. The condition tree must not be modified by the by the caller.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The \textquotesingle{}remainder\textquotesingle{} condition that caller must use to filter out records. N\+U\+LL means the handler will not return rows that do not match the passed condition.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The pushed conditions form a stack (from which one can remove the last pushed condition using cond\+\_\+pop). The table handler filters out rows using (pushed\+\_\+cond1 A\+ND pushed\+\_\+cond2 A\+ND ... A\+ND pushed\+\_\+condN) or less restrictive condition, depending on handler\textquotesingle{}s capabilities.
\end{DoxyNote}
handler-\/$>$\mbox{\hyperlink{classhandler_a53d38f167906d8aaa9e560c71e595a42}{ha\+\_\+reset()}} call empties the condition stack. Calls to rnd\+\_\+init/rnd\+\_\+end, index\+\_\+init/index\+\_\+end etc do not affect the condition stack. 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a2285b3af9153f052ef6ba0cfc3bacea1}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_ac24fcaab09a75e81702c2e2c34fa0b62}\label{classhandler_ac24fcaab09a75e81702c2e2c34fa0b62}} 
\index{handler@{handler}!delete\+\_\+all\+\_\+rows@{delete\+\_\+all\+\_\+rows}}
\index{delete\+\_\+all\+\_\+rows@{delete\+\_\+all\+\_\+rows}!handler@{handler}}
\subsubsection{\texorpdfstring{delete\+\_\+all\+\_\+rows()}{delete\_all\_rows()}}
{\footnotesize\ttfamily virtual int handler\+::delete\+\_\+all\+\_\+rows (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

This is called to delete all rows in a table If the handler don\textquotesingle{}t support this, then this function will return H\+A\+\_\+\+E\+R\+R\+\_\+\+W\+R\+O\+N\+G\+\_\+\+C\+O\+M\+M\+A\+ND and My\+S\+QL will delete the rows one by one. \mbox{\Hypertarget{classhandler_ae53ec34116b901cc08e5a87f5ec681a6}\label{classhandler_ae53ec34116b901cc08e5a87f5ec681a6}} 
\index{handler@{handler}!delete\+\_\+table@{delete\+\_\+table}}
\index{delete\+\_\+table@{delete\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{delete\+\_\+table()}{delete\_table()}}
{\footnotesize\ttfamily int handler\+::delete\+\_\+table (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

Delete a table in the engine. Called for base as well as temporary tables.

Delete all files with extension from \mbox{\hyperlink{classhandler_a748d5e5b6dbbb0681cbac2ad881505c9}{bas\+\_\+ext()}}.


\begin{DoxyParams}{Parameters}
{\em name} & Base name of table\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
We assume that the handler may return more extensions than was actually used for the file.
\end{DoxyNote}

\begin{DoxyRetVals}{Return values}
{\em 0} & If we successfully deleted at least one file from base\+\_\+ext and didn\textquotesingle{}t get any other errors than E\+N\+O\+E\+NT \\
\hline
{\em !0} & Error \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a4d32721908372dc62c490e14a005e03c}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_af5f9f1ca2b5efc0b41e96c6b793d9bb1}\label{classhandler_af5f9f1ca2b5efc0b41e96c6b793d9bb1}} 
\index{handler@{handler}!end\+\_\+bulk\+\_\+delete@{end\+\_\+bulk\+\_\+delete}}
\index{end\+\_\+bulk\+\_\+delete@{end\+\_\+bulk\+\_\+delete}!handler@{handler}}
\subsubsection{\texorpdfstring{end\+\_\+bulk\+\_\+delete()}{end\_bulk\_delete()}}
{\footnotesize\ttfamily virtual int handler\+::end\+\_\+bulk\+\_\+delete (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Execute all outstanding deletes and close down the bulk delete.


\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em $>$0} & Error code \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a2bf6c46d66ca282a4cbd6118e4c99e03}\label{classhandler_a2bf6c46d66ca282a4cbd6118e4c99e03}} 
\index{handler@{handler}!end\+\_\+bulk\+\_\+update@{end\+\_\+bulk\+\_\+update}}
\index{end\+\_\+bulk\+\_\+update@{end\+\_\+bulk\+\_\+update}!handler@{handler}}
\subsubsection{\texorpdfstring{end\+\_\+bulk\+\_\+update()}{end\_bulk\_update()}}
{\footnotesize\ttfamily virtual void handler\+::end\+\_\+bulk\+\_\+update (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Perform any needed clean-\/up, no outstanding updates are there at the moment. 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a3c3b80b72e921059f62aed3eda1db911}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_ab6a860cb6d6cb731416080acc8f179e0}\label{classhandler_ab6a860cb6d6cb731416080acc8f179e0}} 
\index{handler@{handler}!end\+\_\+psi\+\_\+batch\+\_\+mode@{end\+\_\+psi\+\_\+batch\+\_\+mode}}
\index{end\+\_\+psi\+\_\+batch\+\_\+mode@{end\+\_\+psi\+\_\+batch\+\_\+mode}!handler@{handler}}
\subsubsection{\texorpdfstring{end\+\_\+psi\+\_\+batch\+\_\+mode()}{end\_psi\_batch\_mode()}}
{\footnotesize\ttfamily void handler\+::end\+\_\+psi\+\_\+batch\+\_\+mode (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

End a batch started with {\ttfamily start\+\_\+psi\+\_\+batch\+\_\+mode}. \mbox{\Hypertarget{classhandler_a517d99c283e85e8d97460f07a781dabf}\label{classhandler_a517d99c283e85e8d97460f07a781dabf}} 
\index{handler@{handler}!end\+\_\+read\+\_\+removal@{end\+\_\+read\+\_\+removal}}
\index{end\+\_\+read\+\_\+removal@{end\+\_\+read\+\_\+removal}!handler@{handler}}
\subsubsection{\texorpdfstring{end\+\_\+read\+\_\+removal()}{end\_read\_removal()}}
{\footnotesize\ttfamily virtual ha\+\_\+rows handler\+::end\+\_\+read\+\_\+removal (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

End read (before write) removal and return the number of rows really written \begin{DoxySeeAlso}{See also}
H\+A\+\_\+\+R\+E\+A\+D\+\_\+\+B\+E\+F\+O\+R\+E\+\_\+\+W\+R\+I\+T\+E\+\_\+\+R\+E\+M\+O\+V\+AL 
\end{DoxySeeAlso}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a81e58b0a19c7cc7d857a3f00e039ae37}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_ae59e9a1d36d852f4dd5dd00bff5f1ae4}\label{classhandler_ae59e9a1d36d852f4dd5dd00bff5f1ae4}} 
\index{handler@{handler}!estimate\+\_\+rows\+\_\+upper\+\_\+bound@{estimate\+\_\+rows\+\_\+upper\+\_\+bound}}
\index{estimate\+\_\+rows\+\_\+upper\+\_\+bound@{estimate\+\_\+rows\+\_\+upper\+\_\+bound}!handler@{handler}}
\subsubsection{\texorpdfstring{estimate\+\_\+rows\+\_\+upper\+\_\+bound()}{estimate\_rows\_upper\_bound()}}
{\footnotesize\ttfamily virtual ha\+\_\+rows handler\+::estimate\+\_\+rows\+\_\+upper\+\_\+bound (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Return upper bound of current number of records in the table (max. of how many records one will retrieve when doing a full table scan) If upper bound is not known, H\+A\+\_\+\+P\+O\+S\+\_\+\+E\+R\+R\+OR should be returned as a max possible upper bound. 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a59555b02c52fc703e99a41d3ee3a04c3}{ha\+\_\+ndbcluster}}, and \mbox{\hyperlink{classha__ndbinfo_a343b6837bb14a74236095276dec644dd}{ha\+\_\+ndbinfo}}.

\mbox{\Hypertarget{classhandler_a886bf2fbf16de7e200e3ebc0765fb6e4}\label{classhandler_a886bf2fbf16de7e200e3ebc0765fb6e4}} 
\index{handler@{handler}!exec\+\_\+bulk\+\_\+update@{exec\+\_\+bulk\+\_\+update}}
\index{exec\+\_\+bulk\+\_\+update@{exec\+\_\+bulk\+\_\+update}!handler@{handler}}
\subsubsection{\texorpdfstring{exec\+\_\+bulk\+\_\+update()}{exec\_bulk\_update()}}
{\footnotesize\ttfamily virtual int handler\+::exec\+\_\+bulk\+\_\+update (\begin{DoxyParamCaption}\item[{uint $\ast$}]{dup\+\_\+key\+\_\+found }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

After this call all outstanding updates must be performed. The number of duplicate key errors are reported in the duplicate key parameter. It is allowed to continue to the batched update after this call, the handler has to wait until end\+\_\+bulk\+\_\+update with changing state.


\begin{DoxyParams}{Parameters}
{\em dup\+\_\+key\+\_\+found} & Number of duplicate keys found\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em $>$0} & Error code \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a5c9f552924c7168373ab0d1c2ba0e049}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_aaf6af760a4ef09984a5cc1dc58db9a40}\label{classhandler_aaf6af760a4ef09984a5cc1dc58db9a40}} 
\index{handler@{handler}!get\+\_\+auto\+\_\+increment@{get\+\_\+auto\+\_\+increment}}
\index{get\+\_\+auto\+\_\+increment@{get\+\_\+auto\+\_\+increment}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+auto\+\_\+increment()}{get\_auto\_increment()}}
{\footnotesize\ttfamily void handler\+::get\+\_\+auto\+\_\+increment (\begin{DoxyParamCaption}\item[{ulonglong}]{offset,  }\item[{ulonglong}]{increment,  }\item[{ulonglong}]{nb\+\_\+desired\+\_\+values,  }\item[{ulonglong $\ast$}]{first\+\_\+value,  }\item[{ulonglong $\ast$}]{nb\+\_\+reserved\+\_\+values }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Reserves an interval of auto\+\_\+increment values from the handler.


\begin{DoxyParams}[1]{Parameters}
 & {\em offset} & offset (modulus increment) \\
\hline
 & {\em increment} & increment between calls \\
\hline
 & {\em nb\+\_\+desired\+\_\+values} & how many values we want \\
\hline
\mbox{\texttt{ out}}  & {\em first\+\_\+value} & the first value reserved by the handler \\
\hline
\mbox{\texttt{ out}}  & {\em nb\+\_\+reserved\+\_\+values} & how many values the handler reserved\\
\hline
\end{DoxyParams}
offset and increment means that we want values to be of the form offset + N $\ast$ increment, where N$>$=0 is integer. If the function sets $\ast$first\+\_\+value to U\+L\+L\+O\+N\+G\+\_\+\+M\+AX it means an error. If the function sets $\ast$nb\+\_\+reserved\+\_\+values to U\+L\+L\+O\+N\+G\+\_\+\+M\+AX it means it has reserved to \char`\"{}positive infinite\char`\"{}. \mbox{\Hypertarget{classhandler_a683eef70b4481c3bc0b10336e179de27}\label{classhandler_a683eef70b4481c3bc0b10336e179de27}} 
\index{handler@{handler}!get\+\_\+cascade\+\_\+foreign\+\_\+key\+\_\+table\+\_\+list@{get\+\_\+cascade\+\_\+foreign\+\_\+key\+\_\+table\+\_\+list}}
\index{get\+\_\+cascade\+\_\+foreign\+\_\+key\+\_\+table\+\_\+list@{get\+\_\+cascade\+\_\+foreign\+\_\+key\+\_\+table\+\_\+list}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+cascade\+\_\+foreign\+\_\+key\+\_\+table\+\_\+list()}{get\_cascade\_foreign\_key\_table\_list()}}
{\footnotesize\ttfamily virtual int handler\+::get\+\_\+cascade\+\_\+foreign\+\_\+key\+\_\+table\+\_\+list (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{\mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{structst__handler__tablename}{st\+\_\+handler\+\_\+tablename}} $>$ $\ast$}]{fk\+\_\+table\+\_\+list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Get the list of tables which are direct or indirect parents in foreign key with cascading actions for this table.

\begin{DoxyRemark}{Remarks}
Returns the set of parent tables connected by FK clause that can modify the given table.
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
 & {\em thd} & The thread handle. \\
\hline
\mbox{\texttt{ out}}  & {\em fk\+\_\+table\+\_\+list} & \mbox{\hyperlink{classList}{List}} of parent tables (including indirect parents). Elements of the list as well as buffers for database and schema names are allocated from the current memory root.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The handler error code or zero for success 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_ad5eede0999f8273864faa40c5e181793}\label{classhandler_ad5eede0999f8273864faa40c5e181793}} 
\index{handler@{handler}!get\+\_\+dup\+\_\+key@{get\+\_\+dup\+\_\+key}}
\index{get\+\_\+dup\+\_\+key@{get\+\_\+dup\+\_\+key}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+dup\+\_\+key()}{get\_dup\_key()}}
{\footnotesize\ttfamily uint handler\+::get\+\_\+dup\+\_\+key (\begin{DoxyParamCaption}\item[{int}]{error }\end{DoxyParamCaption})}

\begin{DoxyReturn}{Returns}
key if error because of duplicated keys 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_afce8ffd064ce683481494c7503ef820c}\label{classhandler_afce8ffd064ce683481494c7503ef820c}} 
\index{handler@{handler}!get\+\_\+error\+\_\+message@{get\+\_\+error\+\_\+message}}
\index{get\+\_\+error\+\_\+message@{get\+\_\+error\+\_\+message}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+error\+\_\+message()}{get\_error\_message()}}
{\footnotesize\ttfamily bool handler\+::get\+\_\+error\+\_\+message (\begin{DoxyParamCaption}\item[{int}]{error,  }\item[{String $\ast$}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Return an error message specific to this handler.


\begin{DoxyParams}{Parameters}
{\em error} & error code previously returned by handler \\
\hline
{\em buf} & pointer to String where to add error message\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if this is a temporary error 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a31a5f675ffb30d67ba91bb1cb9ec9dc8}{ha\+\_\+ndbcluster}}, and \mbox{\hyperlink{classha__ndbinfo_ab3693b75133ce5d4e4861ef5627ebbdc}{ha\+\_\+ndbinfo}}.

\mbox{\Hypertarget{classhandler_a20878b1fb8d31b91dbf53ac963d90f78}\label{classhandler_a20878b1fb8d31b91dbf53ac963d90f78}} 
\index{handler@{handler}!get\+\_\+foreign\+\_\+dup\+\_\+key@{get\+\_\+foreign\+\_\+dup\+\_\+key}}
\index{get\+\_\+foreign\+\_\+dup\+\_\+key@{get\+\_\+foreign\+\_\+dup\+\_\+key}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+foreign\+\_\+dup\+\_\+key()}{get\_foreign\_dup\_key()}}
{\footnotesize\ttfamily virtual bool handler\+::get\+\_\+foreign\+\_\+dup\+\_\+key (\begin{DoxyParamCaption}\item[{char $\ast$}]{child\+\_\+table\+\_\+name,  }\item[{uint}]{child\+\_\+table\+\_\+name\+\_\+len,  }\item[{char $\ast$}]{child\+\_\+key\+\_\+name,  }\item[{uint}]{child\+\_\+key\+\_\+name\+\_\+len }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Retrieves the names of the table and the key for which there was a duplicate entry in the case of H\+A\+\_\+\+E\+R\+R\+\_\+\+F\+O\+R\+E\+I\+G\+N\+\_\+\+D\+U\+P\+L\+I\+C\+A\+T\+E\+\_\+\+K\+EY.

If any of the table or key name is not available this method will return false and will not change any of child\+\_\+table\+\_\+name or child\+\_\+key\+\_\+name.


\begin{DoxyParams}{Parameters}
{\em child\+\_\+table\+\_\+name\mbox{[}out\mbox{]}} & Table name \\
\hline
{\em child\+\_\+table\+\_\+name\+\_\+len\mbox{[}in\mbox{]}} & Table name buffer size \\
\hline
{\em child\+\_\+key\+\_\+name\mbox{[}out\mbox{]}} & \mbox{\hyperlink{classKey}{Key}} name \\
\hline
{\em child\+\_\+key\+\_\+name\+\_\+len\mbox{[}in\mbox{]}} & \mbox{\hyperlink{classKey}{Key}} name buffer size\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & table and key names were available and were written into the corresponding out parameters. \\
\hline
{\em false} & table and key names were not available, the out parameters were not touched. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a81064e61d4c08261af409fb6ee34e3ca}\label{classhandler_a81064e61d4c08261af409fb6ee34e3ca}} 
\index{handler@{handler}!get\+\_\+foreign\+\_\+key\+\_\+list@{get\+\_\+foreign\+\_\+key\+\_\+list}}
\index{get\+\_\+foreign\+\_\+key\+\_\+list@{get\+\_\+foreign\+\_\+key\+\_\+list}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+foreign\+\_\+key\+\_\+list()}{get\_foreign\_key\_list()}}
{\footnotesize\ttfamily virtual int handler\+::get\+\_\+foreign\+\_\+key\+\_\+list (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{\mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{structst__foreign__key__info}{F\+O\+R\+E\+I\+G\+N\+\_\+\+K\+E\+Y\+\_\+\+I\+N\+FO}} $>$ $\ast$}]{f\+\_\+key\+\_\+list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Get the list of foreign keys in this table.

\begin{DoxyRemark}{Remarks}
Returns the set of foreign keys where this table is the dependent or child table.
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em thd} & The thread handle. \\
\hline
{\em f\+\_\+key\+\_\+list\mbox{[}out\mbox{]}} & The list of foreign keys.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The handler error code or zero for success. 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a3b97152a2ce0d7e7622de70daae4171b}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a13bf21a8ad4be872bbfe94f5cb40abca}\label{classhandler_a13bf21a8ad4be872bbfe94f5cb40abca}} 
\index{handler@{handler}!get\+\_\+ha\+\_\+share\+\_\+ptr@{get\+\_\+ha\+\_\+share\+\_\+ptr}}
\index{get\+\_\+ha\+\_\+share\+\_\+ptr@{get\+\_\+ha\+\_\+share\+\_\+ptr}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+ha\+\_\+share\+\_\+ptr()}{get\_ha\_share\_ptr()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classHandler__share}{Handler\+\_\+share}} $\ast$ handler\+::get\+\_\+ha\+\_\+share\+\_\+ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Get an initialized ha\+\_\+share.

\begin{DoxyReturn}{Returns}
Initialized ha\+\_\+share 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em N\+U\+LL} & ha\+\_\+share is not yet initialized. \\
\hline
{\em !=} & N\+U\+LL previous initialized ha\+\_\+share.\\
\hline
\end{DoxyRetVals}
\begin{DoxyNote}{Note}
If not a temp table, then L\+O\+C\+K\+\_\+ha\+\_\+data must be held. 
\end{DoxyNote}
\mbox{\Hypertarget{classhandler_a475f7fbe39f6ff0e9da2ac6c3d6c629e}\label{classhandler_a475f7fbe39f6ff0e9da2ac6c3d6c629e}} 
\index{handler@{handler}!get\+\_\+memory\+\_\+buffer\+\_\+size@{get\+\_\+memory\+\_\+buffer\+\_\+size}}
\index{get\+\_\+memory\+\_\+buffer\+\_\+size@{get\+\_\+memory\+\_\+buffer\+\_\+size}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+memory\+\_\+buffer\+\_\+size()}{get\_memory\_buffer\_size()}}
{\footnotesize\ttfamily virtual longlong handler\+::get\+\_\+memory\+\_\+buffer\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Return an estimate on the amount of memory the storage engine will use for caching data in memory. If this is unknown or the storage engine does not cache data in memory -\/1 is returned. \mbox{\Hypertarget{classhandler_a9187eea9999eba802ee4ae01f91dda3b}\label{classhandler_a9187eea9999eba802ee4ae01f91dda3b}} 
\index{handler@{handler}!get\+\_\+parent\+\_\+foreign\+\_\+key\+\_\+list@{get\+\_\+parent\+\_\+foreign\+\_\+key\+\_\+list}}
\index{get\+\_\+parent\+\_\+foreign\+\_\+key\+\_\+list@{get\+\_\+parent\+\_\+foreign\+\_\+key\+\_\+list}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+parent\+\_\+foreign\+\_\+key\+\_\+list()}{get\_parent\_foreign\_key\_list()}}
{\footnotesize\ttfamily virtual int handler\+::get\+\_\+parent\+\_\+foreign\+\_\+key\+\_\+list (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{\mbox{\hyperlink{classList}{List}}$<$ \mbox{\hyperlink{structst__foreign__key__info}{F\+O\+R\+E\+I\+G\+N\+\_\+\+K\+E\+Y\+\_\+\+I\+N\+FO}} $>$ $\ast$}]{f\+\_\+key\+\_\+list }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Get the list of foreign keys referencing this table.

\begin{DoxyRemark}{Remarks}
Returns the set of foreign keys where this table is the referenced or parent table.
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em thd} & The thread handle. \\
\hline
{\em f\+\_\+key\+\_\+list\mbox{[}out\mbox{]}} & The list of foreign keys.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The handler error code or zero for success. 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a8ef2926a38b2b39387ad40c55708faa2}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a163a360c0cd4575ae207553b8d5c918d}\label{classhandler_a163a360c0cd4575ae207553b8d5c918d}} 
\index{handler@{handler}!get\+\_\+row\+\_\+type@{get\+\_\+row\+\_\+type}}
\index{get\+\_\+row\+\_\+type@{get\+\_\+row\+\_\+type}!handler@{handler}}
\subsubsection{\texorpdfstring{get\+\_\+row\+\_\+type()}{get\_row\_type()}}
{\footnotesize\ttfamily virtual enum row\+\_\+type handler\+::get\+\_\+row\+\_\+type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Get the row type from the storage engine. If this method returns R\+O\+W\+\_\+\+T\+Y\+P\+E\+\_\+\+N\+O\+T\+\_\+\+U\+S\+ED, the information in H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO should be used. \mbox{\Hypertarget{classhandler_a66cc9e4971b8e768c102398da0656a7f}\label{classhandler_a66cc9e4971b8e768c102398da0656a7f}} 
\index{handler@{handler}!ha\+\_\+analyze@{ha\+\_\+analyze}}
\index{ha\+\_\+analyze@{ha\+\_\+analyze}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+analyze()}{ha\_analyze()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+analyze (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{\mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$}]{check\+\_\+opt }\end{DoxyParamCaption})}

Analyze table\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::analyze() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a49c8ce82a564b0cbf6340dc9b74a9c23}\label{classhandler_a49c8ce82a564b0cbf6340dc9b74a9c23}} 
\index{handler@{handler}!ha\+\_\+bulk\+\_\+update\+\_\+row@{ha\+\_\+bulk\+\_\+update\+\_\+row}}
\index{ha\+\_\+bulk\+\_\+update\+\_\+row@{ha\+\_\+bulk\+\_\+update\+\_\+row}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+bulk\+\_\+update\+\_\+row()}{ha\_bulk\_update\_row()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+bulk\+\_\+update\+\_\+row (\begin{DoxyParamCaption}\item[{const uchar $\ast$}]{old\+\_\+data,  }\item[{uchar $\ast$}]{new\+\_\+data,  }\item[{uint $\ast$}]{dup\+\_\+key\+\_\+found }\end{DoxyParamCaption})}

Bulk update row\+: public interface.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_ac8dd7e44bc71120ace1e467ccb02ad06}{handler\+::bulk\+\_\+update\+\_\+row()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a56545ec9967544c80d5612f8ac9b8e6e}\label{classhandler_a56545ec9967544c80d5612f8ac9b8e6e}} 
\index{handler@{handler}!ha\+\_\+check@{ha\+\_\+check}}
\index{ha\+\_\+check@{ha\+\_\+check}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+check()}{ha\_check()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+check (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{\mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$}]{check\+\_\+opt }\end{DoxyParamCaption})}

to be actually called to get \textquotesingle{}check()\textquotesingle{} functionality

Performs checks upon the table.


\begin{DoxyParams}{Parameters}
{\em thd} & thread doing C\+H\+E\+CK \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} operation \\
\hline
{\em check\+\_\+opt} & options from the parser\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em H\+A\+\_\+\+A\+D\+M\+I\+N\+\_\+\+OK} & Successful upgrade \\
\hline
{\em H\+A\+\_\+\+A\+D\+M\+I\+N\+\_\+\+N\+E\+E\+D\+S\+\_\+\+U\+P\+G\+R\+A\+DE} & Table has structures requiring upgrade \\
\hline
{\em H\+A\+\_\+\+A\+D\+M\+I\+N\+\_\+\+N\+E\+E\+D\+S\+\_\+\+A\+L\+T\+ER} & Table has structures requiring A\+L\+T\+ER \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} \\
\hline
{\em H\+A\+\_\+\+A\+D\+M\+I\+N\+\_\+\+N\+O\+T\+\_\+\+I\+M\+P\+L\+E\+M\+E\+N\+T\+ED} & \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a169d5287bdf480f8cd20f758bb2d9bd1}\label{classhandler_a169d5287bdf480f8cd20f758bb2d9bd1}} 
\index{handler@{handler}!ha\+\_\+check\+\_\+and\+\_\+repair@{ha\+\_\+check\+\_\+and\+\_\+repair}}
\index{ha\+\_\+check\+\_\+and\+\_\+repair@{ha\+\_\+check\+\_\+and\+\_\+repair}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+check\+\_\+and\+\_\+repair()}{ha\_check\_and\_repair()}}
{\footnotesize\ttfamily bool handler\+::ha\+\_\+check\+\_\+and\+\_\+repair (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd }\end{DoxyParamCaption})}

Check and repair table\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::check\+\_\+and\+\_\+repair() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_ae28824cdff2c1812e282463c908e84c2}\label{classhandler_ae28824cdff2c1812e282463c908e84c2}} 
\index{handler@{handler}!ha\+\_\+close@{ha\+\_\+close}}
\index{ha\+\_\+close@{ha\+\_\+close}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+close()}{ha\_close()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+close (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}

Close handler. \mbox{\Hypertarget{classhandler_a6ec170a4aa71186f9dc17358b55587c7}\label{classhandler_a6ec170a4aa71186f9dc17358b55587c7}} 
\index{handler@{handler}!ha\+\_\+commit\+\_\+inplace\+\_\+alter\+\_\+table@{ha\+\_\+commit\+\_\+inplace\+\_\+alter\+\_\+table}}
\index{ha\+\_\+commit\+\_\+inplace\+\_\+alter\+\_\+table@{ha\+\_\+commit\+\_\+inplace\+\_\+alter\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+commit\+\_\+inplace\+\_\+alter\+\_\+table()}{ha\_commit\_inplace\_alter\_table()}}
{\footnotesize\ttfamily bool handler\+::ha\+\_\+commit\+\_\+inplace\+\_\+alter\+\_\+table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{altered\+\_\+table,  }\item[{\mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$}]{ha\+\_\+alter\+\_\+info,  }\item[{bool}]{commit }\end{DoxyParamCaption})}

Public function wrapping the actual handler call. Allows us to enforce asserts regardless of handler implementation. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_a0786a5f57ccd3c97bff07b1afeae9c06}{commit\+\_\+inplace\+\_\+alter\+\_\+table()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a14af5825a427ba6baac74b13223637f8}\label{classhandler_a14af5825a427ba6baac74b13223637f8}} 
\index{handler@{handler}!ha\+\_\+create@{ha\+\_\+create}}
\index{ha\+\_\+create@{ha\+\_\+create}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+create()}{ha\_create()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+create (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{form,  }\item[{\mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$}]{info }\end{DoxyParamCaption})}

Create a table in the engine\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::create() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a722462d7e71059a8ed1f43d0fb28366b}\label{classhandler_a722462d7e71059a8ed1f43d0fb28366b}} 
\index{handler@{handler}!ha\+\_\+create\+\_\+handler\+\_\+files@{ha\+\_\+create\+\_\+handler\+\_\+files}}
\index{ha\+\_\+create\+\_\+handler\+\_\+files@{ha\+\_\+create\+\_\+handler\+\_\+files}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+create\+\_\+handler\+\_\+files()}{ha\_create\_handler\_files()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+create\+\_\+handler\+\_\+files (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name,  }\item[{const char $\ast$}]{old\+\_\+name,  }\item[{int}]{action\+\_\+flag,  }\item[{\mbox{\hyperlink{structst__ha__create__information}{H\+A\+\_\+\+C\+R\+E\+A\+T\+E\+\_\+\+I\+N\+FO}} $\ast$}]{info }\end{DoxyParamCaption})}

Create handler files for C\+R\+E\+A\+TE \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}}\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::create\+\_\+handler\+\_\+files() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a1fef228137a11565f7d52a60ad802004}\label{classhandler_a1fef228137a11565f7d52a60ad802004}} 
\index{handler@{handler}!ha\+\_\+delete\+\_\+all\+\_\+rows@{ha\+\_\+delete\+\_\+all\+\_\+rows}}
\index{ha\+\_\+delete\+\_\+all\+\_\+rows@{ha\+\_\+delete\+\_\+all\+\_\+rows}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+delete\+\_\+all\+\_\+rows()}{ha\_delete\_all\_rows()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+delete\+\_\+all\+\_\+rows (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Delete all rows\+: public interface.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_ac24fcaab09a75e81702c2e2c34fa0b62}{handler\+::delete\+\_\+all\+\_\+rows()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a28700a3bf1af24f9a31ebae51bf877db}\label{classhandler_a28700a3bf1af24f9a31ebae51bf877db}} 
\index{handler@{handler}!ha\+\_\+delete\+\_\+table@{ha\+\_\+delete\+\_\+table}}
\index{ha\+\_\+delete\+\_\+table@{ha\+\_\+delete\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+delete\+\_\+table()}{ha\_delete\_table()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+delete\+\_\+table (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

Delete table\+: public interface.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_ae53ec34116b901cc08e5a87f5ec681a6}{handler\+::delete\+\_\+table()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_aeeb079b3dc59160ba828ef89b4463921}\label{classhandler_aeeb079b3dc59160ba828ef89b4463921}} 
\index{handler@{handler}!ha\+\_\+disable\+\_\+indexes@{ha\+\_\+disable\+\_\+indexes}}
\index{ha\+\_\+disable\+\_\+indexes@{ha\+\_\+disable\+\_\+indexes}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+disable\+\_\+indexes()}{ha\_disable\_indexes()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+disable\+\_\+indexes (\begin{DoxyParamCaption}\item[{uint}]{mode }\end{DoxyParamCaption})}

Disable indexes\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::disable\+\_\+indexes() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a1f75cf982985d21907140a17521cd6c5}\label{classhandler_a1f75cf982985d21907140a17521cd6c5}} 
\index{handler@{handler}!ha\+\_\+discard\+\_\+or\+\_\+import\+\_\+tablespace@{ha\+\_\+discard\+\_\+or\+\_\+import\+\_\+tablespace}}
\index{ha\+\_\+discard\+\_\+or\+\_\+import\+\_\+tablespace@{ha\+\_\+discard\+\_\+or\+\_\+import\+\_\+tablespace}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+discard\+\_\+or\+\_\+import\+\_\+tablespace()}{ha\_discard\_or\_import\_tablespace()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+discard\+\_\+or\+\_\+import\+\_\+tablespace (\begin{DoxyParamCaption}\item[{my\+\_\+bool}]{discard }\end{DoxyParamCaption})}

Discard or import tablespace\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::discard\+\_\+or\+\_\+import\+\_\+tablespace() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a6bcc37ec84386f5d6cc86448781666cb}\label{classhandler_a6bcc37ec84386f5d6cc86448781666cb}} 
\index{handler@{handler}!ha\+\_\+drop\+\_\+table@{ha\+\_\+drop\+\_\+table}}
\index{ha\+\_\+drop\+\_\+table@{ha\+\_\+drop\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+drop\+\_\+table()}{ha\_drop\_table()}}
{\footnotesize\ttfamily void handler\+::ha\+\_\+drop\+\_\+table (\begin{DoxyParamCaption}\item[{const char $\ast$}]{name }\end{DoxyParamCaption})}

Drop table in the engine\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::drop\+\_\+table() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a36e9c53758728e07eb37cbb65ea3ab50}\label{classhandler_a36e9c53758728e07eb37cbb65ea3ab50}} 
\index{handler@{handler}!ha\+\_\+enable\+\_\+indexes@{ha\+\_\+enable\+\_\+indexes}}
\index{ha\+\_\+enable\+\_\+indexes@{ha\+\_\+enable\+\_\+indexes}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+enable\+\_\+indexes()}{ha\_enable\_indexes()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+enable\+\_\+indexes (\begin{DoxyParamCaption}\item[{uint}]{mode }\end{DoxyParamCaption})}

Enable indexes\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::enable\+\_\+indexes() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a30f3cbf4a769155c994ed39f76433106}\label{classhandler_a30f3cbf4a769155c994ed39f76433106}} 
\index{handler@{handler}!ha\+\_\+end\+\_\+bulk\+\_\+insert@{ha\+\_\+end\+\_\+bulk\+\_\+insert}}
\index{ha\+\_\+end\+\_\+bulk\+\_\+insert@{ha\+\_\+end\+\_\+bulk\+\_\+insert}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+end\+\_\+bulk\+\_\+insert()}{ha\_end\_bulk\_insert()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+end\+\_\+bulk\+\_\+insert (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

End bulk insert.

\begin{DoxyReturn}{Returns}
Operation status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em !=} & 0 Failure (error code returned) \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a9a99b5f8ae28bc5c374919396f8dcf08}\label{classhandler_a9a99b5f8ae28bc5c374919396f8dcf08}} 
\index{handler@{handler}!ha\+\_\+external\+\_\+lock@{ha\+\_\+external\+\_\+lock}}
\index{ha\+\_\+external\+\_\+lock@{ha\+\_\+external\+\_\+lock}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+external\+\_\+lock()}{ha\_external\_lock()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+external\+\_\+lock (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{int}]{lock\+\_\+type }\end{DoxyParamCaption})}

These functions represent the public interface to {\itshape users} of the handler class, hence they are {\itshape not} virtual. For the inheritance interface, see the (private) functions write\+\_\+row(), update\+\_\+row(), and delete\+\_\+row() below. \mbox{\Hypertarget{classhandler_afa6bd01057c6cdd86d2ea2ee4ea65ca3}\label{classhandler_afa6bd01057c6cdd86d2ea2ee4ea65ca3}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+end@{ha\+\_\+index\+\_\+end}}
\index{ha\+\_\+index\+\_\+end@{ha\+\_\+index\+\_\+end}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+end()}{ha\_index\_end()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

End use of index.

\begin{DoxyReturn}{Returns}
Operation status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em !=} & 0 Error (error code returned) \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_abd574a3025588e9b0cd49e0d6908e3b8}\label{classhandler_abd574a3025588e9b0cd49e0d6908e3b8}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+first@{ha\+\_\+index\+\_\+first}}
\index{ha\+\_\+index\+\_\+first@{ha\+\_\+index\+\_\+first}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+first()}{ha\_index\_first()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+first (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})}

Reads the first row via index.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em buf} & Row data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+F\+I\+LE} & Row not found \\
\hline
{\em !=} & 0 Error \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a0af23462b249041a0db03c1c7139d76b}\label{classhandler_a0af23462b249041a0db03c1c7139d76b}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+init@{ha\+\_\+index\+\_\+init}}
\index{ha\+\_\+index\+\_\+init@{ha\+\_\+index\+\_\+init}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+init()}{ha\_index\_init()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+init (\begin{DoxyParamCaption}\item[{uint}]{idx,  }\item[{bool}]{sorted }\end{DoxyParamCaption})}

Initialize use of index.


\begin{DoxyParams}{Parameters}
{\em idx} & Index to use \\
\hline
{\em sorted} & Use sorted order\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em !=} & 0 Error (error code returned) \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a2a7415f1744039a51ef15e923ef7da1b}\label{classhandler_a2a7415f1744039a51ef15e923ef7da1b}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+last@{ha\+\_\+index\+\_\+last}}
\index{ha\+\_\+index\+\_\+last@{ha\+\_\+index\+\_\+last}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+last()}{ha\_index\_last()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+last (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})}

Reads the last row via index.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em buf} & Row data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+F\+I\+LE} & Row not found \\
\hline
{\em !=} & 0 Error \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a4c99e96a8350ff577a94529be9387a30}\label{classhandler_a4c99e96a8350ff577a94529be9387a30}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+next@{ha\+\_\+index\+\_\+next}}
\index{ha\+\_\+index\+\_\+next@{ha\+\_\+index\+\_\+next}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+next()}{ha\_index\_next()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+next (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})}

Reads the next row via index.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em buf} & Row data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+F\+I\+LE} & Row not found \\
\hline
{\em !=} & 0 Error \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a3f79360a45d50c6b558feb1c308c4157}\label{classhandler_a3f79360a45d50c6b558feb1c308c4157}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+next\+\_\+same@{ha\+\_\+index\+\_\+next\+\_\+same}}
\index{ha\+\_\+index\+\_\+next\+\_\+same@{ha\+\_\+index\+\_\+next\+\_\+same}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+next\+\_\+same()}{ha\_index\_next\_same()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+next\+\_\+same (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{const uchar $\ast$}]{key,  }\item[{uint}]{keylen }\end{DoxyParamCaption})}

Reads the next same row via index.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em buf} & Row data \\
\hline
 & {\em key} & \mbox{\hyperlink{classKey}{Key}} to search for \\
\hline
 & {\em keylen} & Length of key\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+F\+I\+LE} & Row not found \\
\hline
{\em !=} & 0 Error \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_abb977dac0435158be227e45e04c8b798}\label{classhandler_abb977dac0435158be227e45e04c8b798}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+prev@{ha\+\_\+index\+\_\+prev}}
\index{ha\+\_\+index\+\_\+prev@{ha\+\_\+index\+\_\+prev}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+prev()}{ha\_index\_prev()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+prev (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})}

Reads the previous row via index.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em buf} & Row data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+F\+I\+LE} & Row not found \\
\hline
{\em !=} & 0 Error \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_ac831321e8d33958db4fd4968de932acf}\label{classhandler_ac831321e8d33958db4fd4968de932acf}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+read\+\_\+idx\+\_\+map@{ha\+\_\+index\+\_\+read\+\_\+idx\+\_\+map}}
\index{ha\+\_\+index\+\_\+read\+\_\+idx\+\_\+map@{ha\+\_\+index\+\_\+read\+\_\+idx\+\_\+map}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+read\+\_\+idx\+\_\+map()}{ha\_index\_read\_idx\_map()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+read\+\_\+idx\+\_\+map (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{uint}]{index,  }\item[{const uchar $\ast$}]{key,  }\item[{key\+\_\+part\+\_\+map}]{keypart\+\_\+map,  }\item[{enum ha\+\_\+rkey\+\_\+function}]{find\+\_\+flag }\end{DoxyParamCaption})}

Initializes an index and read it.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_a729d9c9c011527b81287574294887bf3}{handler\+::ha\+\_\+index\+\_\+read\+\_\+map}}. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a729d9c9c011527b81287574294887bf3}\label{classhandler_a729d9c9c011527b81287574294887bf3}} 
\index{handler@{handler}!ha\+\_\+index\+\_\+read\+\_\+map@{ha\+\_\+index\+\_\+read\+\_\+map}}
\index{ha\+\_\+index\+\_\+read\+\_\+map@{ha\+\_\+index\+\_\+read\+\_\+map}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+index\+\_\+read\+\_\+map()}{ha\_index\_read\_map()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+index\+\_\+read\+\_\+map (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{const uchar $\ast$}]{key,  }\item[{key\+\_\+part\+\_\+map}]{keypart\+\_\+map,  }\item[{enum ha\+\_\+rkey\+\_\+function}]{find\+\_\+flag }\end{DoxyParamCaption})}

Read \mbox{[}part of\mbox{]} row via \mbox{[}part of\mbox{]} index. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em buf} & buffer where store the data \\
\hline
 & {\em key} & \mbox{\hyperlink{classKey}{Key}} to search for \\
\hline
 & {\em keypart\+\_\+map} & Which part of key to use \\
\hline
 & {\em find\+\_\+flag} & Direction/condition on key usage\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success (found a record, and function has set table-\/$>$status to 0) \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+F\+I\+LE} & Row not found (function has set table-\/$>$status to S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND). End of index passed. \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+K\+E\+Y\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND} & Row not found (function has set table-\/$>$status to S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND). Index cursor positioned. \\
\hline
{\em !=} & 0 Error\\
\hline
\end{DoxyRetVals}
\begin{DoxyNote}{Note}
Positions an index cursor to the index specified in the handle. Fetches the row if available. If the key value is null, begin at the first key of the index. ha\+\_\+index\+\_\+read\+\_\+map can be restarted without calling index\+\_\+end on the previous index scan and without calling ha\+\_\+index\+\_\+init. In this case the ha\+\_\+index\+\_\+read\+\_\+map is on the same index as the previous ha\+\_\+index\+\_\+scan. This is particularly used in conjunction with multi read ranges. 
\end{DoxyNote}
\mbox{\Hypertarget{classhandler_a96b182710a133be9561afc149cb6aa8f}\label{classhandler_a96b182710a133be9561afc149cb6aa8f}} 
\index{handler@{handler}!ha\+\_\+inplace\+\_\+alter\+\_\+table@{ha\+\_\+inplace\+\_\+alter\+\_\+table}}
\index{ha\+\_\+inplace\+\_\+alter\+\_\+table@{ha\+\_\+inplace\+\_\+alter\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+inplace\+\_\+alter\+\_\+table()}{ha\_inplace\_alter\_table()}}
{\footnotesize\ttfamily bool handler\+::ha\+\_\+inplace\+\_\+alter\+\_\+table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{altered\+\_\+table,  }\item[{\mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$}]{ha\+\_\+alter\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Public function wrapping the actual handler call. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_a90b4c3a8fe1c89c6ccfec1f4b144754a}{inplace\+\_\+alter\+\_\+table()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a5b81b74b0b7b87de4f99ebe20c49dc44}\label{classhandler_a5b81b74b0b7b87de4f99ebe20c49dc44}} 
\index{handler@{handler}!ha\+\_\+notify\+\_\+table\+\_\+changed@{ha\+\_\+notify\+\_\+table\+\_\+changed}}
\index{ha\+\_\+notify\+\_\+table\+\_\+changed@{ha\+\_\+notify\+\_\+table\+\_\+changed}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+notify\+\_\+table\+\_\+changed()}{ha\_notify\_table\_changed()}}
{\footnotesize\ttfamily void handler\+::ha\+\_\+notify\+\_\+table\+\_\+changed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Public function wrapping the actual handler call. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_a26aaaf2105e60ca590b79fae82e48960}{notify\+\_\+table\+\_\+changed()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_ab5e02829386929734724b143391e0a11}\label{classhandler_ab5e02829386929734724b143391e0a11}} 
\index{handler@{handler}!ha\+\_\+open@{ha\+\_\+open}}
\index{ha\+\_\+open@{ha\+\_\+open}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+open()}{ha\_open()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+open (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{table\+\_\+arg,  }\item[{const char $\ast$}]{name,  }\item[{int}]{mode,  }\item[{int}]{test\+\_\+if\+\_\+locked }\end{DoxyParamCaption})}



Open database-\/handler. 

I\+M\+P\+L\+E\+M\+E\+N\+T\+A\+T\+I\+ON Try O\+\_\+\+R\+D\+O\+N\+LY if cannot open as O\+\_\+\+R\+D\+WR Don\textquotesingle{}t wait for locks if not H\+A\+\_\+\+O\+P\+E\+N\+\_\+\+W\+A\+I\+T\+\_\+\+I\+F\+\_\+\+L\+O\+C\+K\+ED is set \mbox{\Hypertarget{classhandler_a980a8a7650a41fd9a05a32521826ccd5}\label{classhandler_a980a8a7650a41fd9a05a32521826ccd5}} 
\index{handler@{handler}!ha\+\_\+optimize@{ha\+\_\+optimize}}
\index{ha\+\_\+optimize@{ha\+\_\+optimize}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+optimize()}{ha\_optimize()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+optimize (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{\mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$}]{check\+\_\+opt }\end{DoxyParamCaption})}

Optimize table\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::optimize() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_ad0ecf7f9bf265e6801b625768f0f2bbe}\label{classhandler_ad0ecf7f9bf265e6801b625768f0f2bbe}} 
\index{handler@{handler}!ha\+\_\+prepare\+\_\+inplace\+\_\+alter\+\_\+table@{ha\+\_\+prepare\+\_\+inplace\+\_\+alter\+\_\+table}}
\index{ha\+\_\+prepare\+\_\+inplace\+\_\+alter\+\_\+table@{ha\+\_\+prepare\+\_\+inplace\+\_\+alter\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+prepare\+\_\+inplace\+\_\+alter\+\_\+table()}{ha\_prepare\_inplace\_alter\_table()}}
{\footnotesize\ttfamily bool handler\+::ha\+\_\+prepare\+\_\+inplace\+\_\+alter\+\_\+table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{altered\+\_\+table,  }\item[{\mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$}]{ha\+\_\+alter\+\_\+info }\end{DoxyParamCaption})}

Public functions wrapping the actual handler call. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_ab25b3931a457f1821ba55ae9cce79d98}{prepare\+\_\+inplace\+\_\+alter\+\_\+table()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a9fe4a9e78c818aa2823c302f0fe65522}\label{classhandler_a9fe4a9e78c818aa2823c302f0fe65522}} 
\index{handler@{handler}!ha\+\_\+records@{ha\+\_\+records}}
\index{ha\+\_\+records@{ha\+\_\+records}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+records()}{ha\_records()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+records (\begin{DoxyParamCaption}\item[{ha\+\_\+rows $\ast$}]{num\+\_\+rows }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Public function wrapping the actual handler call, and doing error checking. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em num\+\_\+rows} & number of rows in table. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & for OK, one of the H\+A\+\_\+xxx values in case of error. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a6ee228a60527e81efd9a49ddfdd4850d}\label{classhandler_a6ee228a60527e81efd9a49ddfdd4850d}} 
\index{handler@{handler}!ha\+\_\+rename\+\_\+table@{ha\+\_\+rename\+\_\+table}}
\index{ha\+\_\+rename\+\_\+table@{ha\+\_\+rename\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+rename\+\_\+table()}{ha\_rename\_table()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+rename\+\_\+table (\begin{DoxyParamCaption}\item[{const char $\ast$}]{from,  }\item[{const char $\ast$}]{to }\end{DoxyParamCaption})}

Rename table\+: public interface.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_a58bf8fa32d87654794e6b1c3b3fb8d32}{handler\+::rename\+\_\+table()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_ad28d70543d9566894b5a81d25eca2e8e}\label{classhandler_ad28d70543d9566894b5a81d25eca2e8e}} 
\index{handler@{handler}!ha\+\_\+repair@{ha\+\_\+repair}}
\index{ha\+\_\+repair@{ha\+\_\+repair}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+repair()}{ha\_repair()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+repair (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{\mbox{\hyperlink{structst__ha__check__opt}{H\+A\+\_\+\+C\+H\+E\+C\+K\+\_\+\+O\+PT}} $\ast$}]{check\+\_\+opt }\end{DoxyParamCaption})}

Repair table\+: public interface.

\begin{DoxySeeAlso}{See also}
handler\+::repair() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a53d38f167906d8aaa9e560c71e595a42}\label{classhandler_a53d38f167906d8aaa9e560c71e595a42}} 
\index{handler@{handler}!ha\+\_\+reset@{ha\+\_\+reset}}
\index{ha\+\_\+reset@{ha\+\_\+reset}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+reset()}{ha\_reset()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Check handler usage and reset state of file to after \textquotesingle{}open\textquotesingle{}. 

\begin{DoxyNote}{Note}
can be called regardless of it is locked or not. 
\end{DoxyNote}
\mbox{\Hypertarget{classhandler_ad4d9bf34ac0a004d8c5c32267f20842f}\label{classhandler_ad4d9bf34ac0a004d8c5c32267f20842f}} 
\index{handler@{handler}!ha\+\_\+rnd\+\_\+end@{ha\+\_\+rnd\+\_\+end}}
\index{ha\+\_\+rnd\+\_\+end@{ha\+\_\+rnd\+\_\+end}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+rnd\+\_\+end()}{ha\_rnd\_end()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+rnd\+\_\+end (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

End use of random access.

\begin{DoxyReturn}{Returns}
Operation status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em !=} & 0 Error (error code returned) \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_afb5c99736cb400350e007578889b8375}\label{classhandler_afb5c99736cb400350e007578889b8375}} 
\index{handler@{handler}!ha\+\_\+rnd\+\_\+init@{ha\+\_\+rnd\+\_\+init}}
\index{ha\+\_\+rnd\+\_\+init@{ha\+\_\+rnd\+\_\+init}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+rnd\+\_\+init()}{ha\_rnd\_init()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+rnd\+\_\+init (\begin{DoxyParamCaption}\item[{bool}]{scan }\end{DoxyParamCaption})}

Initialize table for random read or scan.


\begin{DoxyParams}{Parameters}
{\em scan} & if true\+: Initialize for random scans through \mbox{\hyperlink{classhandler_a48cb9c94ca93dbfbb7e92822caba82a1}{rnd\+\_\+next()}} if false\+: Initialize for random reads through \mbox{\hyperlink{classhandler_adf659edd9d870e90c8974ae0eba7a082}{rnd\+\_\+pos()}}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em !=} & 0 Error (error code returned) \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_ad3743f3a48e7be751dbb2691be4c992a}\label{classhandler_ad3743f3a48e7be751dbb2691be4c992a}} 
\index{handler@{handler}!ha\+\_\+rnd\+\_\+next@{ha\+\_\+rnd\+\_\+next}}
\index{ha\+\_\+rnd\+\_\+next@{ha\+\_\+rnd\+\_\+next}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+rnd\+\_\+next()}{ha\_rnd\_next()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+rnd\+\_\+next (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})}

Read next row via random scan.


\begin{DoxyParams}{Parameters}
{\em buf} & Buffer to read the row into\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em !=} & 0 Error (error code returned) \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_abcd8615219b3e692e7d484d2ba6cfa86}\label{classhandler_abcd8615219b3e692e7d484d2ba6cfa86}} 
\index{handler@{handler}!ha\+\_\+rnd\+\_\+pos@{ha\+\_\+rnd\+\_\+pos}}
\index{ha\+\_\+rnd\+\_\+pos@{ha\+\_\+rnd\+\_\+pos}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+rnd\+\_\+pos()}{ha\_rnd\_pos()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+rnd\+\_\+pos (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{uchar $\ast$}]{pos }\end{DoxyParamCaption})}

Read row via random scan from position.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em buf} & Buffer to read the row into \\
\hline
 & {\em pos} & Position from position() call\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Operation status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & Success \\
\hline
{\em !=} & 0 Error (error code returned) \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a3f09a15d46c019a621b0a65bb1ec89d3}\label{classhandler_a3f09a15d46c019a621b0a65bb1ec89d3}} 
\index{handler@{handler}!ha\+\_\+start\+\_\+bulk\+\_\+insert@{ha\+\_\+start\+\_\+bulk\+\_\+insert}}
\index{ha\+\_\+start\+\_\+bulk\+\_\+insert@{ha\+\_\+start\+\_\+bulk\+\_\+insert}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+start\+\_\+bulk\+\_\+insert()}{ha\_start\_bulk\_insert()}}
{\footnotesize\ttfamily void handler\+::ha\+\_\+start\+\_\+bulk\+\_\+insert (\begin{DoxyParamCaption}\item[{ha\+\_\+rows}]{rows }\end{DoxyParamCaption})}

Start bulk insert.

Allow the handler to optimize for multiple row insert.


\begin{DoxyParams}{Parameters}
{\em rows} & Estimated rows to insert \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classhandler_a6b3015577f49008561db1d34ae750e70}\label{classhandler_a6b3015577f49008561db1d34ae750e70}} 
\index{handler@{handler}!ha\+\_\+table\+\_\+flags@{ha\+\_\+table\+\_\+flags}}
\index{ha\+\_\+table\+\_\+flags@{ha\+\_\+table\+\_\+flags}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+table\+\_\+flags()}{ha\_table\_flags()}}
{\footnotesize\ttfamily Table\+\_\+flags handler\+::ha\+\_\+table\+\_\+flags (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

The cached\+\_\+table\+\_\+flags is set at ha\+\_\+open and ha\+\_\+external\+\_\+lock \mbox{\Hypertarget{classhandler_a69803cd29d92bfecd97212354212c516}\label{classhandler_a69803cd29d92bfecd97212354212c516}} 
\index{handler@{handler}!ha\+\_\+table\+\_\+share\+\_\+psi@{ha\+\_\+table\+\_\+share\+\_\+psi}}
\index{ha\+\_\+table\+\_\+share\+\_\+psi@{ha\+\_\+table\+\_\+share\+\_\+psi}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+table\+\_\+share\+\_\+psi()}{ha\_table\_share\_psi()}}
{\footnotesize\ttfamily P\+S\+I\+\_\+table\+\_\+share $\ast$ handler\+::ha\+\_\+table\+\_\+share\+\_\+psi (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structTABLE__SHARE}{T\+A\+B\+L\+E\+\_\+\+S\+H\+A\+RE}} $\ast$}]{share }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}

Acquire the instrumented table information from a table share. 
\begin{DoxyParams}{Parameters}
{\em share} & a table share \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an instrumented table share, or N\+U\+LL. 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_a25394328a49d42bb45b3b263009f02c7}\label{classhandler_a25394328a49d42bb45b3b263009f02c7}} 
\index{handler@{handler}!ha\+\_\+truncate@{ha\+\_\+truncate}}
\index{ha\+\_\+truncate@{ha\+\_\+truncate}!handler@{handler}}
\subsubsection{\texorpdfstring{ha\+\_\+truncate()}{ha\_truncate()}}
{\footnotesize\ttfamily int handler\+::ha\+\_\+truncate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Truncate table\+: public interface.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_a13fdf15d81c256d3e6a9643532ff2126}{handler\+::truncate()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a7605ac9185a544f444604f11d61f6722}\label{classhandler_a7605ac9185a544f444604f11d61f6722}} 
\index{handler@{handler}!has\+\_\+gap\+\_\+locks@{has\+\_\+gap\+\_\+locks}}
\index{has\+\_\+gap\+\_\+locks@{has\+\_\+gap\+\_\+locks}!handler@{handler}}
\subsubsection{\texorpdfstring{has\+\_\+gap\+\_\+locks()}{has\_gap\_locks()}}
{\footnotesize\ttfamily virtual bool handler\+::has\+\_\+gap\+\_\+locks (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Query storage engine to see if it supports gap locks on this table. \mbox{\Hypertarget{classhandler_a0bb554282443af443fc8aae4533e1407}\label{classhandler_a0bb554282443af443fc8aae4533e1407}} 
\index{handler@{handler}!idx\+\_\+cond\+\_\+push@{idx\+\_\+cond\+\_\+push}}
\index{idx\+\_\+cond\+\_\+push@{idx\+\_\+cond\+\_\+push}!handler@{handler}}
\subsubsection{\texorpdfstring{idx\+\_\+cond\+\_\+push()}{idx\_cond\_push()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{classItem}{Item}}$\ast$ handler\+::idx\+\_\+cond\+\_\+push (\begin{DoxyParamCaption}\item[{uint}]{keyno,  }\item[{\mbox{\hyperlink{classItem}{Item}} $\ast$}]{idx\+\_\+cond }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Push down an index condition to the handler.

The server will use this method to push down a condition it wants the handler to evaluate when retrieving records using a specified index. The pushed index condition will only refer to fields from this handler that is contained in the index (but it may also refer to fields in other handlers). Before the handler evaluates the condition it must read the content of the index entry into the record buffer.

The handler is free to decide if and how much of the condition it will take responsibility for evaluating. Based on this evaluation it should return the part of the condition it will not evaluate. If it decides to evaluate the entire condition it should return N\+U\+LL. If it decides not to evaluate any part of the condition it should return a pointer to the same condition as given as argument.


\begin{DoxyParams}{Parameters}
{\em keyno} & the index number to evaluate the condition on \\
\hline
{\em idx\+\_\+cond} & the condition to be evaluated by the handler\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The part of the pushed condition that the handler decides not to evaluate 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_af37bd518c53c966459632584c34855d0}\label{classhandler_af37bd518c53c966459632584c34855d0}} 
\index{handler@{handler}!index\+\_\+first@{index\+\_\+first}}
\index{index\+\_\+first@{index\+\_\+first}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+first()}{index\_first()}}
{\footnotesize\ttfamily virtual int handler\+::index\+\_\+first (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a1d3598345c3543f684c566f79a61cedc}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a375fdfc86f021f336777324dd5a98a02}\label{classhandler_a375fdfc86f021f336777324dd5a98a02}} 
\index{handler@{handler}!index\+\_\+in\+\_\+memory\+\_\+estimate@{index\+\_\+in\+\_\+memory\+\_\+estimate}}
\index{index\+\_\+in\+\_\+memory\+\_\+estimate@{index\+\_\+in\+\_\+memory\+\_\+estimate}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+in\+\_\+memory\+\_\+estimate()}{index\_in\_memory\_estimate()}}
{\footnotesize\ttfamily double handler\+::index\+\_\+in\+\_\+memory\+\_\+estimate (\begin{DoxyParamCaption}\item[{uint}]{keyno }\end{DoxyParamCaption}) const}

Return an estimate of how much of the index that is currently stored in main memory.

This estimate should be the fraction of the index that currently is available in a main memory buffer. The estimate should be in the range from 0.\+0 (nothing in memory) to 1.\+0 (entire index in memory).


\begin{DoxyParams}{Parameters}
{\em keyno} & the index to get an estimate for\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The fraction of the index in main memory buffer 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_aa1d62ffab7408a031b13e547eb58be09}\label{classhandler_aa1d62ffab7408a031b13e547eb58be09}} 
\index{handler@{handler}!index\+\_\+last@{index\+\_\+last}}
\index{index\+\_\+last@{index\+\_\+last}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+last()}{index\_last()}}
{\footnotesize\ttfamily virtual int handler\+::index\+\_\+last (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a6f6e9347ec700ee952a998fa88ae68b2}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_aca48f687872e10a4fdc35b418d98b761}\label{classhandler_aca48f687872e10a4fdc35b418d98b761}} 
\index{handler@{handler}!index\+\_\+next@{index\+\_\+next}}
\index{index\+\_\+next@{index\+\_\+next}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+next()}{index\_next()}}
{\footnotesize\ttfamily virtual int handler\+::index\+\_\+next (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a865afdc25ee4ca42fafde872e476e0ff}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a5459b92420f74e6f88dec137e1941d22}\label{classhandler_a5459b92420f74e6f88dec137e1941d22}} 
\index{handler@{handler}!index\+\_\+next\+\_\+same@{index\+\_\+next\+\_\+same}}
\index{index\+\_\+next\+\_\+same@{index\+\_\+next\+\_\+same}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+next\+\_\+same()}{index\_next\_same()}}
{\footnotesize\ttfamily int handler\+::index\+\_\+next\+\_\+same (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{const uchar $\ast$}]{key,  }\item[{uint}]{keylen }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_a4a2ac6b2908a899c0ce230818bb7a993}\label{classhandler_a4a2ac6b2908a899c0ce230818bb7a993}} 
\index{handler@{handler}!index\+\_\+only\+\_\+read\+\_\+time@{index\+\_\+only\+\_\+read\+\_\+time}}
\index{index\+\_\+only\+\_\+read\+\_\+time@{index\+\_\+only\+\_\+read\+\_\+time}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+only\+\_\+read\+\_\+time()}{index\_only\_read\_time()}}
{\footnotesize\ttfamily double handler\+::index\+\_\+only\+\_\+read\+\_\+time (\begin{DoxyParamCaption}\item[{uint}]{keynr,  }\item[{double}]{records }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

\begin{DoxyRefDesc}{Deprecated}
\item[\mbox{\hyperlink{deprecated__deprecated000003}{Deprecated}}]This function is deprecated and will be removed in a future version. Use \mbox{\hyperlink{classhandler_a5575d58c0acbb1924f7f3d3eb756612a}{index\+\_\+scan\+\_\+cost()}} instead. \end{DoxyRefDesc}


Calculate cost of \textquotesingle{}index only\textquotesingle{} scan for given index and number of records


\begin{DoxyParams}{Parameters}
{\em keynr} & Index number \\
\hline
{\em records} & Estimated number of records to be retrieved\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
It is assumed that we will read trough the whole key range and that all key blocks are half full (normally things are much better). It is also assumed that each time we read the next key from the index, the handler performs a random seek, thus the cost is proportional to the number of blocks read.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
Estimated cost of \textquotesingle{}index only\textquotesingle{} scan 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_a1ab892ae78db6437119d2d25621118b7}\label{classhandler_a1ab892ae78db6437119d2d25621118b7}} 
\index{handler@{handler}!index\+\_\+prev@{index\+\_\+prev}}
\index{index\+\_\+prev@{index\+\_\+prev}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+prev()}{index\_prev()}}
{\footnotesize\ttfamily virtual int handler\+::index\+\_\+prev (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a824559f84d7f256052f0394e9276774f}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_acba0c549a00023dd44682cd9452cf830}\label{classhandler_acba0c549a00023dd44682cd9452cf830}} 
\index{handler@{handler}!index\+\_\+read\+\_\+idx\+\_\+map@{index\+\_\+read\+\_\+idx\+\_\+map}}
\index{index\+\_\+read\+\_\+idx\+\_\+map@{index\+\_\+read\+\_\+idx\+\_\+map}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+read\+\_\+idx\+\_\+map()}{index\_read\_idx\_map()}}
{\footnotesize\ttfamily int handler\+::index\+\_\+read\+\_\+idx\+\_\+map (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{uint}]{index,  }\item[{const uchar $\ast$}]{key,  }\item[{key\+\_\+part\+\_\+map}]{keypart\+\_\+map,  }\item[{enum ha\+\_\+rkey\+\_\+function}]{find\+\_\+flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index. 

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_ae069d5991214e1fdf14cc44fd865a180}\label{classhandler_ae069d5991214e1fdf14cc44fd865a180}} 
\index{handler@{handler}!index\+\_\+read\+\_\+last\+\_\+map@{index\+\_\+read\+\_\+last\+\_\+map}}
\index{index\+\_\+read\+\_\+last\+\_\+map@{index\+\_\+read\+\_\+last\+\_\+map}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+read\+\_\+last\+\_\+map()}{index\_read\_last\_map()}}
{\footnotesize\ttfamily virtual int handler\+::index\+\_\+read\+\_\+last\+\_\+map (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{const uchar $\ast$}]{key,  }\item[{key\+\_\+part\+\_\+map}]{keypart\+\_\+map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



The following functions works like index\+\_\+read, but it find the last row with the current key value or prefix. 

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classhandler_af8c2b258691e5baac8dd22d19c084b37}\label{classhandler_af8c2b258691e5baac8dd22d19c084b37}} 
\index{handler@{handler}!index\+\_\+read\+\_\+map@{index\+\_\+read\+\_\+map}}
\index{index\+\_\+read\+\_\+map@{index\+\_\+read\+\_\+map}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+read\+\_\+map()}{index\_read\_map()}}
{\footnotesize\ttfamily virtual int handler\+::index\+\_\+read\+\_\+map (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{const uchar $\ast$}]{key,  }\item[{key\+\_\+part\+\_\+map}]{keypart\+\_\+map,  }\item[{enum ha\+\_\+rkey\+\_\+function}]{find\+\_\+flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Positions an index cursor to the index specified in the handle (\textquotesingle{}active\+\_\+index\textquotesingle{}). Fetches the row if available. If the key value is null, begin at the first key of the index. 

\begin{DoxyReturn}{Returns}
0 if success (found a record, and function has set table-\/$>$status to 0); non-\/zero if no record (function has set table-\/$>$status to S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND). 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_a5575d58c0acbb1924f7f3d3eb756612a}\label{classhandler_a5575d58c0acbb1924f7f3d3eb756612a}} 
\index{handler@{handler}!index\+\_\+scan\+\_\+cost@{index\+\_\+scan\+\_\+cost}}
\index{index\+\_\+scan\+\_\+cost@{index\+\_\+scan\+\_\+cost}!handler@{handler}}
\subsubsection{\texorpdfstring{index\+\_\+scan\+\_\+cost()}{index\_scan\_cost()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} handler\+::index\+\_\+scan\+\_\+cost (\begin{DoxyParamCaption}\item[{uint}]{index,  }\item[{double}]{ranges,  }\item[{double}]{rows }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Cost estimate for reading a number of ranges from an index.

The cost estimate will only include the cost of reading data that is contained in the index. If the records need to be read, use \mbox{\hyperlink{classhandler_a196d85fe55a71cc09c642592e771b662}{read\+\_\+cost()}} instead.

\begin{DoxyNote}{Note}
The ranges parameter is currently ignored and is not taken into account in the cost estimate.

For this version it is recommended that storage engines continue to override \mbox{\hyperlink{classhandler_a4a2ac6b2908a899c0ce230818bb7a993}{index\+\_\+only\+\_\+read\+\_\+time()}} instead of this function.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em index} & the index number \\
\hline
{\em ranges} & the number of ranges to be read \\
\hline
{\em rows} & total number of rows to be read\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the estimated cost 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_ab1ad6edb66592b200a7c7ac0f947dc66}\label{classhandler_ab1ad6edb66592b200a7c7ac0f947dc66}} 
\index{handler@{handler}!init@{init}}
\index{init@{init}!handler@{handler}}
\subsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily void handler\+::init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

This is called after create to allow us to set up cached variables \mbox{\Hypertarget{classhandler_a6b6facc9d1d0bda98c814660eaa9bad7}\label{classhandler_a6b6facc9d1d0bda98c814660eaa9bad7}} 
\index{handler@{handler}!init\+\_\+with\+\_\+fields@{init\+\_\+with\+\_\+fields}}
\index{init\+\_\+with\+\_\+fields@{init\+\_\+with\+\_\+fields}!handler@{handler}}
\subsubsection{\texorpdfstring{init\+\_\+with\+\_\+fields()}{init\_with\_fields()}}
{\footnotesize\ttfamily virtual bool handler\+::init\+\_\+with\+\_\+fields (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

For My\+Rocks, secondary initialization that happens after frm is parsed into field information from within open\+\_\+binary\+\_\+frm. My\+Rocks uses this secondary init phase to analyze the key and field definitions to determine if it can expose the H\+A\+\_\+\+P\+R\+I\+M\+A\+R\+Y\+\_\+\+K\+E\+Y\+\_\+\+I\+N\+\_\+\+R\+E\+A\+D\+\_\+\+I\+N\+D\+EX flag on the table as it only supports that behavior for certain types of key combinations. Return values\+: false success, true failure. \mbox{\Hypertarget{classhandler_a90b4c3a8fe1c89c6ccfec1f4b144754a}\label{classhandler_a90b4c3a8fe1c89c6ccfec1f4b144754a}} 
\index{handler@{handler}!inplace\+\_\+alter\+\_\+table@{inplace\+\_\+alter\+\_\+table}}
\index{inplace\+\_\+alter\+\_\+table@{inplace\+\_\+alter\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{inplace\+\_\+alter\+\_\+table()}{inplace\_alter\_table()}}
{\footnotesize\ttfamily virtual bool handler\+::inplace\+\_\+alter\+\_\+table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{altered\+\_\+table,  }\item[{\mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$}]{ha\+\_\+alter\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Alter the table structure in-\/place with operations specified using H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+F\+L\+A\+GS and \mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}}. The level of concurrency allowed during this operation depends on the return value from \mbox{\hyperlink{classhandler_a67890a9deb89b9ef0128601e7687fcba}{check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter()}}.

\begin{DoxyNote}{Note}
Storage engines are responsible for reporting any errors by calling my\+\_\+error()/print\+\_\+error()

If this function reports error, \mbox{\hyperlink{classhandler_a0786a5f57ccd3c97bff07b1afeae9c06}{commit\+\_\+inplace\+\_\+alter\+\_\+table()}} will be called with commit= false.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em altered\+\_\+table} & \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} object for new version of table. \\
\hline
{\em ha\+\_\+alter\+\_\+info} & Structure describing changes to be done by A\+L\+T\+ER \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} and holding data used during in-\/place alter.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & Error \\
\hline
{\em false} & Success \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a5ff1e368997d6822e3285080fade11fe}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a37413b5d60b340ffe26a6713b65bab75}\label{classhandler_a37413b5d60b340ffe26a6713b65bab75}} 
\index{handler@{handler}!is\+\_\+fatal\+\_\+error@{is\+\_\+fatal\+\_\+error}}
\index{is\+\_\+fatal\+\_\+error@{is\+\_\+fatal\+\_\+error}!handler@{handler}}
\subsubsection{\texorpdfstring{is\+\_\+fatal\+\_\+error()}{is\_fatal\_error()}}
{\footnotesize\ttfamily bool handler\+::is\+\_\+fatal\+\_\+error (\begin{DoxyParamCaption}\item[{int}]{error }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Determine whether an error is fatal or not. 

This method is used to analyze the error to see whether the error is fatal or not. A fatal error is an error that will not be possible to handle with SP handlers and will not be subject to retry attempts on the slave.


\begin{DoxyParams}{Parameters}
{\em error} & error code received from the handler interface (H\+A\+\_\+\+E\+R\+R\+\_\+...)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the error is fatal or not 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em true} & the error is fatal \\
\hline
{\em false} & the error is not fatal\\
\hline
\end{DoxyRetVals}
This method is used to analyse the error to see whether the error is fatal or not. Further comments in header file. \mbox{\Hypertarget{classhandler_adda33331aacc500b1b974033cb64a869}\label{classhandler_adda33331aacc500b1b974033cb64a869}} 
\index{handler@{handler}!is\+\_\+fk\+\_\+defined\+\_\+on\+\_\+table\+\_\+or\+\_\+index@{is\+\_\+fk\+\_\+defined\+\_\+on\+\_\+table\+\_\+or\+\_\+index}}
\index{is\+\_\+fk\+\_\+defined\+\_\+on\+\_\+table\+\_\+or\+\_\+index@{is\+\_\+fk\+\_\+defined\+\_\+on\+\_\+table\+\_\+or\+\_\+index}!handler@{handler}}
\subsubsection{\texorpdfstring{is\+\_\+fk\+\_\+defined\+\_\+on\+\_\+table\+\_\+or\+\_\+index()}{is\_fk\_defined\_on\_table\_or\_index()}}
{\footnotesize\ttfamily virtual bool handler\+::is\+\_\+fk\+\_\+defined\+\_\+on\+\_\+table\+\_\+or\+\_\+index (\begin{DoxyParamCaption}\item[{uint}]{index }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

If index == M\+A\+X\+\_\+\+K\+EY then a check for table is made and if index $<$ M\+A\+X\+\_\+\+K\+EY then a check is made if the table has foreign keys and if a foreign key uses this index (and thus the index cannot be dropped).


\begin{DoxyParams}{Parameters}
{\em index} & Index to check if foreign key uses it\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em T\+R\+UE} & Foreign key defined on table or index \\
\hline
{\em F\+A\+L\+SE} & No foreign key defined \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a6adf9b7e7b7357f464a01f9a7ed2a1ee}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a39c5919d6a3f3098353f4517e2c81037}\label{classhandler_a39c5919d6a3f3098353f4517e2c81037}} 
\index{handler@{handler}!is\+\_\+ignorable\+\_\+error@{is\+\_\+ignorable\+\_\+error}}
\index{is\+\_\+ignorable\+\_\+error@{is\+\_\+ignorable\+\_\+error}!handler@{handler}}
\subsubsection{\texorpdfstring{is\+\_\+ignorable\+\_\+error()}{is\_ignorable\_error()}}
{\footnotesize\ttfamily bool handler\+::is\+\_\+ignorable\+\_\+error (\begin{DoxyParamCaption}\item[{int}]{error }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Determine whether an error can be ignored or not. 

This method is used to analyze the error to see whether the error is ignorable or not. Such errors will be reported as warnings instead of errors for I\+G\+N\+O\+RE statements. This means that the statement will not abort, but instead continue to the next row.

H\+A\+\_\+\+E\+R\+R\+\_\+\+F\+O\+U\+N\+D\+\_\+\+D\+U\+P\+\_\+\+U\+N\+I\+Q\+UE is a special case in My\+I\+S\+AM that means the same thing as H\+A\+\_\+\+E\+R\+R\+\_\+\+F\+O\+U\+N\+D\+\_\+\+D\+U\+P\+\_\+\+K\+EY, but can in some cases lead to a slightly different error message.


\begin{DoxyParams}{Parameters}
{\em error} & error code received from the handler interface (H\+A\+\_\+\+E\+R\+R\+\_\+...)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the error is ignorablel or not 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em true} & the error is ignorable \\
\hline
{\em false} & the error is not ignorable\\
\hline
\end{DoxyRetVals}
This method is used to analyse the error to see whether the error is ignorable or not. Further comments in header file. 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a95efd97175c4d0f4e5548473b6759e31}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a2447668275a831bcf73b5c00818254a6}\label{classhandler_a2447668275a831bcf73b5c00818254a6}} 
\index{handler@{handler}!lock\+\_\+count@{lock\+\_\+count}}
\index{lock\+\_\+count@{lock\+\_\+count}!handler@{handler}}
\subsubsection{\texorpdfstring{lock\+\_\+count()}{lock\_count()}}
{\footnotesize\ttfamily virtual uint handler\+::lock\+\_\+count (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

\begin{DoxyNote}{Note}
\mbox{\hyperlink{classhandler_a2447668275a831bcf73b5c00818254a6}{lock\+\_\+count()}} can return $>$ 1 if the table is M\+E\+R\+GE or partitioned. 
\end{DoxyNote}
\mbox{\Hypertarget{classhandler_aa3a39db9dc1cca31f4a3ec0e0e1d7300}\label{classhandler_aa3a39db9dc1cca31f4a3ec0e0e1d7300}} 
\index{handler@{handler}!lock\+\_\+shared\+\_\+ha\+\_\+data@{lock\+\_\+shared\+\_\+ha\+\_\+data}}
\index{lock\+\_\+shared\+\_\+ha\+\_\+data@{lock\+\_\+shared\+\_\+ha\+\_\+data}!handler@{handler}}
\subsubsection{\texorpdfstring{lock\+\_\+shared\+\_\+ha\+\_\+data()}{lock\_shared\_ha\_data()}}
{\footnotesize\ttfamily void handler\+::lock\+\_\+shared\+\_\+ha\+\_\+data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Take a lock for protecting shared handler data. \mbox{\Hypertarget{classhandler_a5add40a6cd7088ffef25a3816294b624}\label{classhandler_a5add40a6cd7088ffef25a3816294b624}} 
\index{handler@{handler}!multi\+\_\+range\+\_\+read\+\_\+info@{multi\+\_\+range\+\_\+read\+\_\+info}}
\index{multi\+\_\+range\+\_\+read\+\_\+info@{multi\+\_\+range\+\_\+read\+\_\+info}!handler@{handler}}
\subsubsection{\texorpdfstring{multi\+\_\+range\+\_\+read\+\_\+info()}{multi\_range\_read\_info()}}
{\footnotesize\ttfamily ha\+\_\+rows handler\+::multi\+\_\+range\+\_\+read\+\_\+info (\begin{DoxyParamCaption}\item[{uint}]{keyno,  }\item[{uint}]{n\+\_\+ranges,  }\item[{uint}]{n\+\_\+rows,  }\item[{uint $\ast$}]{bufsz,  }\item[{uint $\ast$}]{flags,  }\item[{\mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} $\ast$}]{cost }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Get cost and other information about M\+RR scan over some sequence of ranges

Calculate estimated cost and other information about an M\+RR scan for some sequence of ranges.

The ranges themselves will be known only at execution phase. When this function is called we only know number of ranges and a (rough) E(\mbox{\hyperlink{classhandler_ae5b7b96354fd25da35a940e656d91940}{records}}) within those ranges.

Currently this function is only called for \char`\"{}n-\/keypart singlepoint\char`\"{} ranges, i.\+e. each range is \char`\"{}keypart1=someconst1 A\+N\+D ... A\+N\+D keypart\+N=someconst\+N\char`\"{}

The flags parameter is a combination of those flags\+: H\+A\+\_\+\+M\+R\+R\+\_\+\+S\+O\+R\+T\+ED, H\+A\+\_\+\+M\+R\+R\+\_\+\+I\+N\+D\+E\+X\+\_\+\+O\+N\+LY, H\+A\+\_\+\+M\+R\+R\+\_\+\+N\+O\+\_\+\+A\+S\+S\+O\+C\+I\+A\+T\+I\+ON, H\+A\+\_\+\+M\+R\+R\+\_\+\+L\+I\+M\+I\+TS.


\begin{DoxyParams}{Parameters}
{\em keyno} & Index number \\
\hline
{\em n\+\_\+ranges} & Estimated number of ranges (i.\+e. intervals) in the range sequence. \\
\hline
{\em n\+\_\+rows} & Estimated total number of records contained within all of the ranges \\
\hline
{\em bufsz\mbox{[}in,out\mbox{]}} & IN\+: Size of the buffer available for use O\+UT\+: Size of the buffer that will be actually used, or 0 if buffer is not needed. \\
\hline
{\em flags\mbox{[}in,out\mbox{]}} & A combination of H\+A\+\_\+\+M\+R\+R\+\_\+$\ast$ flags \\
\hline
{\em cost\mbox{[}out\mbox{]}} & Estimated cost of M\+RR access\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & OK, $\ast$cost contains cost of the scan, $\ast$bufsz and $\ast$flags contain scan parameters. \\
\hline
{\em other} & Error or can\textquotesingle{}t perform the requested scan \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_af561f07d996700a18cd0eb636a14f32e}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a5ee356d2340552eb121d423fc01597f8}\label{classhandler_a5ee356d2340552eb121d423fc01597f8}} 
\index{handler@{handler}!multi\+\_\+range\+\_\+read\+\_\+info\+\_\+const@{multi\+\_\+range\+\_\+read\+\_\+info\+\_\+const}}
\index{multi\+\_\+range\+\_\+read\+\_\+info\+\_\+const@{multi\+\_\+range\+\_\+read\+\_\+info\+\_\+const}!handler@{handler}}
\subsubsection{\texorpdfstring{multi\+\_\+range\+\_\+read\+\_\+info\+\_\+const()}{multi\_range\_read\_info\_const()}}
{\footnotesize\ttfamily ha\+\_\+rows handler\+::multi\+\_\+range\+\_\+read\+\_\+info\+\_\+const (\begin{DoxyParamCaption}\item[{uint}]{keyno,  }\item[{\mbox{\hyperlink{structst__range__seq__if}{R\+A\+N\+G\+E\+\_\+\+S\+E\+Q\+\_\+\+IF}} $\ast$}]{seq,  }\item[{void $\ast$}]{seq\+\_\+init\+\_\+param,  }\item[{uint}]{n\+\_\+ranges\+\_\+arg,  }\item[{uint $\ast$}]{bufsz,  }\item[{uint $\ast$}]{flags,  }\item[{\mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} $\ast$}]{cost }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Get cost and other information about M\+RR scan over a known list of ranges

Calculate estimated cost and other information about an M\+RR scan for given sequence of ranges.


\begin{DoxyParams}{Parameters}
{\em keyno} & Index number \\
\hline
{\em seq} & Range sequence to be traversed \\
\hline
{\em seq\+\_\+init\+\_\+param} & First parameter for seq-\/$>$\mbox{\hyperlink{classhandler_ab1ad6edb66592b200a7c7ac0f947dc66}{init()}} \\
\hline
{\em n\+\_\+ranges\+\_\+arg} & Number of ranges in the sequence, or 0 if the caller can\textquotesingle{}t efficiently determine it \\
\hline
{\em bufsz\mbox{[}in,out\mbox{]}} & IN\+: Size of the buffer available for use O\+UT\+: Size of the buffer that is expected to be actually used, or 0 if buffer is not needed. \\
\hline
{\em flags\mbox{[}in,out\mbox{]}} & A combination of H\+A\+\_\+\+M\+R\+R\+\_\+$\ast$ flags \\
\hline
{\em cost\mbox{[}out\mbox{]}} & Estimated cost of M\+RR access\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This method (or an overriding one in a derived class) must check for thd-\/$>$killed and return H\+A\+\_\+\+P\+O\+S\+\_\+\+E\+R\+R\+OR if it is not zero. This is required for a user to be able to interrupt the calculation by killing the connection/query.
\end{DoxyNote}

\begin{DoxyRetVals}{Return values}
{\em H\+A\+\_\+\+P\+O\+S\+\_\+\+E\+R\+R\+OR} & Error or the engine is unable to perform the requested scan. Values of O\+UT parameters are undefined. \\
\hline
{\em other} & OK, $\ast$cost contains cost of the scan, $\ast$bufsz and $\ast$flags contain scan parameters. \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_abc8e0c56a5a9150ece910a132a05e826}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a33e8899f4bae262b6b91c7284f1d946e}\label{classhandler_a33e8899f4bae262b6b91c7284f1d946e}} 
\index{handler@{handler}!multi\+\_\+range\+\_\+read\+\_\+init@{multi\+\_\+range\+\_\+read\+\_\+init}}
\index{multi\+\_\+range\+\_\+read\+\_\+init@{multi\+\_\+range\+\_\+read\+\_\+init}!handler@{handler}}
\subsubsection{\texorpdfstring{multi\+\_\+range\+\_\+read\+\_\+init()}{multi\_range\_read\_init()}}
{\footnotesize\ttfamily int handler\+::multi\+\_\+range\+\_\+read\+\_\+init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structst__range__seq__if}{R\+A\+N\+G\+E\+\_\+\+S\+E\+Q\+\_\+\+IF}} $\ast$}]{seq\+\_\+funcs,  }\item[{void $\ast$}]{seq\+\_\+init\+\_\+param,  }\item[{uint}]{n\+\_\+ranges,  }\item[{uint}]{mode,  }\item[{\mbox{\hyperlink{structst__handler__buffer}{H\+A\+N\+D\+L\+E\+R\+\_\+\+B\+U\+F\+F\+ER}} $\ast$}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Initialize the M\+RR scan

Initialize the M\+RR scan. This function may do heavyweight scan initialization like row prefetching/sorting/etc (N\+O\+TE\+: but better not do it here as we may not need it, e.\+g. if we never satisfy W\+H\+E\+RE clause on previous tables. For many implementations it would be natural to do such initializations in the first multi\+\_\+read\+\_\+range\+\_\+next() call)

mode is a combination of the following flags\+: H\+A\+\_\+\+M\+R\+R\+\_\+\+S\+O\+R\+T\+ED, H\+A\+\_\+\+M\+R\+R\+\_\+\+I\+N\+D\+E\+X\+\_\+\+O\+N\+LY, H\+A\+\_\+\+M\+R\+R\+\_\+\+N\+O\+\_\+\+A\+S\+S\+O\+C\+I\+A\+T\+I\+ON


\begin{DoxyParams}{Parameters}
{\em seq} & Range sequence to be traversed \\
\hline
{\em seq\+\_\+init\+\_\+param} & First parameter for seq-\/$>$\mbox{\hyperlink{classhandler_ab1ad6edb66592b200a7c7ac0f947dc66}{init()}} \\
\hline
{\em n\+\_\+ranges} & Number of ranges in the sequence \\
\hline
{\em mode} & Flags, see the description section for the details \\
\hline
{\em buf} & I\+N\+O\+UT\+: memory buffer to be used\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
One must have called index\+\_\+init() before calling this function. Several \mbox{\hyperlink{classhandler_a33e8899f4bae262b6b91c7284f1d946e}{multi\+\_\+range\+\_\+read\+\_\+init()}} calls may be made in course of one query.
\end{DoxyNote}
Until WL\#2623 is done (see its text, section 3.\+2), the following will also hold\+: The caller will guarantee that if \char`\"{}seq-\/$>$init == mrr\+\_\+ranges\+\_\+array\+\_\+init\char`\"{} then seq\+\_\+init\+\_\+param is an array of n\+\_\+ranges K\+E\+Y\+\_\+\+M\+U\+L\+T\+I\+\_\+\+R\+A\+N\+GE structures. This property will only be used by N\+DB handler until WL\#2623 is done.

~\newline
 Buffer memory management is done according to the following scenario\+: The caller allocates the buffer and provides it to the callee by filling the members of H\+A\+N\+D\+L\+E\+R\+\_\+\+B\+U\+F\+F\+ER structure. The callee consumes all or some fraction of the provided buffer space, and sets the H\+A\+N\+D\+L\+E\+R\+\_\+\+B\+U\+F\+F\+ER members accordingly. The callee may use the buffer memory until the next \mbox{\hyperlink{classhandler_a33e8899f4bae262b6b91c7284f1d946e}{multi\+\_\+range\+\_\+read\+\_\+init()}} call is made, all records have been read, or until index\+\_\+end() call is made, whichever comes first.


\begin{DoxyRetVals}{Return values}
{\em 0} & OK \\
\hline
{\em 1} & Error \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_aba9c67b0e6bdfc66f40e30b0bccecabf}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a3419071f3d4abf183dac95ef565adfff}\label{classhandler_a3419071f3d4abf183dac95ef565adfff}} 
\index{handler@{handler}!multi\+\_\+range\+\_\+read\+\_\+next@{multi\+\_\+range\+\_\+read\+\_\+next}}
\index{multi\+\_\+range\+\_\+read\+\_\+next@{multi\+\_\+range\+\_\+read\+\_\+next}!handler@{handler}}
\subsubsection{\texorpdfstring{multi\+\_\+range\+\_\+read\+\_\+next()}{multi\_range\_read\_next()}}
{\footnotesize\ttfamily int handler\+::multi\+\_\+range\+\_\+read\+\_\+next (\begin{DoxyParamCaption}\item[{char $\ast$$\ast$}]{range\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Get next record in M\+RR scan

Default M\+RR implementation\+: read the next record


\begin{DoxyParams}{Parameters}
{\em range\+\_\+info} & O\+UT Undefined if H\+A\+\_\+\+M\+R\+R\+\_\+\+N\+O\+\_\+\+A\+S\+S\+O\+C\+I\+A\+T\+I\+ON flag is in effect Otherwise, the opaque value associated with the range that contains the returned record.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & OK \\
\hline
{\em other} & Error code \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a63ab7aa4c5bedaae4a2edb452da67fc8}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a39b30a208b304f519e8d74070a41ac19}\label{classhandler_a39b30a208b304f519e8d74070a41ac19}} 
\index{handler@{handler}!my\+\_\+eval\+\_\+gcolumn\+\_\+expr@{my\+\_\+eval\+\_\+gcolumn\+\_\+expr}}
\index{my\+\_\+eval\+\_\+gcolumn\+\_\+expr@{my\+\_\+eval\+\_\+gcolumn\+\_\+expr}!handler@{handler}}
\subsubsection{\texorpdfstring{my\+\_\+eval\+\_\+gcolumn\+\_\+expr()}{my\_eval\_gcolumn\_expr()}}
{\footnotesize\ttfamily bool handler\+::my\+\_\+eval\+\_\+gcolumn\+\_\+expr (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{table,  }\item[{const M\+Y\+\_\+\+B\+I\+T\+M\+AP $\ast$const}]{fields,  }\item[{uchar $\ast$}]{record }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Callback for computing generated column values.

Storage engines that need to have virtual column values for a row can use this function to get the values computed. The storage engine must have filled in the values for the base columns that the virutal columns depend on.


\begin{DoxyParams}{Parameters}
{\em thd} & thread handle \\
\hline
{\em table} & table object \\
\hline
{\em fields} & bitmap of field index of evaluated generated column \\
\hline
{\em record} & buff of base columns generated column depends. After calling this function, it will be used to return the value of the generated columns.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & in case of error \\
\hline
{\em false} & on success.\\
\hline
\end{DoxyRetVals}
Evaluate generated Column\textquotesingle{}s value. If the engine has to write an index entry to its U\+N\+DO log (in a D\+E\+L\+E\+TE or U\+P\+D\+A\+TE), and the index is on a virtual generated column, engine needs to calculate the column\textquotesingle{}s value. This variant of \mbox{\hyperlink{classhandler_a39b30a208b304f519e8d74070a41ac19}{handler\+::my\+\_\+eval\+\_\+gcolumn\+\_\+expr()}} is used by client threads which have a \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}}.


\begin{DoxyParams}{Parameters}
{\em thd} & Thread handle \\
\hline
{\em table} & mysql table object \\
\hline
{\em fields} & bitmap of field index of evaluated generated column \\
\hline
{\em record} & buff of base columns generated column depends. After calling this function, it will be used to return the value of generated column.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & in case of error \\
\hline
{\em false} & on success. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a32dd6a07c4f58be3273576d0cc813933}\label{classhandler_a32dd6a07c4f58be3273576d0cc813933}} 
\index{handler@{handler}!my\+\_\+eval\+\_\+gcolumn\+\_\+expr\+\_\+with\+\_\+open@{my\+\_\+eval\+\_\+gcolumn\+\_\+expr\+\_\+with\+\_\+open}}
\index{my\+\_\+eval\+\_\+gcolumn\+\_\+expr\+\_\+with\+\_\+open@{my\+\_\+eval\+\_\+gcolumn\+\_\+expr\+\_\+with\+\_\+open}!handler@{handler}}
\subsubsection{\texorpdfstring{my\+\_\+eval\+\_\+gcolumn\+\_\+expr\+\_\+with\+\_\+open()}{my\_eval\_gcolumn\_expr\_with\_open()}}
{\footnotesize\ttfamily bool handler\+::my\+\_\+eval\+\_\+gcolumn\+\_\+expr\+\_\+with\+\_\+open (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{const char $\ast$}]{db\+\_\+name,  }\item[{const char $\ast$}]{table\+\_\+name,  }\item[{const M\+Y\+\_\+\+B\+I\+T\+M\+AP $\ast$const}]{fields,  }\item[{uchar $\ast$}]{record }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Callback for generated columns processing. Will open the table, in the server {\itshape only}, and call my\+\_\+eval\+\_\+gcolumn\+\_\+expr\+\_\+helper() to do the actual processing. This function is a variant of the other \mbox{\hyperlink{classhandler_a39b30a208b304f519e8d74070a41ac19}{handler\+::my\+\_\+eval\+\_\+gcolumn\+\_\+expr()}} but is intended for use when no \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} object already exists -\/ e.\+g. from purge threads.

Note! The call to \mbox{\hyperlink{group__Data__Dictionary_ga35659d6f0f8a6d39ee3f3db7c233df52}{open\+\_\+table\+\_\+uncached()}} must be made with the last argument (open\+\_\+in\+\_\+engine) set to false. Failing to do so will cause deadlocks and incorrect behavior.


\begin{DoxyParams}{Parameters}
{\em thd} & Thread handle \\
\hline
{\em db\+\_\+name} & Database containing the table to open \\
\hline
{\em table\+\_\+name} & Name of table to open \\
\hline
{\em fields} & \mbox{\hyperlink{classBitmap}{Bitmap}} of field index of evaluated generated column \\
\hline
{\em record} & Record buffer\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true in case of error, false otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_aa6c449e2194c590eb53b6a6b5dbb362c}\label{classhandler_aa6c449e2194c590eb53b6a6b5dbb362c}} 
\index{handler@{handler}!my\+\_\+prepare\+\_\+gcolumn\+\_\+template@{my\+\_\+prepare\+\_\+gcolumn\+\_\+template}}
\index{my\+\_\+prepare\+\_\+gcolumn\+\_\+template@{my\+\_\+prepare\+\_\+gcolumn\+\_\+template}!handler@{handler}}
\subsubsection{\texorpdfstring{my\+\_\+prepare\+\_\+gcolumn\+\_\+template()}{my\_prepare\_gcolumn\_template()}}
{\footnotesize\ttfamily bool handler\+::my\+\_\+prepare\+\_\+gcolumn\+\_\+template (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{const char $\ast$}]{db\+\_\+name,  }\item[{const char $\ast$}]{table\+\_\+name,  }\item[{\mbox{\hyperlink{classhandler_ad4c241e50948859d98ceae6e39066838}{my\+\_\+gcolumn\+\_\+template\+\_\+callback\+\_\+t}}}]{myc,  }\item[{void $\ast$}]{ib\+\_\+table }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Callback to allow Inno\+DB to prepare a template for generated column processing. This function will open the table without opening in the engine and call the provided function with the \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} object made. The function will then close the \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}}.


\begin{DoxyParams}{Parameters}
{\em thd} & Thread handle \\
\hline
{\em db\+\_\+name} & Name of database containing the table \\
\hline
{\em table\+\_\+name} & Name of table to open \\
\hline
{\em myc} & Inno\+DB function to call for processing \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} \\
\hline
{\em ib\+\_\+table} & Argument for Inno\+DB function\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true in case of error, false otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_a26aaaf2105e60ca590b79fae82e48960}\label{classhandler_a26aaaf2105e60ca590b79fae82e48960}} 
\index{handler@{handler}!notify\+\_\+table\+\_\+changed@{notify\+\_\+table\+\_\+changed}}
\index{notify\+\_\+table\+\_\+changed@{notify\+\_\+table\+\_\+changed}!handler@{handler}}
\subsubsection{\texorpdfstring{notify\+\_\+table\+\_\+changed()}{notify\_table\_changed()}}
{\footnotesize\ttfamily void handler\+::notify\+\_\+table\+\_\+changed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

Notify the storage engine that the table structure (.F\+RM) has been updated.

\begin{DoxyNote}{Note}
No errors are allowed during \mbox{\hyperlink{classhandler_a26aaaf2105e60ca590b79fae82e48960}{notify\+\_\+table\+\_\+changed()}}. 
\end{DoxyNote}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a2e656837653854c38ee70a7cb46515c6}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a86930bf10b20ad19b3df07e07d28116e}\label{classhandler_a86930bf10b20ad19b3df07e07d28116e}} 
\index{handler@{handler}!number\+\_\+of\+\_\+pushed\+\_\+joins@{number\+\_\+of\+\_\+pushed\+\_\+joins}}
\index{number\+\_\+of\+\_\+pushed\+\_\+joins@{number\+\_\+of\+\_\+pushed\+\_\+joins}!handler@{handler}}
\subsubsection{\texorpdfstring{number\+\_\+of\+\_\+pushed\+\_\+joins()}{number\_of\_pushed\_joins()}}
{\footnotesize\ttfamily virtual uint handler\+::number\+\_\+of\+\_\+pushed\+\_\+joins (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Reports \#tables included in pushed join which this handler instance is part of. ==0 -\/$>$ Not pushed 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a6aaba12f45b013e5dc180f40463e802a}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_aaef865015edc575d0a50d1a6f5b13e4a}\label{classhandler_aaef865015edc575d0a50d1a6f5b13e4a}} 
\index{handler@{handler}!parent\+\_\+of\+\_\+pushed\+\_\+join@{parent\+\_\+of\+\_\+pushed\+\_\+join}}
\index{parent\+\_\+of\+\_\+pushed\+\_\+join@{parent\+\_\+of\+\_\+pushed\+\_\+join}!handler@{handler}}
\subsubsection{\texorpdfstring{parent\+\_\+of\+\_\+pushed\+\_\+join()}{parent\_of\_pushed\_join()}}
{\footnotesize\ttfamily virtual const \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}}$\ast$ handler\+::parent\+\_\+of\+\_\+pushed\+\_\+join (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

If this handler instance is a child in a pushed join sequence returned \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} instance being my parent? 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a9faa32fde75fed4ebafffd11b6c5638e}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a03831da80c8a99422edd4b4ab84fa55a}\label{classhandler_a03831da80c8a99422edd4b4ab84fa55a}} 
\index{handler@{handler}!prepare\+\_\+index\+\_\+key\+\_\+scan@{prepare\+\_\+index\+\_\+key\+\_\+scan}}
\index{prepare\+\_\+index\+\_\+key\+\_\+scan@{prepare\+\_\+index\+\_\+key\+\_\+scan}!handler@{handler}}
\subsubsection{\texorpdfstring{prepare\+\_\+index\+\_\+key\+\_\+scan()}{prepare\_index\_key\_scan()}}
{\footnotesize\ttfamily virtual int handler\+::prepare\+\_\+index\+\_\+key\+\_\+scan (\begin{DoxyParamCaption}\item[{const uchar $\ast$}]{key,  }\item[{uint}]{key\+\_\+len }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Notify storage engine about imminent index read with key length. \mbox{\Hypertarget{classhandler_a4906703169a1e43358e2d95f0d90e911}\label{classhandler_a4906703169a1e43358e2d95f0d90e911}} 
\index{handler@{handler}!prepare\+\_\+index\+\_\+key\+\_\+scan\+\_\+map@{prepare\+\_\+index\+\_\+key\+\_\+scan\+\_\+map}}
\index{prepare\+\_\+index\+\_\+key\+\_\+scan\+\_\+map@{prepare\+\_\+index\+\_\+key\+\_\+scan\+\_\+map}!handler@{handler}}
\subsubsection{\texorpdfstring{prepare\+\_\+index\+\_\+key\+\_\+scan\+\_\+map()}{prepare\_index\_key\_scan\_map()}}
{\footnotesize\ttfamily int handler\+::prepare\+\_\+index\+\_\+key\+\_\+scan\+\_\+map (\begin{DoxyParamCaption}\item[{const uchar $\ast$}]{key,  }\item[{key\+\_\+part\+\_\+map}]{keypart\+\_\+map }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Notify storage engine about imminent index read with a bitmap of used key parts. \mbox{\Hypertarget{classhandler_ad17ab5ed40c1eab55ce74ce2465c9bff}\label{classhandler_ad17ab5ed40c1eab55ce74ce2465c9bff}} 
\index{handler@{handler}!prepare\+\_\+index\+\_\+scan@{prepare\+\_\+index\+\_\+scan}}
\index{prepare\+\_\+index\+\_\+scan@{prepare\+\_\+index\+\_\+scan}!handler@{handler}}
\subsubsection{\texorpdfstring{prepare\+\_\+index\+\_\+scan()}{prepare\_index\_scan()}}
{\footnotesize\ttfamily virtual int handler\+::prepare\+\_\+index\+\_\+scan (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Notify storage engine about imminent index scan where a large number of rows is expected to be returned. Does not replace nor call index\+\_\+init. \mbox{\Hypertarget{classhandler_ab25b3931a457f1821ba55ae9cce79d98}\label{classhandler_ab25b3931a457f1821ba55ae9cce79d98}} 
\index{handler@{handler}!prepare\+\_\+inplace\+\_\+alter\+\_\+table@{prepare\+\_\+inplace\+\_\+alter\+\_\+table}}
\index{prepare\+\_\+inplace\+\_\+alter\+\_\+table@{prepare\+\_\+inplace\+\_\+alter\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{prepare\+\_\+inplace\+\_\+alter\+\_\+table()}{prepare\_inplace\_alter\_table()}}
{\footnotesize\ttfamily virtual bool handler\+::prepare\+\_\+inplace\+\_\+alter\+\_\+table (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} $\ast$}]{altered\+\_\+table,  }\item[{\mbox{\hyperlink{classAlter__inplace__info}{Alter\+\_\+inplace\+\_\+info}} $\ast$}]{ha\+\_\+alter\+\_\+info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Allows the storage engine to update internal structures with concurrent writes blocked. If \mbox{\hyperlink{classhandler_a67890a9deb89b9ef0128601e7687fcba}{check\+\_\+if\+\_\+supported\+\_\+inplace\+\_\+alter()}} returns H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+I\+N\+P\+L\+A\+C\+E\+\_\+\+N\+O\+\_\+\+L\+O\+C\+K\+\_\+\+A\+F\+T\+E\+R\+\_\+\+P\+R\+E\+P\+A\+RE or H\+A\+\_\+\+A\+L\+T\+E\+R\+\_\+\+I\+N\+P\+L\+A\+C\+E\+\_\+\+S\+H\+A\+R\+E\+D\+\_\+\+A\+F\+T\+E\+R\+\_\+\+P\+R\+E\+P\+A\+RE, this function is called with exclusive lock otherwise the same level of locking as for \mbox{\hyperlink{classhandler_a90b4c3a8fe1c89c6ccfec1f4b144754a}{inplace\+\_\+alter\+\_\+table()}} will be used.

\begin{DoxyNote}{Note}
Storage engines are responsible for reporting any errors by calling my\+\_\+error()/print\+\_\+error()

If this function reports error, \mbox{\hyperlink{classhandler_a0786a5f57ccd3c97bff07b1afeae9c06}{commit\+\_\+inplace\+\_\+alter\+\_\+table()}} will be called with commit= false.

For partitioning, failing to prepare one partition, means that \mbox{\hyperlink{classhandler_a0786a5f57ccd3c97bff07b1afeae9c06}{commit\+\_\+inplace\+\_\+alter\+\_\+table()}} will be called to roll back changes for all partitions. This means that \mbox{\hyperlink{classhandler_a0786a5f57ccd3c97bff07b1afeae9c06}{commit\+\_\+inplace\+\_\+alter\+\_\+table()}} might be called without \mbox{\hyperlink{classhandler_ab25b3931a457f1821ba55ae9cce79d98}{prepare\+\_\+inplace\+\_\+alter\+\_\+table()}} having been called first for a given partition.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em altered\+\_\+table} & \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} object for new version of table. \\
\hline
{\em ha\+\_\+alter\+\_\+info} & Structure describing changes to be done by A\+L\+T\+ER \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} and holding data used during in-\/place alter.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & Error \\
\hline
{\em false} & Success \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a3d7235ae7ee13ad3a572af0fd5c15291}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_aa111c313513f50300e9740aeb3e4cfc4}\label{classhandler_aa111c313513f50300e9740aeb3e4cfc4}} 
\index{handler@{handler}!prepare\+\_\+range\+\_\+scan@{prepare\+\_\+range\+\_\+scan}}
\index{prepare\+\_\+range\+\_\+scan@{prepare\+\_\+range\+\_\+scan}!handler@{handler}}
\subsubsection{\texorpdfstring{prepare\+\_\+range\+\_\+scan()}{prepare\_range\_scan()}}
{\footnotesize\ttfamily virtual int handler\+::prepare\+\_\+range\+\_\+scan (\begin{DoxyParamCaption}\item[{const key\+\_\+range $\ast$}]{start\+\_\+key,  }\item[{const key\+\_\+range $\ast$}]{end\+\_\+key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Notify storage engine about imminent index range scan. \mbox{\Hypertarget{classhandler_a1c885f4b3b5bf6d2878225a188b5599f}\label{classhandler_a1c885f4b3b5bf6d2878225a188b5599f}} 
\index{handler@{handler}!primary\+\_\+key\+\_\+is\+\_\+clustered@{primary\+\_\+key\+\_\+is\+\_\+clustered}}
\index{primary\+\_\+key\+\_\+is\+\_\+clustered@{primary\+\_\+key\+\_\+is\+\_\+clustered}!handler@{handler}}
\subsubsection{\texorpdfstring{primary\+\_\+key\+\_\+is\+\_\+clustered()}{primary\_key\_is\_clustered()}}
{\footnotesize\ttfamily virtual bool handler\+::primary\+\_\+key\+\_\+is\+\_\+clustered (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Check if the primary key is clustered or not.


\begin{DoxyRetVals}{Return values}
{\em true} & Primary key (if there is one) is a clustered key covering all fields \\
\hline
{\em false} & otherwise \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_abf1a2f928fcc952bbe31d8c496ef0dce}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_afda4f1390385a4dc0bfd2981fee23e6c}\label{classhandler_afda4f1390385a4dc0bfd2981fee23e6c}} 
\index{handler@{handler}!print\+\_\+error@{print\+\_\+error}}
\index{print\+\_\+error@{print\+\_\+error}!handler@{handler}}
\subsubsection{\texorpdfstring{print\+\_\+error()}{print\_error()}}
{\footnotesize\ttfamily void handler\+::print\+\_\+error (\begin{DoxyParamCaption}\item[{int}]{error,  }\item[{myf}]{errflag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Print error that we got from handler function.

\begin{DoxyNote}{Note}
In case of delete table it\textquotesingle{}s only safe to use the following parts of the \textquotesingle{}table\textquotesingle{} structure\+:
\begin{DoxyItemize}
\item table-\/$>$s-\/$>$path
\item table-\/$>$alias 
\end{DoxyItemize}
\end{DoxyNote}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_ab4b4b9ed3726be8a4a0887785a5ed530}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a196d85fe55a71cc09c642592e771b662}\label{classhandler_a196d85fe55a71cc09c642592e771b662}} 
\index{handler@{handler}!read\+\_\+cost@{read\+\_\+cost}}
\index{read\+\_\+cost@{read\+\_\+cost}!handler@{handler}}
\subsubsection{\texorpdfstring{read\+\_\+cost()}{read\_cost()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} handler\+::read\+\_\+cost (\begin{DoxyParamCaption}\item[{uint}]{index,  }\item[{double}]{ranges,  }\item[{double}]{rows }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Cost estimate for reading a set of ranges from the table using an index to access it.

\begin{DoxyNote}{Note}
For this version it is recommended that storage engines continue to override \mbox{\hyperlink{classhandler_a061b519fb16fbff126b0e21530973c2e}{read\+\_\+time()}} instead of this function.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em index} & the index number \\
\hline
{\em ranges} & the number of ranges to be read \\
\hline
{\em rows} & total number of rows to be read\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the estimated cost 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_aff50b704d53d715d6b0fd3534c6107d8}\label{classhandler_aff50b704d53d715d6b0fd3534c6107d8}} 
\index{handler@{handler}!read\+\_\+first\+\_\+row@{read\+\_\+first\+\_\+row}}
\index{read\+\_\+first\+\_\+row@{read\+\_\+first\+\_\+row}!handler@{handler}}
\subsubsection{\texorpdfstring{read\+\_\+first\+\_\+row()}{read\_first\_row()}}
{\footnotesize\ttfamily int handler\+::read\+\_\+first\+\_\+row (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{uint}]{primary\+\_\+key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Read first row (only) from a table.

This is never called for Inno\+DB tables, as these table types has the H\+A\+\_\+\+S\+T\+A\+T\+S\+\_\+\+R\+E\+C\+O\+R\+D\+S\+\_\+\+I\+S\+\_\+\+E\+X\+A\+CT set. \mbox{\Hypertarget{classhandler_a3a0d596ff3ddc77b4f0ad990c4c4cb4b}\label{classhandler_a3a0d596ff3ddc77b4f0ad990c4c4cb4b}} 
\index{handler@{handler}!read\+\_\+range\+\_\+first@{read\+\_\+range\+\_\+first}}
\index{read\+\_\+range\+\_\+first@{read\+\_\+range\+\_\+first}!handler@{handler}}
\subsubsection{\texorpdfstring{read\+\_\+range\+\_\+first()}{read\_range\_first()}}
{\footnotesize\ttfamily int handler\+::read\+\_\+range\+\_\+first (\begin{DoxyParamCaption}\item[{const key\+\_\+range $\ast$}]{start\+\_\+key,  }\item[{const key\+\_\+range $\ast$}]{end\+\_\+key,  }\item[{bool}]{eq\+\_\+range\+\_\+arg,  }\item[{bool}]{sorted }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Read first row between two ranges. Store ranges for future calls to read\+\_\+range\+\_\+next. 


\begin{DoxyParams}{Parameters}
{\em start\+\_\+key} & Start key. Is 0 if no min range \\
\hline
{\em end\+\_\+key} & End key. Is 0 if no max range \\
\hline
{\em eq\+\_\+range\+\_\+arg} & Set to 1 if start\+\_\+key == end\+\_\+key \\
\hline
{\em sorted} & Set to 1 if result should be sorted per key\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Record is read into table-\/$>$record\mbox{[}0\mbox{]}
\end{DoxyNote}

\begin{DoxyRetVals}{Return values}
{\em 0} & Found row \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+F\+I\+LE} & No rows in range \\
\hline
{\em } & \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a4ebf9b2b84870f08b62e5e3f5465aae8}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_ae4632aa56c9c66a57558f849f8e01271}\label{classhandler_ae4632aa56c9c66a57558f849f8e01271}} 
\index{handler@{handler}!read\+\_\+range\+\_\+next@{read\+\_\+range\+\_\+next}}
\index{read\+\_\+range\+\_\+next@{read\+\_\+range\+\_\+next}!handler@{handler}}
\subsubsection{\texorpdfstring{read\+\_\+range\+\_\+next()}{read\_range\_next()}}
{\footnotesize\ttfamily int handler\+::read\+\_\+range\+\_\+next (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Read next row between two endpoints. 

\begin{DoxyNote}{Note}
Record is read into table-\/$>$record\mbox{[}0\mbox{]}
\end{DoxyNote}

\begin{DoxyRetVals}{Return values}
{\em 0} & Found row \\
\hline
{\em H\+A\+\_\+\+E\+R\+R\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+F\+I\+LE} & No rows in range \\
\hline
{\em } & \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_ac4ca12e4aa287eaf6a50c43219a1c776}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a061b519fb16fbff126b0e21530973c2e}\label{classhandler_a061b519fb16fbff126b0e21530973c2e}} 
\index{handler@{handler}!read\+\_\+time@{read\+\_\+time}}
\index{read\+\_\+time@{read\+\_\+time}!handler@{handler}}
\subsubsection{\texorpdfstring{read\+\_\+time()}{read\_time()}}
{\footnotesize\ttfamily virtual double handler\+::read\+\_\+time (\begin{DoxyParamCaption}\item[{uint}]{index,  }\item[{uint}]{ranges,  }\item[{ha\+\_\+rows}]{rows }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

The cost of reading a set of ranges from the table using an index to access it.

\begin{DoxyRefDesc}{Deprecated}
\item[\mbox{\hyperlink{deprecated__deprecated000002}{Deprecated}}]This function is deprecated and will be removed in a future version. Use \mbox{\hyperlink{classhandler_a196d85fe55a71cc09c642592e771b662}{read\+\_\+cost()}} instead.\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em index} & The index number. \\
\hline
{\em ranges} & The number of ranges to be read. \\
\hline
{\em rows} & Total number of rows to be read.\\
\hline
\end{DoxyParams}
This method can be used to calculate the total cost of scanning a table using an index by calling it using read\+\_\+time(index, 1, table\+\_\+size). \mbox{\Hypertarget{classhandler_ae5b7b96354fd25da35a940e656d91940}\label{classhandler_ae5b7b96354fd25da35a940e656d91940}} 
\index{handler@{handler}!records@{records}}
\index{records@{records}!handler@{handler}}
\subsubsection{\texorpdfstring{records()}{records()}}
{\footnotesize\ttfamily virtual int handler\+::records (\begin{DoxyParamCaption}\item[{ha\+\_\+rows $\ast$}]{num\+\_\+rows }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Number of rows in table. It will only be called if (table\+\_\+flags() \& (H\+A\+\_\+\+H\+A\+S\+\_\+\+R\+E\+C\+O\+R\+DS $\vert$ H\+A\+\_\+\+S\+T\+A\+T\+S\+\_\+\+R\+E\+C\+O\+R\+D\+S\+\_\+\+I\+S\+\_\+\+E\+X\+A\+CT)) != 0 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em num\+\_\+rows} & number of rows in table. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em 0} & for OK, one of the H\+A\+\_\+xxx values in case of error. \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a31757e2658abd318909a0d190a3795c0}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_af42324038f030519d7476bf915780341}\label{classhandler_af42324038f030519d7476bf915780341}} 
\index{handler@{handler}!register\+\_\+query\+\_\+cache\+\_\+table@{register\+\_\+query\+\_\+cache\+\_\+table}}
\index{register\+\_\+query\+\_\+cache\+\_\+table@{register\+\_\+query\+\_\+cache\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{register\+\_\+query\+\_\+cache\+\_\+table()}{register\_query\_cache\_table()}}
{\footnotesize\ttfamily virtual my\+\_\+bool handler\+::register\+\_\+query\+\_\+cache\+\_\+table (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{char $\ast$}]{table\+\_\+key,  }\item[{size\+\_\+t}]{key\+\_\+length,  }\item[{qc\+\_\+engine\+\_\+callback $\ast$}]{engine\+\_\+callback,  }\item[{ulonglong $\ast$}]{engine\+\_\+data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Register a named table with a call back function to the query cache. 


\begin{DoxyParams}[1]{Parameters}
 & {\em thd} & The thread handle \\
\hline
 & {\em table\+\_\+key} & A pointer to the table name in the table cache \\
\hline
 & {\em key\+\_\+length} & The length of the table name \\
\hline
\mbox{\texttt{ out}}  & {\em engine\+\_\+callback} & The pointer to the storage engine call back function \\
\hline
\mbox{\texttt{ out}}  & {\em engine\+\_\+data} & Storage engine specific data which could be anything\\
\hline
\end{DoxyParams}
This method offers the storage engine, the possibility to store a reference to a table name which is going to be used with query cache. The method is called each time a statement is written to the cache and can be used to verify if a specific statement is cachable. It also offers the possibility to register a generic (but static) call back function which is called each time a statement is matched against the query cache.

\begin{DoxyNote}{Note}
If engine\+\_\+data supplied with this function is different from engine\+\_\+data supplied with the callback function, and the callback returns F\+A\+L\+SE, a table invalidation on the current table will occur.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
Upon success the engine\+\_\+callback will point to the storage engine call back function, if any, and engine\+\_\+data will point to any storage engine data used in the specific implementation. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em T\+R\+UE} & Success \\
\hline
{\em F\+A\+L\+SE} & The specified table or current statement should not be cached \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_abef3e8ffe1d4b952fc59b356d3d5f142}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a58bf8fa32d87654794e6b1c3b3fb8d32}\label{classhandler_a58bf8fa32d87654794e6b1c3b3fb8d32}} 
\index{handler@{handler}!rename\+\_\+table@{rename\+\_\+table}}
\index{rename\+\_\+table@{rename\+\_\+table}!handler@{handler}}
\subsubsection{\texorpdfstring{rename\+\_\+table()}{rename\_table()}}
{\footnotesize\ttfamily int handler\+::rename\+\_\+table (\begin{DoxyParamCaption}\item[{const char $\ast$}]{from,  }\item[{const char $\ast$}]{to }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

Default \mbox{\hyperlink{classhandler_a58bf8fa32d87654794e6b1c3b3fb8d32}{rename\+\_\+table()}} and \mbox{\hyperlink{classhandler_ae53ec34116b901cc08e5a87f5ec681a6}{delete\+\_\+table()}} rename/delete files with a given name and extensions from \mbox{\hyperlink{classhandler_a748d5e5b6dbbb0681cbac2ad881505c9}{bas\+\_\+ext()}}.

These methods can be overridden, but their default implementation provide useful functionality. 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a5609bf8b91966dacc3610fc7ceffc314}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a48cb9c94ca93dbfbb7e92822caba82a1}\label{classhandler_a48cb9c94ca93dbfbb7e92822caba82a1}} 
\index{handler@{handler}!rnd\+\_\+next@{rnd\+\_\+next}}
\index{rnd\+\_\+next@{rnd\+\_\+next}!handler@{handler}}
\subsubsection{\texorpdfstring{rnd\+\_\+next()}{rnd\_next()}}
{\footnotesize\ttfamily virtual int handler\+::rnd\+\_\+next (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}


Implemented in \mbox{\hyperlink{classha__ndbcluster_adc93bae43a800cc5ba5057b306136de1}{ha\+\_\+ndbcluster}}, and \mbox{\hyperlink{classha__ndbinfo_aafb71ce870019170b8949672a26387c3}{ha\+\_\+ndbinfo}}.

\mbox{\Hypertarget{classhandler_adf659edd9d870e90c8974ae0eba7a082}\label{classhandler_adf659edd9d870e90c8974ae0eba7a082}} 
\index{handler@{handler}!rnd\+\_\+pos@{rnd\+\_\+pos}}
\index{rnd\+\_\+pos@{rnd\+\_\+pos}!handler@{handler}}
\subsubsection{\texorpdfstring{rnd\+\_\+pos()}{rnd\_pos()}}
{\footnotesize\ttfamily virtual int handler\+::rnd\+\_\+pos (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{buf,  }\item[{uchar $\ast$}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}

\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classhandler_af8c2b258691e5baac8dd22d19c084b37}{index\+\_\+read\+\_\+map()}}. 
\end{DoxySeeAlso}


Implemented in \mbox{\hyperlink{classha__ndbcluster_a8980053ce56e386ced321a1ad88d1cc2}{ha\+\_\+ndbcluster}}, and \mbox{\hyperlink{classha__ndbinfo_a3c82928e6d10f1e83b118cc6fa7ce088}{ha\+\_\+ndbinfo}}.

\mbox{\Hypertarget{classhandler_ac2be2fa5d347252f8a28dce931654b76}\label{classhandler_ac2be2fa5d347252f8a28dce931654b76}} 
\index{handler@{handler}!rnd\+\_\+pos\+\_\+by\+\_\+record@{rnd\+\_\+pos\+\_\+by\+\_\+record}}
\index{rnd\+\_\+pos\+\_\+by\+\_\+record@{rnd\+\_\+pos\+\_\+by\+\_\+record}!handler@{handler}}
\subsubsection{\texorpdfstring{rnd\+\_\+pos\+\_\+by\+\_\+record()}{rnd\_pos\_by\_record()}}
{\footnotesize\ttfamily virtual int handler\+::rnd\+\_\+pos\+\_\+by\+\_\+record (\begin{DoxyParamCaption}\item[{uchar $\ast$}]{record }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

This function only works for handlers having H\+A\+\_\+\+P\+R\+I\+M\+A\+R\+Y\+\_\+\+K\+E\+Y\+\_\+\+R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+F\+O\+R\+\_\+\+P\+O\+S\+I\+T\+I\+ON set. It will return the row with the PK given in the record argument. \mbox{\Hypertarget{classhandler_a624f6946109f48559e92a9e7c1b86517}\label{classhandler_a624f6946109f48559e92a9e7c1b86517}} 
\index{handler@{handler}!root\+\_\+of\+\_\+pushed\+\_\+join@{root\+\_\+of\+\_\+pushed\+\_\+join}}
\index{root\+\_\+of\+\_\+pushed\+\_\+join@{root\+\_\+of\+\_\+pushed\+\_\+join}!handler@{handler}}
\subsubsection{\texorpdfstring{root\+\_\+of\+\_\+pushed\+\_\+join()}{root\_of\_pushed\_join()}}
{\footnotesize\ttfamily virtual const \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}}$\ast$ handler\+::root\+\_\+of\+\_\+pushed\+\_\+join (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

If this handler instance is part of a pushed join sequence returned \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} instance being root of the pushed query? 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_abf2a5948eca40262f5d533d7c57ca414}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_af0be0637dfaf4fc4a2dc89334c350ec7}\label{classhandler_af0be0637dfaf4fc4a2dc89334c350ec7}} 
\index{handler@{handler}!rpl\+\_\+can\+\_\+handle\+\_\+stm\+\_\+event@{rpl\+\_\+can\+\_\+handle\+\_\+stm\+\_\+event}}
\index{rpl\+\_\+can\+\_\+handle\+\_\+stm\+\_\+event@{rpl\+\_\+can\+\_\+handle\+\_\+stm\+\_\+event}!handler@{handler}}
\subsubsection{\texorpdfstring{rpl\+\_\+can\+\_\+handle\+\_\+stm\+\_\+event()}{rpl\_can\_handle\_stm\_event()}}
{\footnotesize\ttfamily virtual bool handler\+::rpl\+\_\+can\+\_\+handle\+\_\+stm\+\_\+event (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Query storage engine to see if it can support handling specific replication method in its current configuration. \mbox{\Hypertarget{classhandler_a5f01ea7ce530c3a234e5d17363204f13}\label{classhandler_a5f01ea7ce530c3a234e5d17363204f13}} 
\index{handler@{handler}!rpl\+\_\+lookup\+\_\+rows@{rpl\+\_\+lookup\+\_\+rows}}
\index{rpl\+\_\+lookup\+\_\+rows@{rpl\+\_\+lookup\+\_\+rows}!handler@{handler}}
\subsubsection{\texorpdfstring{rpl\+\_\+lookup\+\_\+rows()}{rpl\_lookup\_rows()}}
{\footnotesize\ttfamily virtual bool handler\+::rpl\+\_\+lookup\+\_\+rows (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Determine whether the storage engine asks for row-\/based replication that may skip the lookup of the old row image.

\begin{DoxyReturn}{Returns}
true if old rows should be read (the default) false if old rows should not be read 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_a65f8e5188e2bd9636a564bbc0c3fef86}\label{classhandler_a65f8e5188e2bd9636a564bbc0c3fef86}} 
\index{handler@{handler}!scan\+\_\+time@{scan\+\_\+time}}
\index{scan\+\_\+time@{scan\+\_\+time}!handler@{handler}}
\subsubsection{\texorpdfstring{scan\+\_\+time()}{scan\_time()}}
{\footnotesize\ttfamily virtual double handler\+::scan\+\_\+time (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

\begin{DoxyRefDesc}{Deprecated}
\item[\mbox{\hyperlink{deprecated__deprecated000001}{Deprecated}}]This function is deprecated and will be removed in a future version. Use \mbox{\hyperlink{classhandler_a5e9380355a7eea5386ef061f36479258}{table\+\_\+scan\+\_\+cost()}} instead. \end{DoxyRefDesc}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a21574780af8b6cdc0bbcf8dc5ccb5164}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a4b7dfb95a0da2e828ac018aa2b4abe3a}\label{classhandler_a4b7dfb95a0da2e828ac018aa2b4abe3a}} 
\index{handler@{handler}!set\+\_\+end\+\_\+range@{set\+\_\+end\+\_\+range}}
\index{set\+\_\+end\+\_\+range@{set\+\_\+end\+\_\+range}!handler@{handler}}
\subsubsection{\texorpdfstring{set\+\_\+end\+\_\+range()}{set\_end\_range()}}
{\footnotesize\ttfamily void handler\+::set\+\_\+end\+\_\+range (\begin{DoxyParamCaption}\item[{const key\+\_\+range $\ast$}]{range,  }\item[{enum\+\_\+range\+\_\+scan\+\_\+direction}]{direction }\end{DoxyParamCaption})}

Set the end position for a range scan. This is used for checking for when to end the range scan and by the I\+CP code to determine that the next record is within the current range.


\begin{DoxyParams}{Parameters}
{\em range} & The end value for the range scan \\
\hline
{\em direction} & Direction of the range scan \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classhandler_ab24470ac1d4ac336cedbe7c245d321c9}\label{classhandler_ab24470ac1d4ac336cedbe7c245d321c9}} 
\index{handler@{handler}!set\+\_\+ha\+\_\+share\+\_\+ptr@{set\+\_\+ha\+\_\+share\+\_\+ptr}}
\index{set\+\_\+ha\+\_\+share\+\_\+ptr@{set\+\_\+ha\+\_\+share\+\_\+ptr}!handler@{handler}}
\subsubsection{\texorpdfstring{set\+\_\+ha\+\_\+share\+\_\+ptr()}{set\_ha\_share\_ptr()}}
{\footnotesize\ttfamily void handler\+::set\+\_\+ha\+\_\+share\+\_\+ptr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classHandler__share}{Handler\+\_\+share}} $\ast$}]{arg\+\_\+ha\+\_\+share }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Set ha\+\_\+share to be used by all instances of the same table/partition.


\begin{DoxyParams}{Parameters}
{\em ha\+\_\+share} & \mbox{\hyperlink{classHandler__share}{Handler\+\_\+share}} to be shared.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
If not a temp table, then L\+O\+C\+K\+\_\+ha\+\_\+data must be held. 
\end{DoxyNote}
\mbox{\Hypertarget{classhandler_acdaf7319a6498f655f8f07b1b34b12fc}\label{classhandler_acdaf7319a6498f655f8f07b1b34b12fc}} 
\index{handler@{handler}!start\+\_\+bulk\+\_\+delete@{start\+\_\+bulk\+\_\+delete}}
\index{start\+\_\+bulk\+\_\+delete@{start\+\_\+bulk\+\_\+delete}!handler@{handler}}
\subsubsection{\texorpdfstring{start\+\_\+bulk\+\_\+delete()}{start\_bulk\_delete()}}
{\footnotesize\ttfamily virtual bool handler\+::start\+\_\+bulk\+\_\+delete (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}


\begin{DoxyRetVals}{Return values}
{\em 0} & Bulk delete used by handler \\
\hline
{\em 1} & Bulk delete not used, normal operation used \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classhandler_a7488245f51aa4676c872bb0564dbe71f}\label{classhandler_a7488245f51aa4676c872bb0564dbe71f}} 
\index{handler@{handler}!start\+\_\+bulk\+\_\+update@{start\+\_\+bulk\+\_\+update}}
\index{start\+\_\+bulk\+\_\+update@{start\+\_\+bulk\+\_\+update}!handler@{handler}}
\subsubsection{\texorpdfstring{start\+\_\+bulk\+\_\+update()}{start\_bulk\_update()}}
{\footnotesize\ttfamily virtual bool handler\+::start\+\_\+bulk\+\_\+update (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}


\begin{DoxyRetVals}{Return values}
{\em 0} & Bulk update used by handler \\
\hline
{\em 1} & Bulk update not used, normal operation used \\
\hline
\end{DoxyRetVals}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_aa852a48bce2fe6fbbe70b83022d74ed2}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a6cadefb8724982848541e06a394917e8}\label{classhandler_a6cadefb8724982848541e06a394917e8}} 
\index{handler@{handler}!start\+\_\+psi\+\_\+batch\+\_\+mode@{start\+\_\+psi\+\_\+batch\+\_\+mode}}
\index{start\+\_\+psi\+\_\+batch\+\_\+mode@{start\+\_\+psi\+\_\+batch\+\_\+mode}!handler@{handler}}
\subsubsection{\texorpdfstring{start\+\_\+psi\+\_\+batch\+\_\+mode()}{start\_psi\_batch\_mode()}}
{\footnotesize\ttfamily void handler\+::start\+\_\+psi\+\_\+batch\+\_\+mode (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Put the handler in \textquotesingle{}batch\textquotesingle{} mode when collecting table io instrumented events. When operating in batch mode\+:
\begin{DoxyItemize}
\item a single start event is generated in the performance schema.
\item all table io performed between {\ttfamily start\+\_\+psi\+\_\+batch\+\_\+mode} and {\ttfamily end\+\_\+psi\+\_\+batch\+\_\+mode} is not instrumented\+: the number of rows affected is counted instead in {\ttfamily m\+\_\+psi\+\_\+numrows}.
\item a single end event is generated in the performance schema when the batch mode ends with {\ttfamily end\+\_\+psi\+\_\+batch\+\_\+mode}. 
\end{DoxyItemize}\mbox{\Hypertarget{classhandler_a3e2428788c2437e4e33c4b390cc697f7}\label{classhandler_a3e2428788c2437e4e33c4b390cc697f7}} 
\index{handler@{handler}!start\+\_\+read\+\_\+removal@{start\+\_\+read\+\_\+removal}}
\index{start\+\_\+read\+\_\+removal@{start\+\_\+read\+\_\+removal}!handler@{handler}}
\subsubsection{\texorpdfstring{start\+\_\+read\+\_\+removal()}{start\_read\_removal()}}
{\footnotesize\ttfamily virtual bool handler\+::start\+\_\+read\+\_\+removal (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Start read (before write) removal on the current table. \begin{DoxySeeAlso}{See also}
H\+A\+\_\+\+R\+E\+A\+D\+\_\+\+B\+E\+F\+O\+R\+E\+\_\+\+W\+R\+I\+T\+E\+\_\+\+R\+E\+M\+O\+V\+AL 
\end{DoxySeeAlso}


Reimplemented in \mbox{\hyperlink{classha__ndbcluster_a55b76e2e6595d838981a54951aa3f002}{ha\+\_\+ndbcluster}}.

\mbox{\Hypertarget{classhandler_a2502e460566f2c4b506cc1b30eb79e0a}\label{classhandler_a2502e460566f2c4b506cc1b30eb79e0a}} 
\index{handler@{handler}!store\+\_\+lock@{store\+\_\+lock}}
\index{store\+\_\+lock@{store\+\_\+lock}!handler@{handler}}
\subsubsection{\texorpdfstring{store\+\_\+lock()}{store\_lock()}}
{\footnotesize\ttfamily virtual T\+H\+R\+\_\+\+L\+O\+C\+K\+\_\+\+D\+A\+TA$\ast$$\ast$ handler\+::store\+\_\+lock (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{T\+H\+R\+\_\+\+L\+O\+C\+K\+\_\+\+D\+A\+TA $\ast$$\ast$}]{to,  }\item[{enum thr\+\_\+lock\+\_\+type}]{lock\+\_\+type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Is not invoked for non-\/transactional temporary tables.

\begin{DoxyNote}{Note}
\mbox{\hyperlink{classhandler_a2502e460566f2c4b506cc1b30eb79e0a}{store\+\_\+lock()}} can return more than one lock if the table is M\+E\+R\+GE or partitioned.

that one can N\+OT rely on table-\/$>$in\+\_\+use in \mbox{\hyperlink{classhandler_a2502e460566f2c4b506cc1b30eb79e0a}{store\+\_\+lock()}}. It may refer to a different thread if called from \mbox{\hyperlink{group__Locking_gad2320fa808c9d6523790e796d57e2331}{mysql\+\_\+lock\+\_\+abort\+\_\+for\+\_\+thread()}}.

If the table is M\+E\+R\+GE, \mbox{\hyperlink{classhandler_a2502e460566f2c4b506cc1b30eb79e0a}{store\+\_\+lock()}} can return less locks than \mbox{\hyperlink{classhandler_a2447668275a831bcf73b5c00818254a6}{lock\+\_\+count()}} claimed. This can happen when the M\+E\+R\+GE children are not attached when this is called from another thread. 
\end{DoxyNote}


Implemented in \mbox{\hyperlink{classha__ndbcluster_a5bc14d2819ddbc2d616e11db49d669de}{ha\+\_\+ndbcluster}}, and \mbox{\hyperlink{classha__ndbinfo_a7169a09db353528ca14a979b01e56eb6}{ha\+\_\+ndbinfo}}.

\mbox{\Hypertarget{classhandler_ab4d7cf309121ec10e4150860c8caa12a}\label{classhandler_ab4d7cf309121ec10e4150860c8caa12a}} 
\index{handler@{handler}!table\+\_\+cache\+\_\+type@{table\+\_\+cache\+\_\+type}}
\index{table\+\_\+cache\+\_\+type@{table\+\_\+cache\+\_\+type}!handler@{handler}}
\subsubsection{\texorpdfstring{table\+\_\+cache\+\_\+type()}{table\_cache\_type()}}
{\footnotesize\ttfamily virtual uint8 handler\+::table\+\_\+cache\+\_\+type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Type of table for caching query 

Reimplemented in \mbox{\hyperlink{classha__ndbcluster_ac3a23eb89230938663a59fcf8fbe908b}{ha\+\_\+ndbcluster}}, and \mbox{\hyperlink{classha__ndbinfo_ab23949e133485226e2c90e78eb914b60}{ha\+\_\+ndbinfo}}.

\mbox{\Hypertarget{classhandler_a171927b3afde9e800755b834bd8d31bd}\label{classhandler_a171927b3afde9e800755b834bd8d31bd}} 
\index{handler@{handler}!table\+\_\+in\+\_\+memory\+\_\+estimate@{table\+\_\+in\+\_\+memory\+\_\+estimate}}
\index{table\+\_\+in\+\_\+memory\+\_\+estimate@{table\+\_\+in\+\_\+memory\+\_\+estimate}!handler@{handler}}
\subsubsection{\texorpdfstring{table\+\_\+in\+\_\+memory\+\_\+estimate()}{table\_in\_memory\_estimate()}}
{\footnotesize\ttfamily double handler\+::table\+\_\+in\+\_\+memory\+\_\+estimate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Return an estimate of how much of the table that is currently stored in main memory.

This estimate should be the fraction of the table that currently is available in a main memory buffer. The estimate should be in the range from 0.\+0 (nothing in memory) to 1.\+0 (entire table in memory).

\begin{DoxyReturn}{Returns}
The fraction of the table in main memory buffer 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_a5e9380355a7eea5386ef061f36479258}\label{classhandler_a5e9380355a7eea5386ef061f36479258}} 
\index{handler@{handler}!table\+\_\+scan\+\_\+cost@{table\+\_\+scan\+\_\+cost}}
\index{table\+\_\+scan\+\_\+cost@{table\+\_\+scan\+\_\+cost}!handler@{handler}}
\subsubsection{\texorpdfstring{table\+\_\+scan\+\_\+cost()}{table\_scan\_cost()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classCost__estimate}{Cost\+\_\+estimate}} handler\+::table\+\_\+scan\+\_\+cost (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Cost estimate for doing a complete table scan.

\begin{DoxyNote}{Note}
For this version it is recommended that storage engines continue to override \mbox{\hyperlink{classhandler_a65f8e5188e2bd9636a564bbc0c3fef86}{scan\+\_\+time()}} instead of this function.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
the estimated cost 
\end{DoxyReturn}
\mbox{\Hypertarget{classhandler_ad38f5d3f1e026a0af32b5542aa5ac2f9}\label{classhandler_ad38f5d3f1e026a0af32b5542aa5ac2f9}} 
\index{handler@{handler}!table\+\_\+type@{table\+\_\+type}}
\index{table\+\_\+type@{table\+\_\+type}!handler@{handler}}
\subsubsection{\texorpdfstring{table\+\_\+type()}{table\_type()}}
{\footnotesize\ttfamily virtual const char$\ast$ handler\+::table\+\_\+type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

The following can be called without an open handler 

Implemented in \mbox{\hyperlink{classha__ndbcluster_a96d160419836ac20e131570a32e1c4a8}{ha\+\_\+ndbcluster}}, and \mbox{\hyperlink{classha__ndbinfo_a4f8caa0e516e62ccce4a5f2a52590548}{ha\+\_\+ndbinfo}}.

\mbox{\Hypertarget{classhandler_a13fdf15d81c256d3e6a9643532ff2126}\label{classhandler_a13fdf15d81c256d3e6a9643532ff2126}} 
\index{handler@{handler}!truncate@{truncate}}
\index{truncate@{truncate}!handler@{handler}}
\subsubsection{\texorpdfstring{truncate()}{truncate()}}
{\footnotesize\ttfamily virtual int handler\+::truncate (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Quickly remove all rows from a table.

\begin{DoxyRemark}{Remarks}
This method is responsible for implementing My\+S\+QL\textquotesingle{}s T\+R\+U\+N\+C\+A\+TE \mbox{\hyperlink{structTABLE}{T\+A\+B\+LE}} statement, which is a D\+DL operation. As such, a engine can bypass certain integrity checks and in some cases avoid fine-\/grained locking (e.\+g. row locks) which would normally be required for a D\+E\+L\+E\+TE statement.

Typically, truncate is not used if it can result in integrity violation. For example, truncate is not used when a foreign key references the table, but it might be used if foreign key checks are disabled.

Engine is responsible for resetting the auto-\/increment counter.

The table is locked in exclusive mode. 
\end{DoxyRemark}
\mbox{\Hypertarget{classhandler_ab3e767094bff139a26743e9314df8476}\label{classhandler_ab3e767094bff139a26743e9314df8476}} 
\index{handler@{handler}!try\+\_\+semi\+\_\+consistent\+\_\+read@{try\+\_\+semi\+\_\+consistent\+\_\+read}}
\index{try\+\_\+semi\+\_\+consistent\+\_\+read@{try\+\_\+semi\+\_\+consistent\+\_\+read}!handler@{handler}}
\subsubsection{\texorpdfstring{try\+\_\+semi\+\_\+consistent\+\_\+read()}{try\_semi\_consistent\_read()}}
{\footnotesize\ttfamily virtual void handler\+::try\+\_\+semi\+\_\+consistent\+\_\+read (\begin{DoxyParamCaption}\item[{bool}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Tell the engine whether it should avoid unnecessary lock waits. If yes, in an U\+P\+D\+A\+TE or D\+E\+L\+E\+TE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. \mbox{\Hypertarget{classhandler_a8059bbed3de416b3bea51c69dc064e79}\label{classhandler_a8059bbed3de416b3bea51c69dc064e79}} 
\index{handler@{handler}!unlock\+\_\+shared\+\_\+ha\+\_\+data@{unlock\+\_\+shared\+\_\+ha\+\_\+data}}
\index{unlock\+\_\+shared\+\_\+ha\+\_\+data@{unlock\+\_\+shared\+\_\+ha\+\_\+data}!handler@{handler}}
\subsubsection{\texorpdfstring{unlock\+\_\+shared\+\_\+ha\+\_\+data()}{unlock\_shared\_ha\_data()}}
{\footnotesize\ttfamily void handler\+::unlock\+\_\+shared\+\_\+ha\+\_\+data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Release lock for protecting ha\+\_\+share. \mbox{\Hypertarget{classhandler_af07d741fb837dacdddc29c1d7e912204}\label{classhandler_af07d741fb837dacdddc29c1d7e912204}} 
\index{handler@{handler}!update\+\_\+field\+\_\+defs\+\_\+with\+\_\+zip\+\_\+dict\+\_\+info@{update\+\_\+field\+\_\+defs\+\_\+with\+\_\+zip\+\_\+dict\+\_\+info}}
\index{update\+\_\+field\+\_\+defs\+\_\+with\+\_\+zip\+\_\+dict\+\_\+info@{update\+\_\+field\+\_\+defs\+\_\+with\+\_\+zip\+\_\+dict\+\_\+info}!handler@{handler}}
\subsubsection{\texorpdfstring{update\+\_\+field\+\_\+defs\+\_\+with\+\_\+zip\+\_\+dict\+\_\+info()}{update\_field\_defs\_with\_zip\_dict\_info()}}
{\footnotesize\ttfamily virtual void handler\+::update\+\_\+field\+\_\+defs\+\_\+with\+\_\+zip\+\_\+dict\+\_\+info (\begin{DoxyParamCaption}\item[{T\+HD $\ast$}]{thd,  }\item[{const char $\ast$}]{part\+\_\+name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

This method is supposed to fill field definition objects with compression dictionary info (name and data). If the handler does not support compression dictionaries this method should be left empty (not overloaded).


\begin{DoxyParams}{Parameters}
{\em thd} & Thread handle \\
\hline
{\em part\+\_\+name} & Full table name (including partition part). Optional. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classhandler_adac21f2d10c4463fb1d7e14882c6314f}\label{classhandler_adac21f2d10c4463fb1d7e14882c6314f}} 
\index{handler@{handler}!use\+\_\+hidden\+\_\+primary\+\_\+key@{use\+\_\+hidden\+\_\+primary\+\_\+key}}
\index{use\+\_\+hidden\+\_\+primary\+\_\+key@{use\+\_\+hidden\+\_\+primary\+\_\+key}!handler@{handler}}
\subsubsection{\texorpdfstring{use\+\_\+hidden\+\_\+primary\+\_\+key()}{use\_hidden\_primary\_key()}}
{\footnotesize\ttfamily void handler\+::use\+\_\+hidden\+\_\+primary\+\_\+key (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



\mbox{\hyperlink{classhandler_adac21f2d10c4463fb1d7e14882c6314f}{use\+\_\+hidden\+\_\+primary\+\_\+key()}} is called in case of an update/delete when (table\+\_\+flags() and H\+A\+\_\+\+P\+R\+I\+M\+A\+R\+Y\+\_\+\+K\+E\+Y\+\_\+\+R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+F\+O\+R\+\_\+\+D\+E\+L\+E\+TE) is defined but we don\textquotesingle{}t have a primary key 

\mbox{\hyperlink{classhandler_adac21f2d10c4463fb1d7e14882c6314f}{use\+\_\+hidden\+\_\+primary\+\_\+key()}} is called in case of an update/delete when (table\+\_\+flags() and H\+A\+\_\+\+P\+R\+I\+M\+A\+R\+Y\+\_\+\+K\+E\+Y\+\_\+\+R\+E\+Q\+U\+I\+R\+E\+D\+\_\+\+F\+O\+R\+\_\+\+D\+E\+L\+E\+TE) is defined but we don\textquotesingle{}t have a primary key \mbox{\Hypertarget{classhandler_a54d92f647a4ca5a3b7867fa5538242a6}\label{classhandler_a54d92f647a4ca5a3b7867fa5538242a6}} 
\index{handler@{handler}!was\+\_\+semi\+\_\+consistent\+\_\+read@{was\+\_\+semi\+\_\+consistent\+\_\+read}}
\index{was\+\_\+semi\+\_\+consistent\+\_\+read@{was\+\_\+semi\+\_\+consistent\+\_\+read}!handler@{handler}}
\subsubsection{\texorpdfstring{was\+\_\+semi\+\_\+consistent\+\_\+read()}{was\_semi\_consistent\_read()}}
{\footnotesize\ttfamily virtual bool handler\+::was\+\_\+semi\+\_\+consistent\+\_\+read (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

In an U\+P\+D\+A\+TE or D\+E\+L\+E\+TE, if the row under the cursor was locked by another transaction, and the engine used an optimistic read of the last committed row value under the cursor, then the engine returns 1 from this function. My\+S\+QL must N\+OT try to update this optimistic value. If the optimistic value does not match the W\+H\+E\+RE condition, My\+S\+QL can decide to skip over this row. Currently only works for Inno\+DB. This can be used to avoid unnecessary lock waits.

If this method returns nonzero, it will also signal the storage engine that the next read will be a locking re-\/read of the row. 

\subsection{Member Data Documentation}
\mbox{\Hypertarget{classhandler_a1540a47a05c03724f1102aaaa623131e}\label{classhandler_a1540a47a05c03724f1102aaaa623131e}} 
\index{handler@{handler}!auto\+\_\+inc\+\_\+interval\+\_\+for\+\_\+cur\+\_\+row@{auto\+\_\+inc\+\_\+interval\+\_\+for\+\_\+cur\+\_\+row}}
\index{auto\+\_\+inc\+\_\+interval\+\_\+for\+\_\+cur\+\_\+row@{auto\+\_\+inc\+\_\+interval\+\_\+for\+\_\+cur\+\_\+row}!handler@{handler}}
\subsubsection{\texorpdfstring{auto\+\_\+inc\+\_\+interval\+\_\+for\+\_\+cur\+\_\+row}{auto\_inc\_interval\_for\_cur\_row}}
{\footnotesize\ttfamily \mbox{\hyperlink{classDiscrete__interval}{Discrete\+\_\+interval}} handler\+::auto\+\_\+inc\+\_\+interval\+\_\+for\+\_\+cur\+\_\+row}

\mbox{\hyperlink{structInterval}{Interval}} returned by \mbox{\hyperlink{classhandler_aaf6af760a4ef09984a5cc1dc58db9a40}{get\+\_\+auto\+\_\+increment()}} and being consumed by the inserter. \mbox{\Hypertarget{classhandler_acdfcef0738a89138c8f41ded8da17c0a}\label{classhandler_acdfcef0738a89138c8f41ded8da17c0a}} 
\index{handler@{handler}!auto\+\_\+inc\+\_\+intervals\+\_\+count@{auto\+\_\+inc\+\_\+intervals\+\_\+count}}
\index{auto\+\_\+inc\+\_\+intervals\+\_\+count@{auto\+\_\+inc\+\_\+intervals\+\_\+count}!handler@{handler}}
\subsubsection{\texorpdfstring{auto\+\_\+inc\+\_\+intervals\+\_\+count}{auto\_inc\_intervals\_count}}
{\footnotesize\ttfamily uint handler\+::auto\+\_\+inc\+\_\+intervals\+\_\+count}

Number of reserved auto-\/increment intervals. Serves as a heuristic when we have no estimation of how many records the statement will insert\+: the more intervals we have reserved, the bigger the next one. Reset in handler\+::ha\+\_\+release\+\_\+auto\+\_\+increment(). \mbox{\Hypertarget{classhandler_a05dd2cafd83ae60562649bf9688aebf1}\label{classhandler_a05dd2cafd83ae60562649bf9688aebf1}} 
\index{handler@{handler}!insert\+\_\+id\+\_\+for\+\_\+cur\+\_\+row@{insert\+\_\+id\+\_\+for\+\_\+cur\+\_\+row}}
\index{insert\+\_\+id\+\_\+for\+\_\+cur\+\_\+row@{insert\+\_\+id\+\_\+for\+\_\+cur\+\_\+row}!handler@{handler}}
\subsubsection{\texorpdfstring{insert\+\_\+id\+\_\+for\+\_\+cur\+\_\+row}{insert\_id\_for\_cur\_row}}
{\footnotesize\ttfamily ulonglong handler\+::insert\+\_\+id\+\_\+for\+\_\+cur\+\_\+row}

insert id for the current row ({\itshape autogenerated}; if not autogenerated, it\textquotesingle{}s 0). At first successful insertion, this variable is stored into T\+H\+D\+::first\+\_\+successful\+\_\+insert\+\_\+id\+\_\+in\+\_\+cur\+\_\+stmt. \mbox{\Hypertarget{classhandler_a881e7cba3fe3bf9731a91be82983cc35}\label{classhandler_a881e7cba3fe3bf9731a91be82983cc35}} 
\index{handler@{handler}!m\+\_\+psi@{m\+\_\+psi}}
\index{m\+\_\+psi@{m\+\_\+psi}!handler@{handler}}
\subsubsection{\texorpdfstring{m\+\_\+psi}{m\_psi}}
{\footnotesize\ttfamily P\+S\+I\+\_\+table$\ast$ handler\+::m\+\_\+psi}

Instrumented table associated with this handler. \mbox{\Hypertarget{classhandler_a62ab295e407d8a5c50087fed0f4fcd18}\label{classhandler_a62ab295e407d8a5c50087fed0f4fcd18}} 
\index{handler@{handler}!next\+\_\+insert\+\_\+id@{next\+\_\+insert\+\_\+id}}
\index{next\+\_\+insert\+\_\+id@{next\+\_\+insert\+\_\+id}!handler@{handler}}
\subsubsection{\texorpdfstring{next\+\_\+insert\+\_\+id}{next\_insert\_id}}
{\footnotesize\ttfamily ulonglong handler\+::next\+\_\+insert\+\_\+id}

next\+\_\+insert\+\_\+id is the next value which should be inserted into the auto\+\_\+increment column\+: in a inserting-\/multi-\/row statement (like I\+N\+S\+E\+RT S\+E\+L\+E\+CT), for the first row where the autoinc value is not specified by the statement, \mbox{\hyperlink{classhandler_aaf6af760a4ef09984a5cc1dc58db9a40}{get\+\_\+auto\+\_\+increment()}} called and asked to generate a value, next\+\_\+insert\+\_\+id is set to the next value, then for all other rows next\+\_\+insert\+\_\+id is used (and increased each time) without calling \mbox{\hyperlink{classhandler_aaf6af760a4ef09984a5cc1dc58db9a40}{get\+\_\+auto\+\_\+increment()}}. \mbox{\Hypertarget{classhandler_a64def328ff0ca7e391b217c2d3a758ec}\label{classhandler_a64def328ff0ca7e391b217c2d3a758ec}} 
\index{handler@{handler}!ref\+\_\+length@{ref\+\_\+length}}
\index{ref\+\_\+length@{ref\+\_\+length}!handler@{handler}}
\subsubsection{\texorpdfstring{ref\+\_\+length}{ref\_length}}
{\footnotesize\ttfamily uint handler\+::ref\+\_\+length}

Length of ref (1-\/8 or the clustered key length) 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
handler.\+h\item 
\mbox{\hyperlink{handler_8cc}{handler.\+cc}}\end{DoxyCompactItemize}
