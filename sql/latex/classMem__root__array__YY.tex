\hypertarget{classMem__root__array__YY}{}\section{Mem\+\_\+root\+\_\+array\+\_\+\+YY$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$ Class Template Reference}
\label{classMem__root__array__YY}\index{Mem\+\_\+root\+\_\+array\+\_\+\+Y\+Y$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$@{Mem\+\_\+root\+\_\+array\+\_\+\+Y\+Y$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$}}


{\ttfamily \#include $<$mem\+\_\+root\+\_\+array.\+h$>$}

Inheritance diagram for Mem\+\_\+root\+\_\+array\+\_\+\+YY$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=12.000000cm]{classMem__root__array__YY}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a7cd544d399ee0cf1ac196fbf0da8b3ff}\label{classMem__root__array__YY_a7cd544d399ee0cf1ac196fbf0da8b3ff}} 
typedef Element\+\_\+type \mbox{\hyperlink{classMem__root__array__YY_a7cd544d399ee0cf1ac196fbf0da8b3ff}{value\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Convenience typedef, same typedef name as std\+::vector. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classMem__root__array__YY_a567571c6fba9dc6615c0ec772743ee67}\label{classMem__root__array__YY_a567571c6fba9dc6615c0ec772743ee67}} 
typedef Element\+\_\+type $\ast$ \mbox{\hyperlink{classMem__root__array__YY_a567571c6fba9dc6615c0ec772743ee67}{iterator}}
\begin{DoxyCompactList}\small\item\em Random access iterators to value\+\_\+type and const value\+\_\+type. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classMem__root__array__YY_afa721a4338ab28f67c058b2a197b26ab}\label{classMem__root__array__YY_afa721a4338ab28f67c058b2a197b26ab}} 
typedef const Element\+\_\+type $\ast$ {\bfseries const\+\_\+iterator}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a091a12a12e419e167c71c0db29c0766e}\label{classMem__root__array__YY_a091a12a12e419e167c71c0db29c0766e}} 
void {\bfseries init} (M\+E\+M\+\_\+\+R\+O\+OT $\ast$root)
\item 
void \mbox{\hyperlink{classMem__root__array__YY_a777a34213998be27410cc67f086464a0}{set\+\_\+mem\+\_\+root}} (M\+E\+M\+\_\+\+R\+O\+OT $\ast$new\+\_\+root)
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a4ba9f5d62d0abde5b809709548df4b7e}\label{classMem__root__array__YY_a4ba9f5d62d0abde5b809709548df4b7e}} 
Element\+\_\+type \& {\bfseries at} (size\+\_\+t n)
\item 
\mbox{\Hypertarget{classMem__root__array__YY_abe407b66fd2a36e1cd4082457b7ae5d4}\label{classMem__root__array__YY_abe407b66fd2a36e1cd4082457b7ae5d4}} 
const Element\+\_\+type \& {\bfseries at} (size\+\_\+t n) const
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a29c01db114177e28bea860b7d6c7a655}\label{classMem__root__array__YY_a29c01db114177e28bea860b7d6c7a655}} 
Element\+\_\+type \& {\bfseries operator\mbox{[}$\,$\mbox{]}} (size\+\_\+t n)
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a04603198aefdd918ed18609a346d2f65}\label{classMem__root__array__YY_a04603198aefdd918ed18609a346d2f65}} 
const Element\+\_\+type \& {\bfseries operator\mbox{[}$\,$\mbox{]}} (size\+\_\+t n) const
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a9bf4a7198eab5865623c1ff06842b5ee}\label{classMem__root__array__YY_a9bf4a7198eab5865623c1ff06842b5ee}} 
Element\+\_\+type \& {\bfseries back} ()
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a7cc179f271fefb5d5638dea2cf1a96ff}\label{classMem__root__array__YY_a7cc179f271fefb5d5638dea2cf1a96ff}} 
const Element\+\_\+type \& {\bfseries back} () const
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a497b3e8d416fed699297a0c431f35214}\label{classMem__root__array__YY_a497b3e8d416fed699297a0c431f35214}} 
Element\+\_\+type $\ast$ \mbox{\hyperlink{classMem__root__array__YY_a497b3e8d416fed699297a0c431f35214}{begin}} ()
\begin{DoxyCompactList}\small\item\em Returns a pointer to the first element in the array. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classMem__root__array__YY_a867fe230010fddefa175438ae973e87e}\label{classMem__root__array__YY_a867fe230010fddefa175438ae973e87e}} 
const Element\+\_\+type $\ast$ {\bfseries begin} () const
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a87d1b244bc43cf49b75ee8f08e487752}\label{classMem__root__array__YY_a87d1b244bc43cf49b75ee8f08e487752}} 
Element\+\_\+type $\ast$ \mbox{\hyperlink{classMem__root__array__YY_a87d1b244bc43cf49b75ee8f08e487752}{end}} ()
\begin{DoxyCompactList}\small\item\em Returns a pointer to the past-\/the-\/end element in the array. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classMem__root__array__YY_a305bcad94918a119a3ba42c350f95cbe}\label{classMem__root__array__YY_a305bcad94918a119a3ba42c350f95cbe}} 
const Element\+\_\+type $\ast$ {\bfseries end} () const
\item 
\mbox{\Hypertarget{classMem__root__array__YY_ac2f2a0fd264d54ebfb44dd74bd6a8361}\label{classMem__root__array__YY_ac2f2a0fd264d54ebfb44dd74bd6a8361}} 
void \mbox{\hyperlink{classMem__root__array__YY_ac2f2a0fd264d54ebfb44dd74bd6a8361}{clear}} ()
\begin{DoxyCompactList}\small\item\em Erases all of the elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classMem__root__array__YY_ae8180a30bba47eaf409351f33c1b7f1b}{chop}} (const size\+\_\+t pos)
\item 
bool \mbox{\hyperlink{classMem__root__array__YY_ac1538b675c5ef3b9cbe67940b054cc2f}{reserve}} (size\+\_\+t n)
\item 
bool \mbox{\hyperlink{classMem__root__array__YY_ad179b3f709bb4b31d3fce461e93be3cf}{push\+\_\+back}} (const Element\+\_\+type \&element)
\item 
void \mbox{\hyperlink{classMem__root__array__YY_aa07dcb7f72b3b2bba7a46985505fed95}{pop\+\_\+back}} ()
\item 
void \mbox{\hyperlink{classMem__root__array__YY_aee9a24954393d15680f23e59e9eb5f45}{resize}} (size\+\_\+t n, const \mbox{\hyperlink{classMem__root__array__YY_a7cd544d399ee0cf1ac196fbf0da8b3ff}{value\+\_\+type}} \&val=\mbox{\hyperlink{classMem__root__array__YY_a7cd544d399ee0cf1ac196fbf0da8b3ff}{value\+\_\+type}}())
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a8dec5cb843baa4e450b115bec42b1d26}\label{classMem__root__array__YY_a8dec5cb843baa4e450b115bec42b1d26}} 
size\+\_\+t {\bfseries capacity} () const
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a56d5c552ddc158f1fbcef0cedccbbd8a}\label{classMem__root__array__YY_a56d5c552ddc158f1fbcef0cedccbbd8a}} 
size\+\_\+t {\bfseries element\+\_\+size} () const
\item 
\mbox{\Hypertarget{classMem__root__array__YY_a378ef1a93daff80be898717ddfc08c56}\label{classMem__root__array__YY_a378ef1a93daff80be898717ddfc08c56}} 
bool {\bfseries empty} () const
\item 
\mbox{\Hypertarget{classMem__root__array__YY_ac8db98f9eb5dfea2099ce6734bdb997f}\label{classMem__root__array__YY_ac8db98f9eb5dfea2099ce6734bdb997f}} 
size\+\_\+t {\bfseries size} () const
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename Element\+\_\+type, bool has\+\_\+trivial\+\_\+destructor = true$>$\newline
class Mem\+\_\+root\+\_\+array\+\_\+\+Y\+Y$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$}

A typesafe replacement for D\+Y\+N\+A\+M\+I\+C\+\_\+\+A\+R\+R\+AY. We use M\+E\+M\+\_\+\+R\+O\+OT for allocating storage, rather than the C++ heap. The interface is chosen to be similar to std\+::vector.

\begin{DoxyRemark}{Remarks}
Unlike D\+Y\+N\+A\+M\+I\+C\+\_\+\+A\+R\+R\+AY, elements are properly copied (rather than memcpy()d) if the underlying array needs to be expanded.

Depending on has\+\_\+trivial\+\_\+destructor, we destroy objects which are removed from the array (including when the array object itself is destroyed).

Note that M\+E\+M\+\_\+\+R\+O\+OT has no facility for reusing free space, so don\textquotesingle{}t use this if multiple re-\/expansions are likely to happen.
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em Element\+\_\+type} & The type of the elements of the container. Elements must be copyable. \\
\hline
{\em has\+\_\+trivial\+\_\+destructor} & If true, we don\textquotesingle{}t destroy elements. We could have used type traits to determine this. \+\_\+\+\_\+has\+\_\+trivial\+\_\+destructor is supported by some (but not all) compilers we use. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classMem__root__array__YY_ae8180a30bba47eaf409351f33c1b7f1b}\label{classMem__root__array__YY_ae8180a30bba47eaf409351f33c1b7f1b}} 
\index{Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}!chop@{chop}}
\index{chop@{chop}!Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}
\subsubsection{\texorpdfstring{chop()}{chop()}}
{\footnotesize\ttfamily template$<$typename Element\+\_\+type, bool has\+\_\+trivial\+\_\+destructor = true$>$ \\
void \mbox{\hyperlink{classMem__root__array__YY}{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$\+::chop (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{pos }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Chops the tail off the array, erasing all tail elements. 
\begin{DoxyParams}{Parameters}
{\em pos} & Index of first element to erase. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classMem__root__array__YY_aa07dcb7f72b3b2bba7a46985505fed95}\label{classMem__root__array__YY_aa07dcb7f72b3b2bba7a46985505fed95}} 
\index{Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}!pop\+\_\+back@{pop\+\_\+back}}
\index{pop\+\_\+back@{pop\+\_\+back}!Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}
\subsubsection{\texorpdfstring{pop\+\_\+back()}{pop\_back()}}
{\footnotesize\ttfamily template$<$typename Element\+\_\+type, bool has\+\_\+trivial\+\_\+destructor = true$>$ \\
void \mbox{\hyperlink{classMem__root__array__YY}{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$\+::pop\+\_\+back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Removes the last element in the array, effectively reducing the container size by one. This destroys the removed element. \mbox{\Hypertarget{classMem__root__array__YY_ad179b3f709bb4b31d3fce461e93be3cf}\label{classMem__root__array__YY_ad179b3f709bb4b31d3fce461e93be3cf}} 
\index{Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}!push\+\_\+back@{push\+\_\+back}}
\index{push\+\_\+back@{push\+\_\+back}!Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}
\subsubsection{\texorpdfstring{push\+\_\+back()}{push\_back()}}
{\footnotesize\ttfamily template$<$typename Element\+\_\+type, bool has\+\_\+trivial\+\_\+destructor = true$>$ \\
bool \mbox{\hyperlink{classMem__root__array__YY}{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{const Element\+\_\+type \&}]{element }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Adds a new element at the end of the array, after its current last element. The content of this new element is initialized to a copy of the input argument.


\begin{DoxyParams}{Parameters}
{\em element} & Object to copy. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & if out-\/of-\/memory, false otherwise. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classMem__root__array__YY_ac1538b675c5ef3b9cbe67940b054cc2f}\label{classMem__root__array__YY_ac1538b675c5ef3b9cbe67940b054cc2f}} 
\index{Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}!reserve@{reserve}}
\index{reserve@{reserve}!Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}
\subsubsection{\texorpdfstring{reserve()}{reserve()}}
{\footnotesize\ttfamily template$<$typename Element\+\_\+type, bool has\+\_\+trivial\+\_\+destructor = true$>$ \\
bool \mbox{\hyperlink{classMem__root__array__YY}{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$\+::reserve (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Reserves space for array elements. Copies over existing elements, in case we are re-\/expanding the array.


\begin{DoxyParams}{Parameters}
{\em n} & number of elements. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & if out-\/of-\/memory, false otherwise. \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{classMem__root__array__YY_aee9a24954393d15680f23e59e9eb5f45}\label{classMem__root__array__YY_aee9a24954393d15680f23e59e9eb5f45}} 
\index{Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}!resize@{resize}}
\index{resize@{resize}!Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}
\subsubsection{\texorpdfstring{resize()}{resize()}}
{\footnotesize\ttfamily template$<$typename Element\+\_\+type, bool has\+\_\+trivial\+\_\+destructor = true$>$ \\
void \mbox{\hyperlink{classMem__root__array__YY}{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$\+::resize (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n,  }\item[{const \mbox{\hyperlink{classMem__root__array__YY_a7cd544d399ee0cf1ac196fbf0da8b3ff}{value\+\_\+type}} \&}]{val = {\ttfamily \mbox{\hyperlink{classMem__root__array__YY_a7cd544d399ee0cf1ac196fbf0da8b3ff}{value\+\_\+type}}()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Resizes the container so that it contains n elements.

If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them).

If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-\/initialized.

If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place.

Notice that this function changes the actual content of the container by inserting or erasing elements from it. \mbox{\Hypertarget{classMem__root__array__YY_a777a34213998be27410cc67f086464a0}\label{classMem__root__array__YY_a777a34213998be27410cc67f086464a0}} 
\index{Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}!set\+\_\+mem\+\_\+root@{set\+\_\+mem\+\_\+root}}
\index{set\+\_\+mem\+\_\+root@{set\+\_\+mem\+\_\+root}!Mem\+\_\+root\+\_\+array\+\_\+\+YY@{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}
\subsubsection{\texorpdfstring{set\+\_\+mem\+\_\+root()}{set\_mem\_root()}}
{\footnotesize\ttfamily template$<$typename Element\+\_\+type, bool has\+\_\+trivial\+\_\+destructor = true$>$ \\
void \mbox{\hyperlink{classMem__root__array__YY}{Mem\+\_\+root\+\_\+array\+\_\+\+YY}}$<$ Element\+\_\+type, has\+\_\+trivial\+\_\+destructor $>$\+::set\+\_\+mem\+\_\+root (\begin{DoxyParamCaption}\item[{M\+E\+M\+\_\+\+R\+O\+OT $\ast$}]{new\+\_\+root }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Switches mem-\/root, in case original mem-\/root was copied. N\+O\+TE\+: m\+\_\+root should really be const, i.\+e. never change after initialization. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
mem\+\_\+root\+\_\+array.\+h\end{DoxyCompactItemize}
