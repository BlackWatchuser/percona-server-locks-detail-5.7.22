\hypertarget{merge__sort_8h}{}\section{merge\+\_\+sort.\+h File Reference}
\label{merge__sort_8h}\index{merge\+\_\+sort.\+h@{merge\+\_\+sort.\+h}}


Merge sort and insert sort implementations. These sorting functions are primarily intended for sorting of J\+O\+I\+N\+\_\+\+T\+A\+Bs before the greedy search algorithm is applied. Since the \mbox{\hyperlink{classJOIN__TAB}{J\+O\+I\+N\+\_\+\+T\+AB}} comparison functions (Join\+\_\+tab\+\_\+compare$\ast$) are not transitive, the resulting order depends on the sorting implementation to a certain degree.  


{\ttfamily \#include \char`\"{}sql\+\_\+select.\+h\char`\"{}}\newline
{\ttfamily \#include $<$queue$>$}\newline
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Element\+\_\+type , typename Comp\+\_\+func $>$ }\\void \mbox{\hyperlink{merge__sort_8h_a4e3225d67ee0d9a70a00c3db110d94f6}{insert\+\_\+sort}} (Element\+\_\+type $\ast$$\ast$first, Element\+\_\+type $\ast$$\ast$last, Comp\+\_\+func comp)
\item 
{\footnotesize template$<$typename Element\+\_\+type , typename Comp\+\_\+func $>$ }\\void \mbox{\hyperlink{merge__sort_8h_acd46fbb79b43b59d971f7470c5eca99e}{merge\+\_\+sort}} (Element\+\_\+type $\ast$$\ast$first, Element\+\_\+type $\ast$$\ast$last, Comp\+\_\+func comp)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Merge sort and insert sort implementations. These sorting functions are primarily intended for sorting of J\+O\+I\+N\+\_\+\+T\+A\+Bs before the greedy search algorithm is applied. Since the \mbox{\hyperlink{classJOIN__TAB}{J\+O\+I\+N\+\_\+\+T\+AB}} comparison functions (Join\+\_\+tab\+\_\+compare$\ast$) are not transitive, the resulting order depends on the sorting implementation to a certain degree. 

Since the std\+::stable\+\_\+sort and std\+::sort implementations differ between platforms, the result of sorting J\+O\+I\+N\+\_\+\+T\+A\+Bs may also differ. In turn, the query execution plan would differ between platforms and that is a problem with mtr tests (E\+X\+P\+L\+A\+IN output would vary).

If you intend to sort something transitive (which means almost everything except J\+O\+I\+N\+\_\+\+T\+A\+Bs) you should most likely use one of the std sorting functions instead of this. 

\subsection{Function Documentation}
\mbox{\Hypertarget{merge__sort_8h_a4e3225d67ee0d9a70a00c3db110d94f6}\label{merge__sort_8h_a4e3225d67ee0d9a70a00c3db110d94f6}} 
\index{merge\+\_\+sort.\+h@{merge\+\_\+sort.\+h}!insert\+\_\+sort@{insert\+\_\+sort}}
\index{insert\+\_\+sort@{insert\+\_\+sort}!merge\+\_\+sort.\+h@{merge\+\_\+sort.\+h}}
\subsubsection{\texorpdfstring{insert\+\_\+sort()}{insert\_sort()}}
{\footnotesize\ttfamily template$<$typename Element\+\_\+type , typename Comp\+\_\+func $>$ \\
void insert\+\_\+sort (\begin{DoxyParamCaption}\item[{Element\+\_\+type $\ast$$\ast$}]{first,  }\item[{Element\+\_\+type $\ast$$\ast$}]{last,  }\item[{Comp\+\_\+func}]{comp }\end{DoxyParamCaption})}

Sorts the elements in the range \mbox{[}first,last) into ascending order using insertion sort.


\begin{DoxyParams}{Parameters}
{\em first} & First element in an array of pointers to be sorted \\
\hline
{\em last} & Element after the last element in an array of pointers to be sorted \\
\hline
{\em comp} & Comparison function object that, taking two pointers of the same type as those contained in the range, returns true if the first argument goes before the second argument in the specific strict weak ordering it defines, and false otherwise.\\
\hline
\end{DoxyParams}
In our case comp should be a function object with an operator\+:

bool operator()(\+Element\+\_\+type$\ast$, Element\+\_\+type$\ast$) \mbox{\Hypertarget{merge__sort_8h_acd46fbb79b43b59d971f7470c5eca99e}\label{merge__sort_8h_acd46fbb79b43b59d971f7470c5eca99e}} 
\index{merge\+\_\+sort.\+h@{merge\+\_\+sort.\+h}!merge\+\_\+sort@{merge\+\_\+sort}}
\index{merge\+\_\+sort@{merge\+\_\+sort}!merge\+\_\+sort.\+h@{merge\+\_\+sort.\+h}}
\subsubsection{\texorpdfstring{merge\+\_\+sort()}{merge\_sort()}}
{\footnotesize\ttfamily template$<$typename Element\+\_\+type , typename Comp\+\_\+func $>$ \\
void merge\+\_\+sort (\begin{DoxyParamCaption}\item[{Element\+\_\+type $\ast$$\ast$}]{first,  }\item[{Element\+\_\+type $\ast$$\ast$}]{last,  }\item[{Comp\+\_\+func}]{comp }\end{DoxyParamCaption})}

Sorts the elements in the range \mbox{[}first,last) into ascending order using merge sort.


\begin{DoxyParams}{Parameters}
{\em first} & First element in an array of pointers to be sorted \\
\hline
{\em last} & Element after the last element in an array of pointers to be sorted \\
\hline
{\em comp} & Comparison function object that, taking two pointers of the same type as those contained in the range, returns true if the first argument goes before the second argument in the specific strict weak ordering it defines, and false otherwise.\\
\hline
\end{DoxyParams}
In our case comp should be a function object with an operator\+:

bool operator()(\+Element\+\_\+type$\ast$, Element\+\_\+type$\ast$) 