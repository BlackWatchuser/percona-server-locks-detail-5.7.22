When a table map is created, the master first calls Table\+\_\+map\+\_\+log\+\_\+event\+::save\+\_\+field\+\_\+metadata() which calculates how many values will be in the field metadata. Only those fields that require the extra data are added. The method also loops through all of the fields in the table calling the method Field\+::save\+\_\+field\+\_\+metadata() which returns the values for the field that will be saved in the metadata and replicated to the slave. Once all fields have been processed, the table map is written to the binlog adding the size of the field metadata and the field metadata to the end of the body of the table map.

When a table map is read on the slave, the field metadata is read from the table map and passed to the \mbox{\hyperlink{classtable__def}{table\+\_\+def}} class constructor which saves the field metadata from the table map into an array based on the type of the field. \mbox{\hyperlink{classField}{Field}} metadata values not present (those fields that do not use extra data) in the table map are initialized as zero (0). The array size is the same as the columns for the table on the slave.

Additionally, values saved for field metadata on the master are saved as a string of bytes (uchar) in the binlog. A field may require 1 or more bytes to store the information. In cases where values require multiple bytes (e.\+g. values $>$ 255), the endian-\/safe methods are used to properly encode the values on the master and decode them on the slave. When the field metadata values are captured on the slave, they are stored in an array of type uint16. This allows the least number of casts to prevent casting bugs when the field metadata is used in comparisons of field attributes. When the field metadata is used for calculating addresses in pointer math, the type used is uint32. 