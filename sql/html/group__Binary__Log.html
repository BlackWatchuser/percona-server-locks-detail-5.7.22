<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Binary Log</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Binary Log</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMutex__sentry.html">Mutex_sentry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThd__backup__and__restore.html">Thd_backup_and_restore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinlog__stmt__cache__data.html">binlog_stmt_cache_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinlog__trx__cache__data.html">binlog_trx_cache_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbinlog__cache__mngr.html">binlog_cache_mngr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5aab2d267393c9edd4b54a7c51f214b5"><td class="memItemLeft" align="right" valign="top"><a id="ga5aab2d267393c9edd4b54a7c51f214b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MY_OFF_T_UNDEF</b>&#160;&#160;&#160;(~(my_off_t)0UL)</td></tr>
<tr class="separator:ga5aab2d267393c9edd4b54a7c51f214b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c072f1c240a3925f70fe927aa4b303"><td class="memItemLeft" align="right" valign="top"><a id="gac8c072f1c240a3925f70fe927aa4b303"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LIMIT_UNSAFE_WARNING_ACTIVATION_TIMEOUT</b>&#160;&#160;&#160;50</td></tr>
<tr class="separator:gac8c072f1c240a3925f70fe927aa4b303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb15a4577c16ac29e9e49bbb91be40a"><td class="memItemLeft" align="right" valign="top"><a id="ga5eb15a4577c16ac29e9e49bbb91be40a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LIMIT_UNSAFE_WARNING_ACTIVATION_THRESHOLD_COUNT</b>&#160;&#160;&#160;50</td></tr>
<tr class="separator:ga5eb15a4577c16ac29e9e49bbb91be40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga731816acd3e6040814a1383f6eb2fbe9"><td class="memItemLeft" align="right" valign="top"><a id="ga731816acd3e6040814a1383f6eb2fbe9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SESSION_ATTACH_TRIES</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ga731816acd3e6040814a1383f6eb2fbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a60f647184471fabea338e908978317"><td class="memItemLeft" align="right" valign="top"><a id="ga1a60f647184471fabea338e908978317"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOG_WARN_UNIQUE_FN_EXT_LEFT</b>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:ga1a60f647184471fabea338e908978317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1e24693cd278a03ccca7bc269375ad16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga1e24693cd278a03ccca7bc269375ad16">enum_read_gtids_from_binlog_status</a> { <br />
&#160;&#160;<b>GOT_GTIDS</b>, 
<b>GOT_PREVIOUS_GTIDS</b>, 
<b>NO_GTIDS</b>, 
<b>ERROR</b>, 
<br />
&#160;&#160;<b>TRUNCATED</b>
<br />
 }</td></tr>
<tr class="separator:ga1e24693cd278a03ccca7bc269375ad16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga63c6fcd1b8e84116f7bcec46e7b25caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga63c6fcd1b8e84116f7bcec46e7b25caa">check_binlog_cache_size</a> (THD *thd)</td></tr>
<tr class="separator:ga63c6fcd1b8e84116f7bcec46e7b25caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0a12298d22d080b68e55f324cd59bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga7a0a12298d22d080b68e55f324cd59bd">check_binlog_stmt_cache_size</a> (THD *thd)</td></tr>
<tr class="separator:ga7a0a12298d22d080b68e55f324cd59bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46468c405fde69f126c1bcb343c85c90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga46468c405fde69f126c1bcb343c85c90">binlog_enabled</a> ()</td></tr>
<tr class="separator:ga46468c405fde69f126c1bcb343c85c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab41aafa88852810046fb7bcdaa4522ea"><td class="memItemLeft" align="right" valign="top"><a id="gab41aafa88852810046fb7bcdaa4522ea"></a>
enum xa_option_words&#160;</td><td class="memItemRight" valign="bottom"><b>get_xa_opt</b> (THD *thd)</td></tr>
<tr class="separator:gab41aafa88852810046fb7bcdaa4522ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5702b2bc03f66bc0a37c05ff1c84e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga0f5702b2bc03f66bc0a37c05ff1c84e8">is_loggable_xa_prepare</a> (THD *thd)</td></tr>
<tr class="separator:ga0f5702b2bc03f66bc0a37c05ff1c84e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b6d633ef75cd075586ba82ef3f5c9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga92b6d633ef75cd075586ba82ef3f5c9e">do_binlog_xa_commit_rollback</a> (THD *thd, <a class="el" href="structxid__t.html">XID</a> *xid, bool commit)</td></tr>
<tr class="separator:ga92b6d633ef75cd075586ba82ef3f5c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab499865e2616dac2a882d7937a62d2aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gab499865e2616dac2a882d7937a62d2aa">binlog_xa_commit_or_rollback</a> (THD *thd, <a class="el" href="structxid__t.html">XID</a> *xid, bool commit)</td></tr>
<tr class="separator:gab499865e2616dac2a882d7937a62d2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b696534d053643574f8ccf2bf5815f"><td class="memItemLeft" align="right" valign="top"><a id="ga24b696534d053643574f8ccf2bf5815f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_binlog_magic</b> (IO_CACHE *log, const char **errmsg)</td></tr>
<tr class="separator:ga24b696534d053643574f8ccf2bf5815f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79ed24f2c1a0645530426f4346470781"><td class="memItemLeft" align="right" valign="top">File&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga79ed24f2c1a0645530426f4346470781">open_binlog_file</a> (IO_CACHE *log, const char *log_file_name, const char **errmsg)</td></tr>
<tr class="separator:ga79ed24f2c1a0645530426f4346470781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47165cf06d3f64979787a85b6b43f3ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga47165cf06d3f64979787a85b6b43f3ac">is_empty_transaction_in_binlog_cache</a> (const THD *thd)</td></tr>
<tr class="separator:ga47165cf06d3f64979787a85b6b43f3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25239dc38f22eeef6e1aea243af6fd9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga25239dc38f22eeef6e1aea243af6fd9a">trans_has_updated_trans_table</a> (const THD *thd)</td></tr>
<tr class="separator:ga25239dc38f22eeef6e1aea243af6fd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43af0e4821421ea58375e7d4943c6c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaf43af0e4821421ea58375e7d4943c6c0">stmt_has_updated_trans_table</a> (<a class="el" href="classHa__trx__info.html">Ha_trx_info</a> *ha_list)</td></tr>
<tr class="separator:gaf43af0e4821421ea58375e7d4943c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad02774240e19d361a32bd35c9db60cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaad02774240e19d361a32bd35c9db60cb">ending_trans</a> (THD *thd, const bool all)</td></tr>
<tr class="separator:gaad02774240e19d361a32bd35c9db60cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a5419e22b84b8ca2f3595cbf75fa67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga80a5419e22b84b8ca2f3595cbf75fa67">ending_single_stmt_trans</a> (THD *thd, const bool all)</td></tr>
<tr class="separator:ga80a5419e22b84b8ca2f3595cbf75fa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d647f955254c565dc33abf8caabdbab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga1d647f955254c565dc33abf8caabdbab">trans_cannot_safely_rollback</a> (const THD *thd)</td></tr>
<tr class="separator:ga1d647f955254c565dc33abf8caabdbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a668f531f059316c8f17dfcecfd465"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga07a668f531f059316c8f17dfcecfd465">stmt_cannot_safely_rollback</a> (const THD *thd)</td></tr>
<tr class="separator:ga07a668f531f059316c8f17dfcecfd465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f15ff584adebd77fd1bf4ebc88a68b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga1f15ff584adebd77fd1bf4ebc88a68b6">purge_master_logs</a> (THD *thd, const char *to_log)</td></tr>
<tr class="separator:ga1f15ff584adebd77fd1bf4ebc88a68b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f8e56905c5205bb8cf6268cd203cb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga38f8e56905c5205bb8cf6268cd203cb2">purge_master_logs_before_date</a> (THD *thd, time_t purge_time)</td></tr>
<tr class="separator:ga38f8e56905c5205bb8cf6268cd203cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ae6bafee492a4342e739018cfb6701"><td class="memItemLeft" align="right" valign="top"><a id="ga30ae6bafee492a4342e739018cfb6701"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>query_error_code</b> (THD *thd, bool not_killed)</td></tr>
<tr class="separator:ga30ae6bafee492a4342e739018cfb6701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa811388f8ef0ea459d4adc40b65ff68e"><td class="memItemLeft" align="right" valign="top"><a id="gaa811388f8ef0ea459d4adc40b65ff68e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>generate_new_log_name</b> (char *new_name, ulong *new_ext, const char *log_name, bool is_binlog)</td></tr>
<tr class="separator:gaa811388f8ef0ea459d4adc40b65ff68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53bb73d56883af0d06d664f19407eac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga53bb73d56883af0d06d664f19407eac1">register_binlog_handler</a> (THD *thd, bool trx)</td></tr>
<tr class="separator:ga53bb73d56883af0d06d664f19407eac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3295f355d2560a45872262e211b0d83c"><td class="memItemLeft" align="right" valign="top"><a id="ga3295f355d2560a45872262e211b0d83c"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>get_locked_tables_mode_name</b> (enum_locked_tables_mode locked_tables_mode)</td></tr>
<tr class="separator:ga3295f355d2560a45872262e211b0d83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f038ff4067e3f5be2b4dacc1e50ac72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga9f038ff4067e3f5be2b4dacc1e50ac72">handle_gtid_consistency_violation</a> (THD *thd, int error_code)</td></tr>
<tr class="separator:ga9f038ff4067e3f5be2b4dacc1e50ac72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af09c853f5dcd42347e8343a0ccbc2b"><td class="memItemLeft" align="right" valign="top"><a id="ga5af09c853f5dcd42347e8343a0ccbc2b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_stmt_cache_data::finalize</b> (THD *thd)</td></tr>
<tr class="separator:ga5af09c853f5dcd42347e8343a0ccbc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a0b36dc3c576520f72b80298791400"><td class="memItemLeft" align="right" valign="top"><a id="gac3a0b36dc3c576520f72b80298791400"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_cache_data::write_event</b> (THD *thd, <a class="el" href="classLog__event.html">Log_event</a> *event)</td></tr>
<tr class="separator:gac3a0b36dc3c576520f72b80298791400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacface590afa692fc84446cde6f104231"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gacface590afa692fc84446cde6f104231">MYSQL_BIN_LOG::assign_automatic_gtids_to_flush_group</a> (THD *first_seen)</td></tr>
<tr class="separator:gacface590afa692fc84446cde6f104231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6da7d051531ecf891a1fe631697f38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gabc6da7d051531ecf891a1fe631697f38">MYSQL_BIN_LOG::write_gtid</a> (THD *thd, <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *cache_data, class <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> *writer)</td></tr>
<tr class="separator:gabc6da7d051531ecf891a1fe631697f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7e658ba27b48710cf57e3f8a8253e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga4e7e658ba27b48710cf57e3f8a8253e4">MYSQL_BIN_LOG::gtid_end_transaction</a> (THD *thd)</td></tr>
<tr class="separator:ga4e7e658ba27b48710cf57e3f8a8253e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3367fa8c1daced18065f6b9dea5385fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga3367fa8c1daced18065f6b9dea5385fe">binlog_cache_data::finalize</a> (THD *thd, <a class="el" href="classLog__event.html">Log_event</a> *end_event)</td></tr>
<tr class="separator:ga3367fa8c1daced18065f6b9dea5385fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16bd8b16b092443137c073f18c7e11e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga16bd8b16b092443137c073f18c7e11e4">binlog_cache_data::finalize</a> (THD *thd, <a class="el" href="classLog__event.html">Log_event</a> *end_event, <a class="el" href="classXID__STATE.html">XID_STATE</a> *xs)</td></tr>
<tr class="separator:ga16bd8b16b092443137c073f18c7e11e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga302d2ea7bfcbea015c329edacdac6c5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga302d2ea7bfcbea015c329edacdac6c5a">binlog_cache_data::flush</a> (THD *thd, my_off_t *bytes, bool *wrote_xid)</td></tr>
<tr class="separator:ga302d2ea7bfcbea015c329edacdac6c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d03425fee2a702a9b4dfac7b9de4b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gae0d03425fee2a702a9b4dfac7b9de4b1">binlog_trx_cache_data::truncate</a> (THD *thd, bool all)</td></tr>
<tr class="separator:gae0d03425fee2a702a9b4dfac7b9de4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a543666e684f08da1cc093d5fa70ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga20a543666e684f08da1cc093d5fa70ec">Stage_manager::Mutex_queue::append</a> (THD *first)</td></tr>
<tr class="separator:ga20a543666e684f08da1cc093d5fa70ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac617a778e2de5141ba0d25ca33ccac78"><td class="memItemLeft" align="right" valign="top"><a id="gac617a778e2de5141ba0d25ca33ccac78"></a>
std::pair&lt; bool, THD * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Stage_manager::Mutex_queue::pop_front</b> ()</td></tr>
<tr class="separator:gac617a778e2de5141ba0d25ca33ccac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a83004e5774879856189f84d00094f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga71a83004e5774879856189f84d00094f">Stage_manager::enroll_for</a> (<a class="el" href="classStage__manager.html#a28879837525f3786d4bcb6f330f4ac69">StageID</a> stage, THD *first, mysql_mutex_t *stage_mutex)</td></tr>
<tr class="separator:ga71a83004e5774879856189f84d00094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254675ae9d8f6f0a7b48d7520ab16eea"><td class="memItemLeft" align="right" valign="top">THD *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga254675ae9d8f6f0a7b48d7520ab16eea">Stage_manager::Mutex_queue::fetch_and_empty</a> ()</td></tr>
<tr class="separator:ga254675ae9d8f6f0a7b48d7520ab16eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85432b55b5d1d84283e83c4399ad524"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaa85432b55b5d1d84283e83c4399ad524">Stage_manager::wait_count_or_timeout</a> (ulong count, ulong usec, <a class="el" href="classStage__manager.html#a28879837525f3786d4bcb6f330f4ac69">StageID</a> stage)</td></tr>
<tr class="separator:gaa85432b55b5d1d84283e83c4399ad524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad5d70cddeb0156c9b3cea377466858"><td class="memItemLeft" align="right" valign="top"><a id="ga8ad5d70cddeb0156c9b3cea377466858"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Stage_manager::signal_done</b> (THD *queue)</td></tr>
<tr class="separator:ga8ad5d70cddeb0156c9b3cea377466858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3389586ace2de50ee7606d7acc98849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gad3389586ace2de50ee7606d7acc98849">Stage_manager::clear_preempt_status</a> (THD *head)</td></tr>
<tr class="separator:gad3389586ace2de50ee7606d7acc98849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9590d29210bd03fce1b8f9effc7c2d2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga9590d29210bd03fce1b8f9effc7c2d2a">MYSQL_BIN_LOG::rollback</a> (THD *thd, bool all)</td></tr>
<tr class="separator:ga9590d29210bd03fce1b8f9effc7c2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527779639a0c96124be599b029657813"><td class="memItemLeft" align="right" valign="top"><a id="ga527779639a0c96124be599b029657813"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::MYSQL_BIN_LOG</b> (uint *sync_period, enum cache_type io_cache_type_arg)</td></tr>
<tr class="separator:ga527779639a0c96124be599b029657813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8c70fe2db7fc6a5ffba006997e9064"><td class="memItemLeft" align="right" valign="top"><a id="ga2d8c70fe2db7fc6a5ffba006997e9064"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::cleanup</b> ()</td></tr>
<tr class="separator:ga2d8c70fe2db7fc6a5ffba006997e9064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e419bec25df519f933787e11e0050e"><td class="memItemLeft" align="right" valign="top"><a id="ga38e419bec25df519f933787e11e0050e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::init_pthread_objects</b> ()</td></tr>
<tr class="separator:ga38e419bec25df519f933787e11e0050e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd5b380680e537bdec0f093a8f2e3d6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gabcd5b380680e537bdec0f093a8f2e3d6">MYSQL_BIN_LOG::generate_name</a> (const char *log_name, const char *suffix, char *buff)</td></tr>
<tr class="separator:gabcd5b380680e537bdec0f093a8f2e3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc6f71042007e6a8cf40b5b4a95d562b"><td class="memItemLeft" align="right" valign="top"><a id="gacc6f71042007e6a8cf40b5b4a95d562b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::open_index_file</b> (const char *index_file_name_arg, const char *log_name, bool need_lock_index)</td></tr>
<tr class="separator:gacc6f71042007e6a8cf40b5b4a95d562b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8925923df0bf9cd07f7fcaf45f8db16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gab8925923df0bf9cd07f7fcaf45f8db16">MYSQL_BIN_LOG::find_first_log_not_in_gtid_set</a> (char *binlog_file_name, const <a class="el" href="classGtid__set.html">Gtid_set</a> *gtid_set, <a class="el" href="structGtid.html">Gtid</a> *first_gtid, const char **errmsg)</td></tr>
<tr class="separator:gab8925923df0bf9cd07f7fcaf45f8db16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52138e0e18c6bca2812e4051164db4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gab52138e0e18c6bca2812e4051164db4f">MYSQL_BIN_LOG::init_gtid_sets</a> (<a class="el" href="classGtid__set.html">Gtid_set</a> *gtid_set, <a class="el" href="classGtid__set.html">Gtid_set</a> *lost_groups, bool verify_checksum, bool need_lock, <a class="el" href="classTransaction__boundary__parser.html">Transaction_boundary_parser</a> *trx_parser, <a class="el" href="structGtid.html">Gtid</a> *gtid_partial_trx, bool is_server_starting=false)</td></tr>
<tr class="separator:gab52138e0e18c6bca2812e4051164db4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8614d8fb3c4c2c255145d6cfd992e8d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga8614d8fb3c4c2c255145d6cfd992e8d8">MYSQL_BIN_LOG::open_binlog</a> (const char *log_name, const char *new_name, ulong max_size, bool null_created, bool need_lock_index, bool need_sid_lock, <a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> *extra_description_event)</td></tr>
<tr class="separator:ga8614d8fb3c4c2c255145d6cfd992e8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57cd148796a62181465bb25db0e236c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gab57cd148796a62181465bb25db0e236c">MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file</a> (bool need_lock_index)</td></tr>
<tr class="separator:gab57cd148796a62181465bb25db0e236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc5340a448c8179ab35b3f2e0891984"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaddc5340a448c8179ab35b3f2e0891984">MYSQL_BIN_LOG::add_log_to_index</a> (uchar *log_file_name, size_t name_len, bool need_lock_index)</td></tr>
<tr class="separator:gaddc5340a448c8179ab35b3f2e0891984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa05a10f5039b9a66e92e057c8c632dff"><td class="memItemLeft" align="right" valign="top"><a id="gaa05a10f5039b9a66e92e057c8c632dff"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::get_current_log</b> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo, bool need_lock_log=true)</td></tr>
<tr class="separator:gaa05a10f5039b9a66e92e057c8c632dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826bbc38d9566f349fbf9e4cb6c682bc"><td class="memItemLeft" align="right" valign="top"><a id="ga826bbc38d9566f349fbf9e4cb6c682bc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::raw_get_current_log</b> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo)</td></tr>
<tr class="separator:ga826bbc38d9566f349fbf9e4cb6c682bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e22d76ff3054cc3f3b07882ff01fc4"><td class="memItemLeft" align="right" valign="top"><a id="ga55e22d76ff3054cc3f3b07882ff01fc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::check_write_error</b> (THD *thd)</td></tr>
<tr class="separator:ga55e22d76ff3054cc3f3b07882ff01fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc5fc9619717b2ab90bdbd5197ea774d"><td class="memItemLeft" align="right" valign="top"><a id="gabc5fc9619717b2ab90bdbd5197ea774d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::set_write_error</b> (THD *thd, bool is_transactional)</td></tr>
<tr class="separator:gabc5fc9619717b2ab90bdbd5197ea774d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245bb1e482896f726e11719666f2394a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga245bb1e482896f726e11719666f2394a">MYSQL_BIN_LOG::find_log_pos</a> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo, const char *log_name, bool need_lock_index)</td></tr>
<tr class="separator:ga245bb1e482896f726e11719666f2394a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed66e95398bcafa143ca8ad16860711"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga8ed66e95398bcafa143ca8ad16860711">MYSQL_BIN_LOG::find_next_log</a> (<a class="el" href="structst__log__info.html">LOG_INFO</a> *linfo, bool need_lock_index)</td></tr>
<tr class="separator:ga8ed66e95398bcafa143ca8ad16860711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a173d873dfe12dee3963402b0a2075e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga7a173d873dfe12dee3963402b0a2075e">MYSQL_BIN_LOG::find_next_relay_log</a> (char log_name[FN_REFLEN+1])</td></tr>
<tr class="separator:ga7a173d873dfe12dee3963402b0a2075e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7f92132aa396f9d9aa44701800334be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaa7f92132aa396f9d9aa44701800334be">MYSQL_BIN_LOG::reset_logs</a> (THD *thd, bool delete_only=false)</td></tr>
<tr class="separator:gaa7f92132aa396f9d9aa44701800334be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbd66f9464d9a83f33fdcdba20d7d99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga5bbd66f9464d9a83f33fdcdba20d7d99">MYSQL_BIN_LOG::set_crash_safe_index_file_name</a> (const char *base_file_name)</td></tr>
<tr class="separator:ga5bbd66f9464d9a83f33fdcdba20d7d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d69e1ee6b9099429bd919af752a0eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gac6d69e1ee6b9099429bd919af752a0eb">MYSQL_BIN_LOG::open_crash_safe_index_file</a> ()</td></tr>
<tr class="separator:gac6d69e1ee6b9099429bd919af752a0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5cf0683506dfdcc484155c676786860"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gad5cf0683506dfdcc484155c676786860">MYSQL_BIN_LOG::close_crash_safe_index_file</a> ()</td></tr>
<tr class="separator:gad5cf0683506dfdcc484155c676786860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94f694096c1ef28962d9d7936d2d9a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga94f694096c1ef28962d9d7936d2d9a1e">MYSQL_BIN_LOG::make_log_name</a> (char *buf, const char *log_ident)</td></tr>
<tr class="separator:ga94f694096c1ef28962d9d7936d2d9a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac641bdabee70ba4bd377e06e1853fcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaac641bdabee70ba4bd377e06e1853fcb">MYSQL_BIN_LOG::is_active</a> (const char *log_file_name)</td></tr>
<tr class="separator:gaac641bdabee70ba4bd377e06e1853fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae455eec3547a9c58913acad74c946c60"><td class="memItemLeft" align="right" valign="top"><a id="gae455eec3547a9c58913acad74c946c60"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::new_file</b> (<a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> *extra_description_event)</td></tr>
<tr class="separator:gae455eec3547a9c58913acad74c946c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40c4dc6b0b8986a50661b28df3a6fa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gae40c4dc6b0b8986a50661b28df3a6fa3">MYSQL_BIN_LOG::flush_and_sync</a> (const bool force=false)</td></tr>
<tr class="separator:gae40c4dc6b0b8986a50661b28df3a6fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7408e146d23b953fd8e41d58a73119f"><td class="memItemLeft" align="right" valign="top"><a id="gac7408e146d23b953fd8e41d58a73119f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::start_union_events</b> (THD *thd, query_id_t query_id_param)</td></tr>
<tr class="separator:gac7408e146d23b953fd8e41d58a73119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4819bc9642741f8775c71225234095"><td class="memItemLeft" align="right" valign="top"><a id="gaec4819bc9642741f8775c71225234095"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::stop_union_events</b> (THD *thd)</td></tr>
<tr class="separator:gaec4819bc9642741f8775c71225234095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b1915a748ef2b92e65ba67dd7b9371"><td class="memItemLeft" align="right" valign="top"><a id="gaa2b1915a748ef2b92e65ba67dd7b9371"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::is_query_in_union</b> (THD *thd, query_id_t query_id_param)</td></tr>
<tr class="separator:gaa2b1915a748ef2b92e65ba67dd7b9371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e45fa3b5e152adacb9f9899f983b2a"><td class="memItemLeft" align="right" valign="top"><a id="ga21e45fa3b5e152adacb9f9899f983b2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::update_thd_next_event_pos</b> (THD *thd)</td></tr>
<tr class="separator:ga21e45fa3b5e152adacb9f9899f983b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7c8c2cc805e99d685a0d99275d72d8"><td class="memItemLeft" align="right" valign="top"><a id="ga7d7c8c2cc805e99d685a0d99275d72d8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::flush_and_set_pending_rows_event</b> (THD *thd, <a class="el" href="classRows__log__event.html">Rows_log_event</a> *event, bool is_transactional)</td></tr>
<tr class="separator:ga7d7c8c2cc805e99d685a0d99275d72d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c19cd666a1a517386dedd4078dd93e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga9c19cd666a1a517386dedd4078dd93e7">MYSQL_BIN_LOG::write_event</a> (<a class="el" href="classLog__event.html">Log_event</a> *event_info)</td></tr>
<tr class="separator:ga9c19cd666a1a517386dedd4078dd93e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2053b0b53a46eb5702b44966497c333f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga2053b0b53a46eb5702b44966497c333f">MYSQL_BIN_LOG::rotate</a> (bool force_rotate, bool *check_purge)</td></tr>
<tr class="separator:ga2053b0b53a46eb5702b44966497c333f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff1889360685bd90b1d3ffba10ba3dba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaff1889360685bd90b1d3ffba10ba3dba">MYSQL_BIN_LOG::purge</a> ()</td></tr>
<tr class="separator:gaff1889360685bd90b1d3ffba10ba3dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f41b228c438fe7b4c710b8fdd780cfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga9f41b228c438fe7b4c710b8fdd780cfb">MYSQL_BIN_LOG::rotate_and_purge</a> (THD *thd, bool force_rotate)</td></tr>
<tr class="separator:ga9f41b228c438fe7b4c710b8fdd780cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d77f5e99ad74fbd1122a9dbc3ae34e4"><td class="memItemLeft" align="right" valign="top"><a id="ga2d77f5e99ad74fbd1122a9dbc3ae34e4"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::next_file_id</b> ()</td></tr>
<tr class="separator:ga2d77f5e99ad74fbd1122a9dbc3ae34e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d92fa178d27467ce506c759c5d82959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga8d92fa178d27467ce506c759c5d82959">MYSQL_BIN_LOG::get_gtid_executed</a> (<a class="el" href="classSid__map.html">Sid_map</a> *sid_map, <a class="el" href="classGtid__set.html">Gtid_set</a> *gtid_set)</td></tr>
<tr class="separator:ga8d92fa178d27467ce506c759c5d82959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81ca29b12d9e21eb2d36eee2e7a51fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaf81ca29b12d9e21eb2d36eee2e7a51fe">MYSQL_BIN_LOG::do_write_cache</a> (IO_CACHE *cache, class <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> *writer)</td></tr>
<tr class="separator:gaf81ca29b12d9e21eb2d36eee2e7a51fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3d159f584e6c57aed2e5af51db49fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaed3d159f584e6c57aed2e5af51db49fb">MYSQL_BIN_LOG::write_incident</a> (<a class="el" href="classIncident__log__event.html">Incident_log_event</a> *ev, THD *thd, bool need_lock_log, const char *err_msg, bool do_flush_and_sync=true)</td></tr>
<tr class="separator:gaed3d159f584e6c57aed2e5af51db49fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b5241d2e64863a3de611e7b5eb95fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga32b5241d2e64863a3de611e7b5eb95fd">MYSQL_BIN_LOG::write_dml_directly</a> (THD *thd, const char *stmt, size_t stmt_len)</td></tr>
<tr class="separator:ga32b5241d2e64863a3de611e7b5eb95fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceb6fa03fdf46ada9510567752878a53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaceb6fa03fdf46ada9510567752878a53">MYSQL_BIN_LOG::write_incident</a> (THD *thd, bool need_lock_log, const char *err_msg, bool do_flush_and_sync=true)</td></tr>
<tr class="separator:gaceb6fa03fdf46ada9510567752878a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d497917a9a65893753ff92be180172"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gab0d497917a9a65893753ff92be180172">MYSQL_BIN_LOG::write_cache</a> (THD *thd, class <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *<a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a>, class <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> *writer)</td></tr>
<tr class="separator:gab0d497917a9a65893753ff92be180172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10698ebc9afd7be839f7a69b7aaac141"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga10698ebc9afd7be839f7a69b7aaac141">MYSQL_BIN_LOG::wait_for_update_relay_log</a> (THD *thd, const struct timespec *timeout)</td></tr>
<tr class="separator:ga10698ebc9afd7be839f7a69b7aaac141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b625b440aaf82241200b3980d94c6a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga1b625b440aaf82241200b3980d94c6a9">MYSQL_BIN_LOG::wait_for_update_bin_log</a> (THD *thd, const struct timespec *timeout)</td></tr>
<tr class="separator:ga1b625b440aaf82241200b3980d94c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d6d79c98b0c8187b2761b959e67c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaf6d6d79c98b0c8187b2761b959e67c3f">MYSQL_BIN_LOG::close</a> (uint exiting, bool need_lock_log, bool need_lock_index)</td></tr>
<tr class="separator:gaf6d6d79c98b0c8187b2761b959e67c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1668661349520d23557e796db4a0b423"><td class="memItemLeft" align="right" valign="top"><a id="ga1668661349520d23557e796db4a0b423"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQL_BIN_LOG::set_max_size</b> (ulong max_size_arg)</td></tr>
<tr class="separator:ga1668661349520d23557e796db4a0b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44de4e3109fc4d50d4968191ab0f3544"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga44de4e3109fc4d50d4968191ab0f3544">MYSQL_BIN_LOG::open_binlog</a> (const char *opt_name)</td></tr>
<tr class="separator:ga44de4e3109fc4d50d4968191ab0f3544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e829bf97dfac49c3b05a2cbdbaf7cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga22e829bf97dfac49c3b05a2cbdbaf7cb">MYSQL_BIN_LOG::close</a> ()</td></tr>
<tr class="separator:ga22e829bf97dfac49c3b05a2cbdbaf7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4789039161947fff76fa8250b120b7e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga4789039161947fff76fa8250b120b7e3">MYSQL_BIN_LOG::prepare</a> (THD *thd, bool all)</td></tr>
<tr class="separator:ga4789039161947fff76fa8250b120b7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fdcfcfb5d2c85ca2a114ad2115b20e"><td class="memItemLeft" align="right" valign="top">enum_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga94fdcfcfb5d2c85ca2a114ad2115b20e">MYSQL_BIN_LOG::commit</a> (THD *thd, bool all)</td></tr>
<tr class="separator:ga94fdcfcfb5d2c85ca2a114ad2115b20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e843aafa062a4ab987d5ff75d450c41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga0e843aafa062a4ab987d5ff75d450c41">MYSQL_BIN_LOG::recover</a> (IO_CACHE *log, <a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> *fdle, my_off_t *valid_pos)</td></tr>
<tr class="separator:ga0e843aafa062a4ab987d5ff75d450c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebea3ac42b19b6e1c86ca33c3cb28e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#ga5ebea3ac42b19b6e1c86ca33c3cb28e7">MYSQL_BIN_LOG::xlock</a> (void)</td></tr>
<tr class="separator:ga5ebea3ac42b19b6e1c86ca33c3cb28e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee260f3856d7b1e557b91b7ecdc0b01c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Binary__Log.html#gaee260f3856d7b1e557b91b7ecdc0b01c">MYSQL_BIN_LOG::xunlock</a> (void)</td></tr>
<tr class="separator:gaee260f3856d7b1e557b91b7ecdc0b01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac5449116d5d93490b34525853da65eac"><td class="memItemLeft" align="right" valign="top"><a id="gac5449116d5d93490b34525853da65eac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>opt_binlog_order_commits</b> = true</td></tr>
<tr class="separator:gac5449116d5d93490b34525853da65eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d28cf3c8664bf92f1fbe1d8ba04ef0"><td class="memItemLeft" align="right" valign="top"><a id="ga41d28cf3c8664bf92f1fbe1d8ba04ef0"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>log_bin_index</b> = 0</td></tr>
<tr class="separator:ga41d28cf3c8664bf92f1fbe1d8ba04ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dbf1a49cfaae776fd9052568c40a6ba"><td class="memItemLeft" align="right" valign="top"><a id="ga5dbf1a49cfaae776fd9052568c40a6ba"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>log_bin_basename</b> = 0</td></tr>
<tr class="separator:ga5dbf1a49cfaae776fd9052568c40a6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e016d5a4032854dc75a4feeb3b7a91"><td class="memItemLeft" align="right" valign="top"><a id="ga70e016d5a4032854dc75a4feeb3b7a91"></a>
<a class="el" href="classMYSQL__BIN__LOG.html">MYSQL_BIN_LOG</a> mysql_bin_log &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>sync_binlog_period</b></td></tr>
<tr class="separator:ga70e016d5a4032854dc75a4feeb3b7a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ecc9c0253b423bc48289c779e9c010"><td class="memItemLeft" align="right" valign="top">struct st_mysql_storage_engine&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_storage_engine</b></td></tr>
<tr class="separator:gaf6ecc9c0253b423bc48289c779e9c010"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1e24693cd278a03ccca7bc269375ad16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e24693cd278a03ccca7bc269375ad16">&#9670;&nbsp;</a></span>enum_read_gtids_from_binlog_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Binary__Log.html#ga1e24693cd278a03ccca7bc269375ad16">enum_read_gtids_from_binlog_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reads GTIDs from the given binlog file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File to read from. </td></tr>
    <tr><td class="paramname">all_gtids</td><td>If not NULL, then the GTIDs from the <a class="el" href="classPrevious__gtids__log__event.html">Previous_gtids_log_event</a> and from all Gtid_log_events are stored in this object. </td></tr>
    <tr><td class="paramname">prev_gtids</td><td>If not NULL, then the GTIDs from the Previous_gtids_log_events are stored in this object. </td></tr>
    <tr><td class="paramname">first_gtid</td><td>If not NULL, then the first GTID information from the file will be stored in this object. </td></tr>
    <tr><td class="paramname">sid_map</td><td>The sid_map object to use in the rpl_sidno generation of the <a class="el" href="classGtid__log__event.html">Gtid_log_event</a>. If lock is needed in the sid_map, the caller must hold it. </td></tr>
    <tr><td class="paramname">verify_checksum</td><td>Set to true to verify event checksums.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">GOT_GTIDS</td><td>The file was successfully read and it contains both Gtid_log_events and Previous_gtids_log_events. This is only possible if either all_gtids or first_gtid are not null. </td></tr>
    <tr><td class="paramname">GOT_PREVIOUS_GTIDS</td><td>The file was successfully read and it contains Previous_gtids_log_events but no Gtid_log_events. For binary logs, if no all_gtids and no first_gtid are specified, this function will be done right after reading the PREVIOUS_GTIDS regardless of the rest of the content of the binary log file. </td></tr>
    <tr><td class="paramname">NO_GTIDS</td><td>The file was successfully read and it does not contain GTID events. </td></tr>
    <tr><td class="paramname">ERROR</td><td>Out of memory, or IO error, or malformed event structure, or the file is malformed (e.g., contains Gtid_log_events but no <a class="el" href="classPrevious__gtids__log__event.html">Previous_gtids_log_event</a>). </td></tr>
    <tr><td class="paramname">TRUNCATED</td><td>The file was truncated before the end of the first <a class="el" href="classPrevious__gtids__log__event.html">Previous_gtids_log_event</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaddc5340a448c8179ab35b3f2e0891984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddc5340a448c8179ab35b3f2e0891984">&#9670;&nbsp;</a></span>add_log_to_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::add_log_to_index </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>log_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>log_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Append log file name to index file.</p>
<ul>
<li>To make crash safe, we copy all the content of index file to crash safe index file firstly and then append the log file name to the crash safe index file. Finally move the crash safe index file to index file.</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20a543666e684f08da1cc093d5fa70ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a543666e684f08da1cc093d5fa70ec">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Stage_manager::Mutex_queue::append </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>first</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Append a linked list of threads to the queue. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The queue was empty before this operation. </td></tr>
    <tr><td class="paramname">false</td><td>The queue was non-empty before this operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacface590afa692fc84446cde6f104231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacface590afa692fc84446cde6f104231">&#9670;&nbsp;</a></span>assign_automatic_gtids_to_flush_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::assign_automatic_gtids_to_flush_group </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>first_seen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Assign automatic generated GTIDs for all commit group threads in the flush stage having gtid_next.type == AUTOMATIC_GROUP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_seen</td><td>The first thread seen entering the flush stage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if succeeds, otherwise true is returned. </dd></dl>

</div>
</div>
<a id="ga46468c405fde69f126c1bcb343c85c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46468c405fde69f126c1bcb343c85c90">&#9670;&nbsp;</a></span>binlog_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool binlog_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check whether binlog_hton has valid slot and enabled </p>

</div>
</div>
<a id="gab499865e2616dac2a882d7937a62d2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab499865e2616dac2a882d7937a62d2aa">&#9670;&nbsp;</a></span>binlog_xa_commit_or_rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int binlog_xa_commit_or_rollback </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxid__t.html">XID</a> *&#160;</td>
          <td class="paramname"><em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Logging XA commit/rollback of a prepared transaction in the case it was disconnected and resumed (recovered), or executed by a slave applier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD handle </td></tr>
    <tr><td class="paramname">xid</td><td>a pointer to XID object </td></tr>
    <tr><td class="paramname">commit</td><td>when <code>true</code> XA-COMMIT is logged, otherwise XA-ROLLBACK</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code, 0 success </dd></dl>

</div>
</div>
<a id="ga63c6fcd1b8e84116f7bcec46e7b25caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63c6fcd1b8e84116f7bcec46e7b25caa">&#9670;&nbsp;</a></span>check_binlog_cache_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_binlog_cache_size </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Checks if the BINLOG_CACHE_SIZE's value is greater than MAX_BINLOG_CACHE_SIZE. If this happens, the BINLOG_CACHE_SIZE is set to MAX_BINLOG_CACHE_SIZE. </p>

</div>
</div>
<a id="ga7a0a12298d22d080b68e55f324cd59bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0a12298d22d080b68e55f324cd59bd">&#9670;&nbsp;</a></span>check_binlog_stmt_cache_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_binlog_stmt_cache_size </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Checks if the BINLOG_STMT_CACHE_SIZE's value is greater than MAX_BINLOG_STMT_CACHE_SIZE. If this happens, the BINLOG_STMT_CACHE_SIZE is set to MAX_BINLOG_STMT_CACHE_SIZE. </p>

</div>
</div>
<a id="gad3389586ace2de50ee7606d7acc98849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3389586ace2de50ee7606d7acc98849">&#9670;&nbsp;</a></span>clear_preempt_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Stage_manager::clear_preempt_status </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The method ensures the follower's execution path can be preempted by the leader's thread. Preempt status of <code>head</code> follower is checked to engange the leader into waiting when set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>THD* of a follower thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22e829bf97dfac49c3b05a2cbdbaf7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e829bf97dfac49c3b05a2cbdbaf7cb">&#9670;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">This is called on shutdown, after ha_panic. </p>

<p>Implements <a class="el" href="classTC__LOG.html#a645b5d1b49c4c4396d327eef07e2dd53">TC_LOG</a>.</p>

</div>
</div>
<a id="gaf6d6d79c98b0c8187b2761b959e67c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6d6d79c98b0c8187b2761b959e67c3f">&#9670;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::close </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>exiting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close the log file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exiting</td><td>Bitmask for one or more of the following bits:<ul>
<li>LOG_CLOSE_INDEX : if we should close the index file</li>
<li>LOG_CLOSE_TO_BE_OPENED : if we intend to call open at once after close.</li>
<li>LOG_CLOSE_STOP_EVENT : write a 'stop' event to the log</li>
</ul>
</td></tr>
    <tr><td class="paramname">need_lock_log</td><td>If true, this function acquires LOCK_log; otherwise the caller should already have acquired it.</td></tr>
    <tr><td class="paramname">need_lock_index</td><td>If true, this function acquires LOCK_index; otherwise the caller should already have acquired it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>One can do an open on the object at once after doing a close. The internal structures are not freed until cleanup() is called </dd></dl>

</div>
</div>
<a id="gad5cf0683506dfdcc484155c676786860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5cf0683506dfdcc484155c676786860">&#9670;&nbsp;</a></span>close_crash_safe_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::close_crash_safe_index_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close the crash safe index file.</p>
<dl class="section note"><dt>Note</dt><dd>The crash safe file is just closed, is not deleted. Because it is moved to index file later on. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94fdcfcfb5d2c85ca2a114ad2115b20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94fdcfcfb5d2c85ca2a114ad2115b20e">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TC_LOG::enum_result MYSQL_BIN_LOG::commit </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Commit the transaction in the transaction coordinator.</p>
<p class="">This function will commit the sessions transaction in the binary log and in the storage engines (by calling <code>ha_commit_low</code>). If the transaction was successfully logged (or not successfully unlogged) but the commit in the engines did not succed, there is a risk of inconsistency between the engines and the binary log.</p>
<p class="">For binary log group commit, the commit is separated into three parts:</p>
<ol type="1">
<li>First part consists of filling the necessary caches and finalizing them (if they need to be finalized). After this, nothing is added to any of the caches.</li>
<li>Second part execute an ordered flush and commit. This will be done using the group commit functionality in ordered_commit.</li>
<li>Third part checks any errors resulting from the ordered commit and handles them appropriately.</li>
</ol>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">RESULT_SUCCESS</td><td>success </td></tr>
    <tr><td class="paramname">RESULT_ABORTED</td><td>error, transaction was neither logged nor committed </td></tr>
    <tr><td class="paramname">RESULT_INCONSISTENT</td><td>error, transaction was logged but not committed </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classTC__LOG.html#a3f9ef43db745a798f8b361eb0b93ff22">TC_LOG</a>.</p>

</div>
</div>
<a id="ga92b6d633ef75cd075586ba82ef3f5c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92b6d633ef75cd075586ba82ef3f5c9e">&#9670;&nbsp;</a></span>do_binlog_xa_commit_rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int do_binlog_xa_commit_rollback </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxid__t.html">XID</a> *&#160;</td>
          <td class="paramname"><em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Logging XA commit/rollback of a prepared transaction.</p>
<p class="">The function is called at XA-commit or XA-rollback logging via two paths: the recovered-or-slave-applier or immediately through the XA-prepared transaction connection itself. It fills in appropiate event in the statement cache whenever xid state is marked with is_binlogged() flag that indicates the prepared part of the transaction must've been logged.</p>
<p class="">About early returns from the function. In the recovered-or-slave-applier case the function may be called for the 2nd time, which has_logged_xid monitors. ONE_PHASE option to XA-COMMIT is handled to skip writing XA-commit event now. And the final early return check is for the read-only XA that is not to be logged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD handle </td></tr>
    <tr><td class="paramname">xid</td><td>a pointer to XID object that is serialized </td></tr>
    <tr><td class="paramname">commit</td><td>when <code>true</code> XA-COMMIT is to be logged, and <code>false</code> when it's XA-ROLLBACK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code, 0 success </dd></dl>

</div>
</div>
<a id="gaf81ca29b12d9e21eb2d36eee2e7a51fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81ca29b12d9e21eb2d36eee2e7a51fe">&#9670;&nbsp;</a></span>do_write_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::do_write_cache </td>
          <td>(</td>
          <td class="paramtype">IO_CACHE *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> *&#160;</td>
          <td class="paramname"><em>writer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Write the contents of the given IO_CACHE to the binary log.</p>
<p class="">The cache will be reset as a READ_CACHE to be able to read the contents from it.</p>
<p class="">The data will be post-processed: see class <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td><a class="el" href="classEvents.html" title="A facade to the functionality of the Event Scheduler.">Events</a> will be read from this IO_CACHE. </td></tr>
    <tr><td class="paramname">writer</td><td><a class="el" href="classEvents.html" title="A facade to the functionality of the Event Scheduler.">Events</a> will be written to this <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>IO error. </td></tr>
    <tr><td class="paramname">false</td><td>Success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Binary__Log.html#gab0d497917a9a65893753ff92be180172">MYSQL_BIN_LOG::write_cache</a> </dd></dl>
<p class="">Nothing in cache: try to refill, and if cache was ended here, return success. This code is needed even on the first iteration of the loop, because reinit_io_cache may or may not fill the first page.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>: this can happen in case of disk corruption in the IO_CACHE. We may have written a half transaction (even half event) to the binlog. We should rollback the transaction and truncate the binlog. /Sven </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>: this can happen in case of disk corruption in the IO_CACHE. We may have written a half transaction (even half event) to the binlog. We should rollback the transaction and truncate the binlog. /Sven </dd></dl>

</div>
</div>
<a id="ga80a5419e22b84b8ca2f3595cbf75fa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a5419e22b84b8ca2f3595cbf75fa67">&#9670;&nbsp;</a></span>ending_single_stmt_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ending_single_stmt_trans </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function checks if a single statement transaction is about to commit or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
    <tr><td class="paramname">all</td><td>Committing a transaction (i.e. TRUE) or a statement (i.e. FALSE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if committing a single statement transaction, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="gaad02774240e19d361a32bd35c9db60cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad02774240e19d361a32bd35c9db60cb">&#9670;&nbsp;</a></span>ending_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ending_trans </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function checks if a transaction, either a multi-statement or a single statement transaction is about to commit or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
    <tr><td class="paramname">all</td><td>Committing a transaction (i.e. TRUE) or a statement (i.e. FALSE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if committing a transaction, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ga71a83004e5774879856189f84d00094f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a83004e5774879856189f84d00094f">&#9670;&nbsp;</a></span>enroll_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Stage_manager::enroll_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStage__manager.html#a28879837525f3786d4bcb6f330f4ac69">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mysql_mutex_t *&#160;</td>
          <td class="paramname"><em>stage_mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Enroll a set of sessions for a stage.</p>
<p class="">This will queue the session thread for writing and flushing.</p>
<p class="">If the thread being queued is assigned as stage leader, it will return immediately.</p>
<p class="">If wait_if_follower is true the thread is not the stage leader, the thread will be wait for the queue to be processed by the leader before it returns. In DBUG-ON version the follower marks is preempt status as ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage</td><td>Stage identifier for the queue to append to. </td></tr>
    <tr><td class="paramname">first</td><td>Queue to append. </td></tr>
    <tr><td class="paramname">stage_mutex</td><td>Pointer to the currently held stage mutex, or NULL if we're not in a stage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Thread is stage leader. </td></tr>
    <tr><td class="paramname">false</td><td>Thread was not stage leader and processing has been done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga254675ae9d8f6f0a7b48d7520ab16eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254675ae9d8f6f0a7b48d7520ab16eea">&#9670;&nbsp;</a></span>fetch_and_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">THD * Stage_manager::Mutex_queue::fetch_and_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Fetch the entire queue for a stage.</p>
<p class="">This will fetch the entire queue in one go. </p>

</div>
</div>
<a id="ga3367fa8c1daced18065f6b9dea5385fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3367fa8c1daced18065f6b9dea5385fe">&#9670;&nbsp;</a></span>finalize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binlog_cache_data::finalize </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLog__event.html">Log_event</a> *&#160;</td>
          <td class="paramname"><em>end_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function finalizes the cache preparing for commit or rollback.</p>
<p class="">The function just writes all the necessary events to the cache but does not flush the data to the binary log file. That is the role of the <a class="el" href="group__Binary__Log.html#ga302d2ea7bfcbea015c329edacdac6c5a">binlog_cache_data::flush</a> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Binary__Log.html#ga302d2ea7bfcbea015c329edacdac6c5a">binlog_cache_data::flush</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread whose transaction should be flushed </td></tr>
    <tr><td class="paramname">cache_data</td><td>Pointer to the cache </td></tr>
    <tr><td class="paramname">end_ev</td><td>The end event either commit/rollback</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if an error pops up when flushing the cache. </dd></dl>

</div>
</div>
<a id="ga16bd8b16b092443137c073f18c7e11e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16bd8b16b092443137c073f18c7e11e4">&#9670;&nbsp;</a></span>finalize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binlog_cache_data::finalize </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLog__event.html">Log_event</a> *&#160;</td>
          <td class="paramname"><em>end_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXID__STATE.html">XID_STATE</a> *&#160;</td>
          <td class="paramname"><em>xs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The method writes XA END query to XA-prepared transaction's cache and calls the "basic" <a class="el" href="group__Binary__Log.html#ga3367fa8c1daced18065f6b9dea5385fe">finalize()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>error code, 0 success </dd></dl>

</div>
</div>
<a id="gab8925923df0bf9cd07f7fcaf45f8db16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8925923df0bf9cd07f7fcaf45f8db16">&#9670;&nbsp;</a></span>find_first_log_not_in_gtid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::find_first_log_not_in_gtid_set </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>binlog_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>gtid_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGtid.html">Gtid</a> *&#160;</td>
          <td class="paramname"><em>first_gtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find the oldest binary log that contains any GTID that is not in the given gtid set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">binlog_file_name,the</td><td>file name of oldest binary log found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gtid_set,the</td><td>given gtid set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_gtid,the</td><td>first GTID information from the binary log file returned at binlog_file_name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errmsg,the</td><td>error message outputted, which is left untouched if the function returns false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error. </dd></dl>

</div>
</div>
<a id="ga245bb1e482896f726e11719666f2394a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga245bb1e482896f726e11719666f2394a">&#9670;&nbsp;</a></span>find_log_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::find_log_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__log__info.html">LOG_INFO</a> *&#160;</td>
          <td class="paramname"><em>linfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find the position in the log-index-file for the given log name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">linfo</td><td>The found log file name will be stored here, along with the byte offset of the next log file name in the index file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">log_name</td><td>Filename to find in the index file, or NULL if we want to read the first entry. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">need_lock_index</td><td>If false, this function acquires LOCK_index; otherwise the lock should already be held by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On systems without the truncate function the file will end with one or more empty lines. These will be ignored when reading the file.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_EOF</td><td>End of log-index-file found </td></tr>
    <tr><td class="paramname">LOG_INFO_IO</td><td>Got IO error while reading file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ed66e95398bcafa143ca8ad16860711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ed66e95398bcafa143ca8ad16860711">&#9670;&nbsp;</a></span>find_next_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::find_next_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__log__info.html">LOG_INFO</a> *&#160;</td>
          <td class="paramname"><em>linfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find the position in the log-index-file for the given log name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">linfo</td><td>The filename will be stored here, along with the byte offset of the next filename in the index file.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">need_lock_index</td><td>If true, LOCK_index will be acquired; otherwise it should already be held by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Before calling this function, one has to call <a class="el" href="group__Binary__Log.html#ga245bb1e482896f726e11719666f2394a">find_log_pos()</a> to set up 'linfo'</li>
<li>Mutex needed because we need to make sure the file pointer does not move from under our feet</li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_EOF</td><td>End of log-index-file found </td></tr>
    <tr><td class="paramname">LOG_INFO_IO</td><td>Got IO error while reading file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a173d873dfe12dee3963402b0a2075e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a173d873dfe12dee3963402b0a2075e">&#9670;&nbsp;</a></span>find_next_relay_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::find_next_relay_log </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>log_name</em>[FN_REFLEN+1]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find the relay log name following the given name from relay log index file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in|out]</td><td>log_name The name is full path name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return 0 if it finds next relay log. Otherwise return the error code. </dd></dl>

</div>
</div>
<a id="ga302d2ea7bfcbea015c329edacdac6c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga302d2ea7bfcbea015c329edacdac6c5a">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binlog_cache_data::flush </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">my_off_t *&#160;</td>
          <td class="paramname"><em>bytes_written</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>wrote_xid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Flush caches to the binary log.</p>
<p class="">If the cache is finalized, the cache will be flushed to the binary log file. If the cache is not finalized, nothing will be done.</p>
<p class="">If flushing fails for any reason, an error will be reported and the cache will be reset. Flushing can fail in two circumstances:</p>
<ul>
<li>It was not possible to write the cache to the file. In this case, it does not make sense to keep the cache.</li>
<li>The cache was successfully written to disk but post-flush actions (such as binary log rotation) failed. In this case, the cache is already written to disk and there is no reason to keep it.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Binary__Log.html#ga3367fa8c1daced18065f6b9dea5385fe">binlog_cache_data::finalize</a> </dd></dl>

</div>
</div>
<a id="gae40c4dc6b0b8986a50661b28df3a6fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40c4dc6b0b8986a50661b28df3a6fa3">&#9670;&nbsp;</a></span>flush_and_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::flush_and_sync </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Flush binlog cache and synchronize to disk.</p>
<p class="">This function flushes events in binlog cache to binary log file, it will do synchronizing according to the setting of system variable 'sync_binlog'. If file is synchronized, <code>synced</code> will be set to 1, otherwise 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">synced</td><td>if not NULL, set to 1 if file is synchronized, otherwise 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>if TRUE, ignores the 'sync_binlog' and synchronizes the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">other</td><td>Failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabcd5b380680e537bdec0f093a8f2e3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd5b380680e537bdec0f093a8f2e3d6">&#9670;&nbsp;</a></span>generate_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * MYSQL_BIN_LOG::generate_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>The following should be using fn_format(); We just need to first change fn_format() to cut the file name if it's too long. </dd></dl>

</div>
</div>
<a id="ga8d92fa178d27467ce506c759c5d82959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d92fa178d27467ce506c759c5d82959">&#9670;&nbsp;</a></span>get_gtid_executed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::get_gtid_executed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSid__map.html">Sid_map</a> *&#160;</td>
          <td class="paramname"><em>sid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>gtid_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Deep copy global_sid_map to</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sid_map</td><td>and gtid_state-&gt;get_executed_gtids() to</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gtid_set</td><td>Both operations are done under LOCK_commit and global_sid_lock protection.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sid_map</td><td>The <a class="el" href="classSid__map.html">Sid_map</a> to which global_sid_map will be copied. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gtid_set</td><td>The <a class="el" href="classGtid__set.html">Gtid_set</a> to which gtid_executed will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">!=0</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e7e658ba27b48710cf57e3f8a8253e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e7e658ba27b48710cf57e3f8a8253e4">&#9670;&nbsp;</a></span>gtid_end_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::gtid_end_transaction </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">If the thread owns a GTID, this function generates an empty transaction and releases ownership of the GTID.</p>
<ul>
<li>If the binary log is disabled for this thread, the GTID is inserted directly into the mysql.gtid_executed table and the GTID is included in @global.gtid_executed. (This only happens for DDL, since DML will save the GTID into table and release ownership inside ha_commit_trans.)</li>
<li>If the binary log is enabled for this thread, an empty transaction consisting of GTID, BEGIN, COMMIT is written to the binary log, the GTID is included in @global.gtid_executed, and the GTID is added to the mysql.gtid_executed table on the next binlog rotation.</li>
</ul>
<p class="">This function must be called by any committing statement (COMMIT, implicitly committing statements, or <a class="el" href="classXid__log__event.html">Xid_log_event</a>), after the statement has completed execution, regardless of whether the statement updated the database.</p>
<p class="">This logic ensures that an empty transaction is generated for the following cases:</p>
<ul>
<li>Explicit empty transaction: SET GTID_NEXT = 'UUID:NUMBER'; BEGIN; COMMIT;</li>
<li>Transaction or DDL that gets completely filtered out in the slave thread.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The committing thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">nonzero</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f038ff4067e3f5be2b4dacc1e50ac72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f038ff4067e3f5be2b4dacc1e50ac72">&#9670;&nbsp;</a></span>handle_gtid_consistency_violation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handle_gtid_consistency_violation </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Given that a possible violation of gtid consistency has happened, checks if gtid-inconsistencies are forbidden by the current value of ENFORCE_GTID_CONSISTENCY and GTID_MODE. If forbidden, generates error or warning accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread that has issued the GTID-violating statement.</td></tr>
    <tr><td class="paramname">error_code</td><td>The error code to use, if error or warning is to be generated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Error was generated. </td></tr>
    <tr><td class="paramname">true</td><td>No error was generated (possibly a warning was generated). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab52138e0e18c6bca2812e4051164db4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab52138e0e18c6bca2812e4051164db4f">&#9670;&nbsp;</a></span>init_gtid_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::init_gtid_sets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>gtid_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGtid__set.html">Gtid_set</a> *&#160;</td>
          <td class="paramname"><em>lost_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTransaction__boundary__parser.html">Transaction_boundary_parser</a> *&#160;</td>
          <td class="paramname"><em>trx_parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGtid.html">Gtid</a> *&#160;</td>
          <td class="paramname"><em>gtid_partial_trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_server_starting</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reads the set of all GTIDs in the binary/relay log, and the set of all lost GTIDs in the binary log, and stores each set in respective argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">gtid_set</td><td>Will be filled with all GTIDs in this binary/relay log. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lost_groups</td><td>Will be filled with all GTIDs in the <a class="el" href="classPrevious__gtids__log__event.html">Previous_gtids_log_event</a> of the first binary log that has a <a class="el" href="classPrevious__gtids__log__event.html">Previous_gtids_log_event</a>. This is requested to binary logs but not to relay logs. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">verify_checksum</td><td>If true, checksums will be checked. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">need_lock</td><td>If true, LOCK_log, LOCK_index, and global_sid_lock-&gt;wrlock are acquired; otherwise they are asserted to be taken already. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">trx_parser</td><td>[out] This will be used to return the actual relaylog transaction parser state because of the possibility of partial transactions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gtid_partial_trx</td><td>If a transaction was left incomplete on the relaylog, it's GTID should be returned to be used in the case of the rest of the transaction be added to the relaylog. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">is_server_starting</td><td>True if the server is starting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on error. </dd></dl>

</div>
</div>
<a id="gaac641bdabee70ba4bd377e06e1853fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac641bdabee70ba4bd377e06e1853fcb">&#9670;&nbsp;</a></span>is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::is_active </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_file_name_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if we are writing/reading to the given log file. </p>

</div>
</div>
<a id="ga47165cf06d3f64979787a85b6b43f3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47165cf06d3f64979787a85b6b43f3ac">&#9670;&nbsp;</a></span>is_empty_transaction_in_binlog_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_empty_transaction_in_binlog_cache </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if at least one of transacaction and statement binlog caches contains an empty transaction, other one is empty or contains an empty transaction, which has two binlog events "BEGIN" and "COMMIT".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>At least one of transacaction and statement binlog caches contains an empty transaction, other one is empty or contains an empty transaction. </td></tr>
    <tr><td class="paramname">false</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f5702b2bc03f66bc0a37c05ff1c84e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5702b2bc03f66bc0a37c05ff1c84e8">&#9670;&nbsp;</a></span>is_loggable_xa_prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_loggable_xa_prepare </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Predicate function yields true when XA transaction is being logged having a proper state ready for prepare or commit in one phase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer of running transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true When the being prepared transaction should be binlogged, false otherwise. </dd></dl>

</div>
</div>
<a id="ga94f694096c1ef28962d9d7936d2d9a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f694096c1ef28962d9d7936d2d9a1e">&#9670;&nbsp;</a></span>make_log_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::make_log_name </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_ident</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Delete relay log files prior to rli-&gt;group_relay_log_name (i.e. all logs which are not involved in a non-finished group (transaction)), remove them from the index file and start on next relay log.</p>
<p class="">IMPLEMENTATION</p>
<ul>
<li>You must hold rli-&gt;data_lock before calling this function, since it writes group_relay_log_pos and similar fields of <a class="el" href="classRelay__log__info.html">Relay_log_info</a>.</li>
<li>Protects index file with LOCK_index</li>
<li>Delete relevant relay log files</li>
<li>Copy all file names after these ones to the front of the index file</li>
<li>If the OS has truncate, truncate the file, else fill it with <br />
'</li>
<li>Read the next file name from the index file and store in rli-&gt;linfo</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rli</td><td>Relay log information </td></tr>
    <tr><td class="paramname">included</td><td>If false, all relay logs that are strictly before rli-&gt;group_relay_log_name are deleted ; if true, the latter is deleted too (i.e. all relay logs read by the SQL slave thread are deleted).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This is only called from the slave SQL thread when it has read all commands from a relay log and want to switch to a new relay log.</li>
<li>When this happens, we can be in an active transaction as a transaction can span over two relay logs (although it is always written as a single block to the master's binary log, hence cannot span over two master's binary logs).</li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">LOG_INFO_EOF</td><td>End of log-index-file found </td></tr>
    <tr><td class="paramname">LOG_INFO_SEEK</td><td>Could not allocate IO cache </td></tr>
    <tr><td class="paramname">LOG_INFO_IO</td><td>Got IO error while reading fileCreate a new log file name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buf of at least FN_REFLEN where new name is stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If file name will be longer then FN_REFLEN it will be truncated </dd></dl>

</div>
</div>
<a id="gab57cd148796a62181465bb25db0e236c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab57cd148796a62181465bb25db0e236c">&#9670;&nbsp;</a></span>move_crash_safe_index_file_to_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::move_crash_safe_index_file_to_index_file </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Move crash safe index file to index file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">need_lock_index</td><td>If true, LOCK_index will be acquired; otherwise it should already be held.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44de4e3109fc4d50d4968191ab0f3544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44de4e3109fc4d50d4968191ab0f3544">&#9670;&nbsp;</a></span>open_binlog() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::open_binlog </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>keep in-memory list of prepared transactions (add to list in log(), remove on unlog()) and copy it to the new binlog if rotated but let's check the behaviour of tc_log_page_waits first! </dd></dl>

</div>
</div>
<a id="ga8614d8fb3c4c2c255145d6cfd992e8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8614d8fb3c4c2c255145d6cfd992e8d8">&#9670;&nbsp;</a></span>open_binlog() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::open_binlog </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>new_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>max_size_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>null_created_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_sid_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> *&#160;</td>
          <td class="paramname"><em>extra_description_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create a new binary log. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_name</td><td>Name of binlog </td></tr>
    <tr><td class="paramname">new_name</td><td>Name of binlog, too. todo: what's the difference between new_name and log_name? </td></tr>
    <tr><td class="paramname">max_size</td><td>The size at which this binlog will be rotated. </td></tr>
    <tr><td class="paramname">null_created</td><td>If false, and a <a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> is written, then the <a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> will have the timestamp 0. Otherwise, it the timestamp will be the time when the event was written to the log. </td></tr>
    <tr><td class="paramname">need_lock_index</td><td>If true, LOCK_index is acquired; otherwise LOCK_index must be taken by the caller. </td></tr>
    <tr><td class="paramname">need_sid_lock</td><td>If true, the read lock on global_sid_lock will be acquired. Otherwise, the caller must hold the read lock on global_sid_lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Open a (new) binlog file.</p>
<ul>
<li>Open the log file and the index file. Register the new file name in it</li>
<li>When calling this when the file is in use, you must have a locks on LOCK_log and LOCK_index.</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79ed24f2c1a0645530426f4346470781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79ed24f2c1a0645530426f4346470781">&#9670;&nbsp;</a></span>open_binlog_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">File open_binlog_file </td>
          <td>(</td>
          <td class="paramtype">IO_CACHE *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>log_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>errmsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open a single binary log file for reading. </p>

</div>
</div>
<a id="gac6d69e1ee6b9099429bd919af752a0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6d69e1ee6b9099429bd919af752a0eb">&#9670;&nbsp;</a></span>open_crash_safe_index_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::open_crash_safe_index_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open a (new) crash safe index file.</p>
<dl class="section note"><dt>Note</dt><dd>The crash safe index file is a special file used for guaranteeing index file crash safe. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4789039161947fff76fa8250b120b7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4789039161947fff76fa8250b120b7e3">&#9670;&nbsp;</a></span>prepare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::prepare </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Log a prepare record of the transaction to the storage engines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session to log transaction record for.</td></tr>
    <tr><td class="paramname">all</td><td><code>true</code> if an explicit commit or an implicit commit for a statement, <code>false</code> if an internal commit of the statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code on failure, zero on success. </dd></dl>

<p>Implements <a class="el" href="classTC__LOG.html#ab968f1e200f370127c3dcd0302d00968">TC_LOG</a>.</p>

</div>
</div>
<a id="gaff1889360685bd90b1d3ffba10ba3dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff1889360685bd90b1d3ffba10ba3dba">&#9670;&nbsp;</a></span>purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::purge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The method executes logs purging routine.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nonzero</td><td>- error in rotating routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f15ff584adebd77fd1bf4ebc88a68b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f15ff584adebd77fd1bf4ebc88a68b6">&#9670;&nbsp;</a></span>purge_master_logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool purge_master_logs </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to_log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Execute a PURGE BINARY LOGS TO &lt;log&gt; command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to THD object for the client thread executing the statement.</td></tr>
    <tr><td class="paramname">to_log</td><td>Name of the last log to purge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>success </td></tr>
    <tr><td class="paramname">TRUE</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38f8e56905c5205bb8cf6268cd203cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38f8e56905c5205bb8cf6268cd203cb2">&#9670;&nbsp;</a></span>purge_master_logs_before_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool purge_master_logs_before_date </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>purge_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Execute a PURGE BINARY LOGS BEFORE &lt;date&gt; command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Pointer to THD object for the client thread executing the statement.</td></tr>
    <tr><td class="paramname">purge_time</td><td>Date before which logs should be purged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>success </td></tr>
    <tr><td class="paramname">TRUE</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e843aafa062a4ab987d5ff75d450c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e843aafa062a4ab987d5ff75d450c41">&#9670;&nbsp;</a></span>recover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::recover </td>
          <td>(</td>
          <td class="paramtype">IO_CACHE *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> *&#160;</td>
          <td class="paramname"><em>fdle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">my_off_t *&#160;</td>
          <td class="paramname"><em>valid_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">MYSQLD server recovers from last crashed binlog.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log</td><td>IO_CACHE of the crashed binlog. </td></tr>
    <tr><td class="paramname">fdle</td><td><a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> of the crashed binlog. </td></tr>
    <tr><td class="paramname">valid_pos</td><td>The position of the last valid transaction or event(non-transaction) of the crashed binlog.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53bb73d56883af0d06d664f19407eac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53bb73d56883af0d06d664f19407eac1">&#9670;&nbsp;</a></span>register_binlog_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void register_binlog_handler </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa7f92132aa396f9d9aa44701800334be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7f92132aa396f9d9aa44701800334be">&#9670;&nbsp;</a></span>reset_logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::reset_logs </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Removes files, as part of a RESET MASTER or RESET SLAVE statement, by deleting all logs refered to in the index file. Then, it starts writing to a new log file.</p>
<p class="">The new index file will only contain this file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If not called from slave thread, write start event to new log</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9590d29210bd03fce1b8f9effc7c2d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9590d29210bd03fce1b8f9effc7c2d2a">&#9670;&nbsp;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::rollback </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Write a rollback record of the transaction to the binary log.</p>
<p class="">For binary log group commit, the rollback is separated into three parts:</p>
<ol type="1">
<li>First part consists of filling the necessary caches and finalizing them (if they need to be finalized). After a cache is finalized, nothing can be added to the cache.</li>
<li><p class="startli">Second part execute an ordered flush and commit. This will be done using the group commit functionality in <code>ordered_commit</code>.</p>
<p class="startli">Since we roll back the transaction early, we call <code>ordered_commit</code> with the <code>skip_commit</code> flag set. The <code>ha_commit_low</code> call inside <code>ordered_commit</code> will then not be called.</p>
</li>
<li>Third part checks any errors resulting from the flush and handles them appropriately.</li>
</ol>
<dl class="section see"><dt>See also</dt><dd>MYSQL_BIN_LOG::ordered_commit </dd>
<dd>
<a class="el" href="handler_8cc.html#a4a77fdd0e1d6bee79e29e7495c7d752a">ha_commit_low</a> </dd>
<dd>
ha_rollback_low</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Session to commit </td></tr>
    <tr><td class="paramname">all</td><td>This is <code>true</code> if this is a real transaction rollback, and  otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code, or zero if there were no error. </dd></dl>

<p>Implements <a class="el" href="classTC__LOG.html#abf637f1bbf02c6f8e4f69aa2f5e2d362">TC_LOG</a>.</p>

</div>
</div>
<a id="ga2053b0b53a46eb5702b44966497c333f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2053b0b53a46eb5702b44966497c333f">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::rotate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_rotate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>check_purge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The method executes rotation when LOCK_log is already acquired by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force_rotate</td><td>caller can request the log rotation </td></tr>
    <tr><td class="paramname">check_purge</td><td>is set to true if rotation took place</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If rotation fails, for instance the server was unable to create a new log file, we still try to write an incident event to the current log.</dd>
<dd>
The caller must hold LOCK_log when invoking this function.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nonzero</td><td>- error in rotating routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f41b228c438fe7b4c710b8fdd780cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f41b228c438fe7b4c710b8fdd780cfb">&#9670;&nbsp;</a></span>rotate_and_purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::rotate_and_purge </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_rotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Execute a FLUSH LOGS statement.</p>
<p class="">The method is a shortcut of <code><a class="el" href="group__Binary__Log.html#ga2053b0b53a46eb5702b44966497c333f">rotate()</a></code> and <code><a class="el" href="group__Binary__Log.html#gaff1889360685bd90b1d3ffba10ba3dba">purge()</a></code>. LOCK_log is acquired prior to rotate and is released after it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force_rotate</td><td>caller can request the log rotation</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nonzero</td><td>- error in rotating routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5bbd66f9464d9a83f33fdcdba20d7d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bbd66f9464d9a83f33fdcdba20d7d99">&#9670;&nbsp;</a></span>set_crash_safe_index_file_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::set_crash_safe_index_file_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Set the name of crash safe index file.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07a668f531f059316c8f17dfcecfd465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07a668f531f059316c8f17dfcecfd465">&#9670;&nbsp;</a></span>stmt_cannot_safely_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stmt_cannot_safely_rollback </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function checks if current statement cannot be rollded back safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if cannot be safely rolled back, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaf43af0e4821421ea58375e7d4943c6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf43af0e4821421ea58375e7d4943c6c0">&#9670;&nbsp;</a></span>stmt_has_updated_trans_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stmt_has_updated_trans_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHa__trx__info.html">Ha_trx_info</a> *&#160;</td>
          <td class="paramname"><em>ha_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function checks if a transactional table was updated by the current statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ha_list</td><td>Registered storage engine handler list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a transactional table was updated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga1d647f955254c565dc33abf8caabdbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d647f955254c565dc33abf8caabdbab">&#9670;&nbsp;</a></span>trans_cannot_safely_rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trans_cannot_safely_rollback </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function checks if a transaction cannot be rolled back safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if cannot be safely rolled back, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga25239dc38f22eeef6e1aea243af6fd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25239dc38f22eeef6e1aea243af6fd9a">&#9670;&nbsp;</a></span>trans_has_updated_trans_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool trans_has_updated_trans_table </td>
          <td>(</td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function checks if a transactional table was updated by the current transaction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The client thread that executed the current statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a transactional table was updated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gae0d03425fee2a702a9b4dfac7b9de4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d03425fee2a702a9b4dfac7b9de4b1">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binlog_trx_cache_data::truncate </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function truncates the transactional cache upon committing or rolling back either a transaction or a statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread whose transaction should be flushed </td></tr>
    <tr><td class="paramname">cache_mngr</td><td>Pointer to the cache data to be flushed </td></tr>
    <tr><td class="paramname">all</td><td><code>true</code> means truncate the transaction, otherwise the statement must be truncated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if an error pops up when truncating the transactional cache. </dd></dl>

</div>
</div>
<a id="gaa85432b55b5d1d84283e83c4399ad524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa85432b55b5d1d84283e83c4399ad524">&#9670;&nbsp;</a></span>wait_count_or_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Stage_manager::wait_count_or_timeout </td>
          <td>(</td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>usec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStage__manager.html#a28879837525f3786d4bcb6f330f4ac69">StageID</a>&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Introduces a wait operation on the executing thread. The waiting is done until the timeout elapses or count is reached (whichever comes first).</p>
<p class="">If count == 0, then the session will wait until the timeout elapses. If timeout == 0, then there is no waiting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usec</td><td>the number of microseconds to wait. </td></tr>
    <tr><td class="paramname">count</td><td>wait for as many as count to join the queue the session is waiting on </td></tr>
    <tr><td class="paramname">stage</td><td>which stage queue size to compare count against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b625b440aaf82241200b3980d94c6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b625b440aaf82241200b3980d94c6a9">&#9670;&nbsp;</a></span>wait_for_update_bin_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::wait_for_update_bin_log </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Wait until we get a signal that the binary log has been updated. Applies to master only.</p>
<p class=""><br />
NOTES </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>a THD struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>a pointer to a timespec; NULL means to wait w/o timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if got signalled on update </td></tr>
    <tr><td class="paramname">non-0</td><td>if wait timeout elapsed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>LOCK_log must be taken before calling this function. LOCK_log is being released while the thread is waiting. LOCK_log is released by the caller. </dd></dl>

</div>
</div>
<a id="ga10698ebc9afd7be839f7a69b7aaac141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10698ebc9afd7be839f7a69b7aaac141">&#9670;&nbsp;</a></span>wait_for_update_relay_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MYSQL_BIN_LOG::wait_for_update_relay_log </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Wait until we get a signal that the relay log has been updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>a pointer to a timespec; NULL means to wait w/o timeout.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if got signalled on update </td></tr>
    <tr><td class="paramname">non-0</td><td>if wait timeout elapsed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>One must have a lock on LOCK_log before calling this function. </dd></dl>

</div>
</div>
<a id="gab0d497917a9a65893753ff92be180172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d497917a9a65893753ff92be180172">&#9670;&nbsp;</a></span>write_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_cache </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *&#160;</td>
          <td class="paramname"><em>binlog_cache_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> *&#160;</td>
          <td class="paramname"><em>writer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Write the contents of the statement or transaction cache to the binary log.</p>
<p class="">Comparison with do_write_cache:</p>
<ul>
<li>do_write_cache is a lower-level function that only performs the actual write.</li>
<li>write_cache is a higher-level function that calls do_write_cache and additionally performs some maintenance tasks, including:<ul>
<li>report any errors that occurred</li>
<li>write incident event if needed</li>
<li>update gtid_state</li>
<li>update thd.binlog_next_event_pos</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread variable</td></tr>
    <tr><td class="paramname">cache_data</td><td><a class="el" href="classEvents.html" title="A facade to the functionality of the Event Scheduler.">Events</a> will be read from the IO_CACHE of this cache_data object.</td></tr>
    <tr><td class="paramname">writer</td><td><a class="el" href="classEvents.html" title="A facade to the functionality of the Event Scheduler.">Events</a> will be written to this <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>IO error. </td></tr>
    <tr><td class="paramname">false</td><td>Success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We only come here if there is something in the cache. </dd>
<dd>
Whatever is in the cache is always a complete transaction. </dd>
<dd>
'cache' needs to be reinitialized after this functions returns. </dd></dl>

</div>
</div>
<a id="ga32b5241d2e64863a3de611e7b5eb95fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32b5241d2e64863a3de611e7b5eb95fd">&#9670;&nbsp;</a></span>write_dml_directly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_dml_directly </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stmt_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Write a dml into statement cache and then flush it into binlog. It writes <a class="el" href="classGtid__log__event.html">Gtid_log_event</a> and BEGIN, COMMIT automatically.</p>
<p class="">It is aimed to handle cases of "background" logging where a statement is logged indirectly, like "DELETE FROM a_memory_table". So don't use it on any normal statement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[IN]</td><td>thd the THD object of current thread. </td></tr>
    <tr><td class="paramname">[IN]</td><td>stmt the DELETE statement. </td></tr>
    <tr><td class="paramname">[IN]</td><td>stmt_len the length of DELETE statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns false if succeeds, otherwise true is returned. </dd></dl>

</div>
</div>
<a id="ga9c19cd666a1a517386dedd4078dd93e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c19cd666a1a517386dedd4078dd93e7">&#9670;&nbsp;</a></span>write_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLog__event.html">Log_event</a> *&#160;</td>
          <td class="paramname"><em>event_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Write an event to the binary log. </p>

</div>
</div>
<a id="gabc6da7d051531ecf891a1fe631697f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc6da7d051531ecf891a1fe631697f38">&#9670;&nbsp;</a></span>write_gtid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_gtid </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a> *&#160;</td>
          <td class="paramname"><em>cache_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> *&#160;</td>
          <td class="paramname"><em>writer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Write the <a class="el" href="classGtid__log__event.html">Gtid_log_event</a> to the binary log (prior to writing the statement or transaction cache).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread that is committing. </td></tr>
    <tr><td class="paramname">cache_data</td><td>The cache that is flushing. </td></tr>
    <tr><td class="paramname">writer</td><td>The event will be written to this <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaceb6fa03fdf46ada9510567752878a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceb6fa03fdf46ada9510567752878a53">&#9670;&nbsp;</a></span>write_incident() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_incident </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>err_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_flush_and_sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Creates an incident event and writes it to the binary log.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread variable </td></tr>
    <tr><td class="paramname">ev</td><td>Incident event to be written </td></tr>
    <tr><td class="paramname">err_msg</td><td>Error message written to log file for the incident. </td></tr>
    <tr><td class="paramname">lock</td><td>If the binary lock should be locked or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>error </td></tr>
    <tr><td class="paramname">1</td><td>success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed3d159f584e6c57aed2e5af51db49fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed3d159f584e6c57aed2e5af51db49fb">&#9670;&nbsp;</a></span>write_incident() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MYSQL_BIN_LOG::write_incident </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIncident__log__event.html">Incident_log_event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock_log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>err_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_flush_and_sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Writes an incident event to stmt_cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ev</td><td>Incident event to be written </td></tr>
    <tr><td class="paramname">thd</td><td>Thread variable </td></tr>
    <tr><td class="paramname">need_lock_log</td><td>If true, will acquire LOCK_log; otherwise the caller should already have acquired LOCK_log. </td></tr>
    <tr><td class="paramname">err_msg</td><td>Error message written to log file for the incident.  If true, will call <a class="el" href="group__Binary__Log.html#gae40c4dc6b0b8986a50661b28df3a6fa3">flush_and_sync()</a>, <a class="el" href="group__Binary__Log.html#ga2053b0b53a46eb5702b44966497c333f">rotate()</a> and <a class="el" href="group__Binary__Log.html#gaff1889360685bd90b1d3ffba10ba3dba">purge()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>error </td></tr>
    <tr><td class="paramname">true</td><td>success </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ebea3ac42b19b6e1c86ca33c3cb28e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ebea3ac42b19b6e1c86ca33c3cb28e7">&#9670;&nbsp;</a></span>xlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::xlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Acquire an exclusive lock to block binary log updates and commits. This is used by START TRANSACTION WITH CONSISTENT SNAPSHOT to create an atomic snapshot. </p>

<p>Implements <a class="el" href="classTC__LOG.html#aac75dc061e9aae27449e675b23c27ae3">TC_LOG</a>.</p>

</div>
</div>
<a id="gaee260f3856d7b1e557b91b7ecdc0b01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee260f3856d7b1e557b91b7ecdc0b01c">&#9670;&nbsp;</a></span>xunlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MYSQL_BIN_LOG::xunlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Release lock acquired with <a class="el" href="group__Binary__Log.html#ga5ebea3ac42b19b6e1c86ca33c3cb28e7">xlock()</a>. </p>

<p>Implements <a class="el" href="classTC__LOG.html#a60ee380273adc9e23c56ff114cd2636a">TC_LOG</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaf6ecc9c0253b423bc48289c779e9c010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ecc9c0253b423bc48289c779e9c010">&#9670;&nbsp;</a></span>binlog_storage_engine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct st_mysql_storage_engine binlog_storage_engine</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{ MYSQL_HANDLERTON_INTERFACE_VERSION }</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
