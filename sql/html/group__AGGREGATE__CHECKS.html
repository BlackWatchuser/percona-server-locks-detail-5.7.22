<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Aggregate checks of ONLY_FULL_GROUP_BY</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Aggregate checks of ONLY_FULL_GROUP_BY</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__tree__walker.html">Item_tree_walker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDistinct__check.html">Distinct_check</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGroup__check.html">Group_check</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga69e57fec296941e565db230b184262ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga69e57fec296941e565db230b184262ec">FORBID_COPY_CTOR_AND_ASSIGN_OP</a>(myclass)</td></tr>
<tr class="separator:ga69e57fec296941e565db230b184262ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga83e75b415b78e10ade375ad320ea446c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga83e75b415b78e10ade375ad320ea446c">Distinct_check::check_query</a> (THD *thd)</td></tr>
<tr class="separator:ga83e75b415b78e10ade375ad320ea446c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f98a122e6f9accf528534acb5db686"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga85f98a122e6f9accf528534acb5db686">Group_check::check_query</a> (THD *thd)</td></tr>
<tr class="separator:ga85f98a122e6f9accf528534acb5db686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e11f17193e6ad1adff12b0ff2c3af6"><td class="memItemLeft" align="right" valign="top"><a id="ga97e11f17193e6ad1adff12b0ff2c3af6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga97e11f17193e6ad1adff12b0ff2c3af6">Group_check::to_opt_trace</a> (THD *thd)</td></tr>
<tr class="memdesc:ga97e11f17193e6ad1adff12b0ff2c3af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes "check information" to the optimizer trace. <br /></td></tr>
<tr class="separator:ga97e11f17193e6ad1adff12b0ff2c3af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p class="">Checks for some semantic constraints on queries using GROUP BY, or aggregate functions, or DISTINCT.</p>
<p class="">We call "aggregation" the operation of taking a group of rows and replacing it with a single row. There are three types of aggregation: DISTINCT, implicit grouping, explicit grouping.</p>
<p class="">This text describes MySQL's checks (why certain queries are rejected) and the rationale behind them.</p>
<p class="">References:</p><ul>
<li>WL#2489 "better only_full_group_by".</li>
<li>if you have access to the SQL standard, we recommend the following parts of "SQL2011 Foundation": query expression Syntax rule 28; column reference Syntax rule 7 and Conformance rule 2; 4.19 functional dependencies.</li>
</ul>
<h1><a class="anchor" id="DISTINCT"></a>
DISTINCT</h1>
<p class="">DISTINCT: all identical rows in the result of SELECT are "aggregated" to one single row - duplicates are eliminated. If the result of the SELECT without DISTINCT is </p><pre class="fragment">1 2
3 4
1 2
</pre><p> then the result with DISTINCT is </p><pre class="fragment">1 2
3 4
</pre><p> Here is a problematic query. Assume we have a table T which contains three columns C1,C2,C3 and has the following rows: </p><pre class="fragment">C1 C2 C3
1  2  A
3  4  B
1  2  C
</pre><p> and we do "SELECT DISTINCT C1, C2 FROM T ORDER BY C3". Because we want the result to be ordered, we have to first eliminate duplicates then order the result. When we eliminate duplicates, should we keep the first or the third row? This arbitrary choice will influence the retained value of C3, which will influence ordering. In the end, we have arbitrary ordering, which is problematic. To prevent this, if, in a query block 'sl', an ORDER BY expression is not the same expression as one in the SELECT list of 'sl' and contains a column which:</p><ul>
<li>is of a table whose qualifying query block is 'sl'</li>
<li>and is not in the SELECT list of 'sl'</li>
</ul>
<p class="">then 'sl' should not have DISTINCT. This rule makes the query above invalid. Class Check_distinct implements this rule.</p>
<p class="">Class Check_distinct implements a second rule, specific of set functions in ORDER BY (a non-standard feature). Consider these queries labelled (1), (2), (3), with DISTINCT and a set function in ORDER BY: </p><pre class="fragment">SELECT DISTINCT MIN(C2) FROM T GROUP BY C1 ORDER BY MIN(C3);
SELECT DISTINCT MIN(C2) FROM T GROUP BY C1 ORDER BY MIN(C2);
SELECT DISTINCT C1, MIN(C2) FROM T GROUP BY C1 ORDER BY MIN(C3);
</pre><p> (1) is a random-order query, (2) and (3) are not. MySQL has traditionally been permissive, we want to allow (2) and (3).</p>
<p class="">So the second rule is that Check_distinct rejects a query if it has DISTINCT and a set function in ORDER BY which is not the same expression as one in the SELECT list. This rejects (1) and allows (2). It would reject (3); luckily, before Check_distinct checks, DISTINCT is removed (it is redundant with GROUP BY) and thus the query is not processed by Check_distinct; the second rule is thus by-passed and (3) is correctly accepted.</p>
<p class="">The implementation of Check_distinct works like this: if the query has DISTINCT, examine each element of the ORDER BY list: if the element is not the same expression as one in the SELECT list, then examine parts of the element (using <a class="el" href="classItem.html#ab7d2529511c14a77e59a1b1bbabc95d7">Item::walk()</a>), to spot offending set functions or columns.</p>
<h1><a class="anchor" id="IMPLICIT_GROUPING"></a>
Implicit grouping</h1>
<p class="">A query with set functions without GROUP BY can be seen as having GROUP BY() i.e. the set of grouping expressions is empty, all rows are part of a single group and are replaced with a single row. So it is just a sub-case of the next section.</p>
<h1><a class="anchor" id="EXPLICIT_GROUPING"></a>
Explicit grouping (GROUP BY)</h1>
<p class="">MySQL is more permissive than the standard, it allows to group by any expression; it does not require that every element of the GROUP BY clause should be a column of one table of the FROM clause.</p>
<p class="">Here is a problematic query, using a table T with columns C1, C2, C3: </p><pre class="fragment">C1 C2 C3
1  2  A
3  4  B
1  2  C

SELECT C1, C3 FROM T GROUP BY C1;
</pre><p> we first form groups, in each group the value of C1 must be the same for all rows. Consider the group made of the first and third row. We have to produce one row out of it, and this row must have a value for C3 because C3 is in the SELECT list. Among those two rows, which value of C3 should we choose? This is arbitrary, and will give a random result.</p>
<p class="">To prevent this, in a query with GROUP BY or aggregates (known as "a grouped
query"), any column referenced by an expression in the SELECT list or HAVING condition and belonging to one table of the FROM clause, should be one of the group columns (enforced by only_full_group_by in MySQL 5.6 and older) or, if functional dependencies are supported (as in MySQL 5.7), should be functionally dependent on the group columns. In the table T above, C3 is obviously not functionally dependent on {C1,C2}: the values of C1 and C2 for a row do not uniquely determine the value of C3. In other words, if two rows have the same value in C1 and the same value in C2 they do not necessarily have the same value in C3. So this rule correctly rejects the query above.</p>
<p class="">Note that NULL is treated as one value: two NULLs are considered equal.</p>
<p class="">In WL#2489, we have implemented the optional standard feature T301 "functional dependencies" almost entirely.</p>
<p class="">Here are the functional dependencies which we recognize.</p>
<h2><a class="anchor" id="KEYFD"></a>
Key-based, in a base table</h2>
<p class="">A key in this text is a unique constraint made of only non-NULLable columns. For example, a primary key. Considering a base table T, if two rows have the same values of all columns of a key of T they are actually one single row, so: { all columns of key} -&gt; { T.* } (notation: what is on the right of the arrow is functionally dependent on what is on the left).</p>
<h2><a class="anchor" id="GCOLFD"></a>
Generated-column-based, in a base table</h2>
<p class="">Considering a base table T, a generated column is functionally dependent on the set of columns it references (the so-called parametric columns). Note that the SQL standard doesn't allow a parametric column to be a generated column, but MySQL does.</p>
<h2><a class="anchor" id="INNEREQ"></a>
Equality-based, in the result of an inner join</h2>
<p class="">Considering two tables T1 and T2, a condition C, and the result R of an inner join T1 <a class="el" href="classJOIN.html">JOIN</a> T2 ON C. Note that T1/T2 are not necessarily base tables. For example, they can also be views, or derived tables, or the results of some joins; in the rest of text, we use the vague term "table" for those various objects.</p>
<p class="">Note that C may only refer to columns of T1 or T2 (outer references are forbidden by MySQL in join conditions).</p>
<p class="">Assuming that C is a conjunction (i.e. is made of one or more conditions, "conjuncts", chained together with AND):</p><ul>
<li>If one conjunct is of the form T1.A=constant, then {} -&gt; {A} holds in R (the value of A is "the constant" in all rows of R).</li>
<li>If one conjunct is of the form T1.A=T2.B, then {T1.A} -&gt; {T2.B} (and vice versa) holds in R (the value of T2.B is that of T1.A in all rows of R).</li>
</ul>
<h2><a class="anchor" id="OUTEREQ"></a>
Equality-based, in the result of an outer join</h2>
<p class="">Considering the result R of TS LEFT <a class="el" href="classJOIN.html">JOIN</a> TW ON C. Assuming that C is a conjunction. TS is said to be the strong table, TW is said to be the weak table (the one which might be NULL-complemented in the result of this join). To make this really clear, note that, if we have "t1 left join (t2 left join t3 on C) on D":</p><ul>
<li>in the t2-t3 join, t2 is strong and t3 is weak.</li>
<li>in the t1-(t2-t3) join, t1 is strong, t2 is weak, t3 is weak.</li>
</ul>
<p class="">If C is deterministic and one conjunct is of the form TW.A=constant or TW.A=TS.B, then DJS -&gt; {TW.A} holds in R, where DJS is the set of all columns of TS referenced by C. Proof: consider in R two rows r1 and r2 which have the same values of DJS columns. Consider r1. There are two possibilities when r1 was built from a row of TS:</p><ul>
<li>no row in TW matched the row of TS (for no row of TW has C been true): so, r1 is NULL-complemented for the columns of TW. Given that r2 has the same values of DJS columns as r1, and given that C is deterministic, it is sure that no row in TW matched when r2 was built. So r2 is also NULL-complemented for the columns of TW. So r1 and r2 have the same value of TW.A (NULL).</li>
<li>At least one row in TW matched: so, r1 contains real values from TW (not NULL-complemented), matching C, and thus TW.A in r1 is equal to the constant or to TS.B. Following the same reasoning as above, it is sure that it is also the case for r2.</li>
<li>In conclusion, we can see that r1 and r2 always have the same value of TW.A.</li>
</ul>
<p class="">If one conjunct is of the form TW.A=TW.B then {TW.A} -&gt; {TW.B} holds in R Proof: consider r1 and r2 two rows in R having the same value of TW.A. Two cases are possible:</p><ul>
<li>this value is NULL. Then both rows are NULL-complemented (if not, the value of TW.A in TW would be NULL, which cannot match in an equality, so C is not true, which is absurd). Thus, in r1 and r2 TW.B is NULL.</li>
<li>This value is not NULL. Then both rows are not NULL-complemented, C matched for both, so TW.B in r1/r2 is equal to TW.A in r1/r2.</li>
<li>In conclusion, r1 and r2 have the same value of TW.B.</li>
</ul>
<h2><a class="anchor" id="WHEREEQ"></a>
Equality-based, in the result of a WHERE clause</h2>
<p class="">Same rule as the result of an inner join. Additionally, the rule is extended to T1.A=outer_reference, because an outer reference is a constant during one execution of this query.</p>
<p class="">Below we examine how functional dependencies in a table propagate to its containing join nest.</p>
<h2><a class="anchor" id="PROPAGOUTER"></a>
Considering the result R of TS LEFT JOIN TW ON C.</h2>
<p class="">All functional dependencies in TS are also functional dependencies in R. Proof: trivial. The same is not necessarily true for TW. Let's define a "NULL-friendly functional dependency" (NFFD) as a functional dependency between two sets A and B, which has two properties:</p><ul>
<li>A is not empty</li>
<li>if, in a row, all values of A are NULL, then all values of B are NULL.</li>
</ul>
<p class="">All NFFDs in TW are also NFFDs in R. Proof: consider an NFFD A -&gt; B in TW, and r1 and r2 two rows in R having the same values of A columns. Two cases are possible:</p><ul>
<li>In r1 and r2, at least one value of A is not NULL. Then r1 is not NULL-complemented. Its values for A and B come from TW. By application of the functional dependency in TW, because values in A are equal in TW, values in B are equal in TW and thus in r1/r2.</li>
<li>In r1 and r2, all values of A are NULL. Two cases are possible: i) r1 is not NULL-complemented. Its values for A and B come from TW. In the row of TW values of A are all NULL. Because the functional dependency in NULL-friendly, all values of B are NULL in the row of TW and thus in r1. ii) r1 is NULL-complemented. Then all values of B in r1 are NULL. iii) In conclusion, all values of B in r1 are NULL. The same reasoning applies to r2. So, values of B are identical (NULL) in r1 and r2.</li>
<li>In conclusion, values of B are identical in r1/r2, we have proved that this is a functional dependency in R, and a NULL-friendly one.</li>
</ul>
<p class="">The concept of an NFFD is Guilhem's invention. It was felt it was necessary, to have easy propagation of FDs from TW to R. It was preferred to the alternative, simpler rule which says that a functional dependency A-&gt; B in TW is also a functional dependency in R if A contains a non-nullable column. There are two points to note:</p><ul>
<li>the functional dependency of the simpler rule is an NFFD, so our rule is not more restrictive than the simpler one</li>
<li>this simpler rule prevents free propagation of functional dependencies through join nests, which complicates implementation and leads to rejecting queries which could be accepted. An example follows: <pre class="fragment">SELECT T3.A
FROM T1 LEFT JOIN (T2 LEFT JOIN T3 ON  TRUE) ON  TRUE
GROUP BY T3.PK;
</pre> This is what the simpler rule says for this query: In T3, T3.PK-&gt;T3.A holds. Let R1 be the result of "(T2 LEFT JOIN T3 ON TRUE)", in R1 T3.PK-&gt;T3.A holds, by application of: there is a functional dependency in the weak side T3, and T3.PK is not nullable in T3. Let R2 be the result of "T1 LEFT JOIN (T2 LEFT JOIN T3 ON TRUE) ON TRUE", in R2 T3.PK-&gt;T3.A doesn't hold anymore, because: it's a dependency in the weak side (weak side is R1 here), and T3.PK is nullable <em>when seen as a column of R1</em> (in R1 T3.PK can be NULL, if the row of T3 is actually a NULL-complemented one).</li>
</ul>
<h2><a class="anchor" id="PROPAGINNER"></a>
Considering the result R of T1 JOIN T2 ON C.</h2>
<p class="">All [NULL-friendly] functional dependencies in T1 are also [NULL-friendly] functional dependencies in R. the same is true for T2. Proof: trivial.</p>
<h2><a class="anchor" id="PROPAGSUMMARY"></a>
Summary rules for propagating FDs</h2>
<p class="">All NULL-friendly functional dependencies propagate freely through join nests all the way up to the result of the WHERE clause. The same is true for ordinary functional dependencies except if there are weak tables along the propagation path between the table where the dependency holds and the result of the WHERE clause; in other words, except if the table where the dependency holds belongs to some embedding join nest which is on the weak side of an outer join.</p>
<h2><a class="anchor" id="NFFDS"></a>
Which functional dependencies are NULL-friendly</h2>
<p class="">A key-based functional dependency A -&gt; B in the base table is NULL-friendly, because, by definition, there can never be a NULL value in any column of A.</p>
<p class="">A functional dependency A -&gt; B in a base table, between parametric columns A and a generated column B, is not NULL-friendly; for more details, see <a class="el" href="group__AGGREGATE__CHECKS.html#FDVIEW">Functional dependencies in a view or a derived table</a> .</p>
<p class="">A functional dependency A-&gt;B in the result of T1 <a class="el" href="classJOIN.html">JOIN</a> T2 ON C, if based on equality of two columns, is NULL-friendly. Indeed, A is not empty and if there was some NULL in A, it would not match the equality in C and thus it would not exist in the result, absurd. If the equality is rather column=constant, A is empty, the dependency is not NULL-friendly. However, in our implementation, function <code>simplify_joins()</code> moves inner-join conditions to the embedding outer-join nest's join condition, or to the WHERE clause. Because our analysis of functional dependencies happens after simplify_joins(), when we analyze T1 <a class="el" href="classJOIN.html">JOIN</a> T2 it is guaranteed to have no condition, and this paragraph is irrelevant.</p>
<p class="">A functional dependency in the result of TS LEFT <a class="el" href="classJOIN.html">JOIN</a> TW ON C, if based on equality of two columns, is NULL-friendly. Proof: let's consider, in turn, the two types of equality-based functional dependencies which exist in this result R. Let r1 be a row of R.</p><ul>
<li>If C is deterministic and one conjunct is of the form TW.A=constant or TW.A=TS.B, then DJS -&gt; {TW.A} holds in R, where DJS is the set of all columns of TS referenced by C. For NULL-friendliness, we need DJS to not be empty. Thus, we exclude the form TW.A= constant and consider only TW.A=TS.B. We suppose that in r1 DJS contains all NULLs. Conjunct is TW.A=TS.B then this equality is not true, so r1 is NULL-complemented: TW.A is NULL in r1.</li>
<li>If one conjunct is of the form TW.A=TW.B then {TW.A} -&gt; {TW.B} holds in R. If in r1 TW.A is NULL, again the equality in C is not true, and TW.B is NULL in R1.</li>
<li>In conclusion, this is NULL-friendly.</li>
</ul>
<p class="">A functional dependency in the result of a WHERE clause, if based on equality of two columns, is NULL-friendly. If based on T1.A=constant, it is not, as it has an empty set of source columns.</p>
<p class="">Summary: all functional dependencies which we have seen so far are NULL-friendly, except those inferred from TW.A=constant in an outer join condition or in a WHERE clause, and those about generated columns.</p>
<p class="">Thus, in the query with T1-T2-T3 previously seen, T3.PK-&gt;T3.A is NULL-friendly and propagates, query is accepted.</p>
<p class="">In our implementation, we take special care of TW.A=constant in an outer join condition: we infer a functional dependency DJS-&gt;TW.A from such equality only if one of these requirements are met:</p><ul>
<li>the join nest "TS LEFT JOIN TW ON TW.A=constant [AND...]" is not on the weak side of any embedding join nest - in that case, propagation will not meet any weak tables so we do not need the dependency to be NULL-friendly, it will propagate anyway.</li>
<li>DJS contains at least one column from a strong-side table which, if NULL, makes the join condition not evaluate to TRUE - in that case, DJS-&gt;TW.A is NULL-friendly.</li>
</ul>
<p class="">Either of these two conditions is satisfied in most practical cases. For example, it's very common to have an equality between a strong-side column and a weak-side column as a conjunct in the outer join condition (like, "ON
strong.pk = weak.foreign_key AND ..." or "ON strong.foreign_key = weak.pk AND
..."); this satisfies the second condition. It's also common to have outer joins only left-deep ("SELECT ... T1 LEFT JOIN T2 ON ... LEFT JOIN T3 ON ..." is left-deep); this satisfies the first condition. Note that the dependency found from TW.A=TS.B in an outer join condition always satisfies the second condition.</p>
<p class="">T1.A=constant in a WHERE clause is exterior to any join nest so does not need to propagate, so does not need to be NULL-friendly.</p>
<h2><a class="anchor" id="FDVIEW"></a>
Functional dependencies in a view or a derived table</h2>
<p class="">In the rest of this text, we will use the term "view" for "view or derived
table". A view can be merged or materialized, in MySQL. Consider a view V defined by a query expression. If the query expression contains UNION or ROLLUP (which is based on UNION) there are no functional dependencies in this view. So let's assume that the query expression is a query specification (let's note it VS): </p><pre class="fragment">CREATE VIEW V AS SELECT [DISTINCT] VE1 AS C1, VE2 AS C2, ... FROM ... WHERE ... [GROUP BY ...] [HAVING ...] [ORDER BY ...]
</pre><p class="">If {VE1, VE2, VE3} are columns of tables of the FROM clause, and {VE1, VE2} -&gt; {VE3} has been deduced from rules in the previous sections [and is NULL-friendly], then {C1, C2} -&gt; { C3 } holds in the view [and is NULL-friendly].</p>
<p class="">If {VE1, VE2} are columns of tables of the FROM clause, and VE3 is a deterministic expression depending only on VE1 and VE2, then {C1, C2} -&gt; { C3 } in the view. It is not always NULL-friendly, for example: VE3 could be COALESCE(VE1,VE2,3): if VE1 (C1) and VE2 (C2) are NULL, VE3 (C3) is 3: not NULL. Another example: VE3 could be a literal; {}-&gt;{C3}, the left set is empty. The same examples apply to a generated column in a base table - it is like a merged view's expression. For example, in a base table T which has a generated column C3 AS COALESCE(C1,C2,3): {C1, C2} -&gt; { C3 } holds in T but is not NULL-friendly.</p>
<p class="">If VS is a grouped query (which, in MySQL, implies that the view is materialized), then in the result of the grouping there is a functional dependency from the set of all group expressions to the set of all selected expressions (otherwise, this query expression would not have passed its own only_full_group_by validation - in the implementation we validate each query expression separately). Thus, if all group expressions of VS are in the select list of VS, for example they are VE1 and VE2, then {C1, C2} -&gt; {V.*}. It is not NULL-friendly, for example: VE3 is COUNT(1): if the result of the WHERE clause contains a row with group expressions VE1 and VE2 equal to NULL, VE3 is not NULL.</p>
<p class="">It's possible to infer functional dependencies from equality conditions in HAVING, but we have not implemented it yet.</p>
<p class="">Because some functional dependencies above are not NULL-friendly, they exist in the view, but may not freely propagate in the result of join nests containing the view. This includes examples just given in paragraphs above, and the case of T1.A=constant in the WHERE clause of VS.</p>
<p class="">Thus, when we know of a functional dependency A -&gt; B in the query expression of a view, we deduce from it a functional dependency in the view only if:</p><ul>
<li>this view is not on the weak side of any embedding join nest (so NULL-friendliness is not required for propagation).</li>
<li>or A contains at least one non-nullable expression, which makes A -&gt; B NULL-friendly.</li>
</ul>
<p class="">The above is fine for materialized views. For merged views, we cannot study the query expression of the view, it has been merged (and scattered), so we use a different rule:</p><ul>
<li>a merged view is similar to a join nest inserted in the parent query, so for dependencies based on keys or join conditions, we simply follow propagation rules of the non-view sections.</li>
<li>For expression-based dependencies (VE3 depends on VE1 and VE2, VE3 belonging to the view SELECT list), which may not be NULL-friendly, we require</li>
<li>the same non-weak-side criterion as above</li>
<li>or that the left set of the dependency be non-empty and that if VE1 and VE2 are NULL then VE3 must be NULL, which makes the dependency NULL-friendly.</li>
<li>The same solution is used for generated columns in a base table.</li>
</ul>
<h1><a class="anchor" id="USED_TABLES"></a>
Implementation note: used_tables_for_level() vs used_tables()</h1>
<ul>
<li>When we are looking for items to validate, we must enter scalar/row subqueries; if we find an item of our SELECT_LEX inside such subquery, for example an <a class="el" href="classItem__field.html">Item_field</a> with depended_from equal to our SELECT_LEX, we must use used_tables_for_level(). Example: when validating t1.a in select (select t1.a from t1 as t2 limit 1) from t1 group by t1.pk; we need t1.a's map in the grouped query; used_tables() would return OUTER_REF_TABLE_BIT.</li>
<li>When we are searching for FDs in PKs, or join conditions, or the GROUP BY clause, we do not enter scalar/row subqueries, so we use used_tables(). Example: select ... from t1 where t1.a=(subq) from t1 group by ... the subq is not used to discover FDs in the grouped query. Or: select (select t2.a from t1 as t2 where t2.a=t1.a group by t2.b) from t1 when validating the subq, t1.a is an outer reference, kind of a constant, so tells us that t2.a is FD on {} ; using used_tables_for_level() on t1.a would be nonsense - we are validating the subquery. </li>
</ul>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga69e57fec296941e565db230b184262ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69e57fec296941e565db230b184262ec">&#9670;&nbsp;</a></span>FORBID_COPY_CTOR_AND_ASSIGN_OP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FORBID_COPY_CTOR_AND_ASSIGN_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">myclass</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">myclass(myclass <span class="keyword">const</span> &amp;);                     \</div><div class="line">  void operator=(myclass <span class="keyword">const</span> &amp;)</div></div><!-- fragment --><p class="">Re-usable shortcut, when it does not make sense to do copy objects of a class named "myclass"; add this to a private section of the class. The implementations are intentionally not created, so if someone tries to use them like in "myclass A= B" there will be a linker error. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga83e75b415b78e10ade375ad320ea446c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e75b415b78e10ade375ad320ea446c">&#9670;&nbsp;</a></span>check_query() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Distinct_check::check_query </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Rejects the query if it has a combination of DISTINCT and ORDER BY which could lead to randomly ordered results. More precisely: if, in a query block 'sl', an ORDER BY expression</p><ul>
<li>is not the same expression as one in the SELECT list of 'sl' (1)</li>
<li>and contains a column which: &ndash; is of a table whose qualifying query block is 'sl' (2) &ndash; and is not in the SELECT list of 'sl' (3) then 'sl' should not have DISTINCT.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if rejected (my_error() is called) </dd></dl>

</div>
</div>
<a id="ga85f98a122e6f9accf528534acb5db686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85f98a122e6f9accf528534acb5db686">&#9670;&nbsp;</a></span>check_query() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Group_check::check_query </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Rejects the query if it does aggregation or grouping, and expressions in its SELECT list, ORDER BY clause, or HAVING condition, may vary inside a group (are not "group-invariant"). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
