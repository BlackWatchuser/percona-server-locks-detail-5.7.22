<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Mts_submode_logical_clock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classMts__submode__logical__clock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mts_submode_logical_clock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="rpl__mts__submode_8h_source.html">rpl_mts_submode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Mts_submode_logical_clock:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMts__submode__logical__clock.png" usemap="#Mts_5Fsubmode_5Flogical_5Fclock_map" alt=""/>
  <map id="Mts_5Fsubmode_5Flogical_5Fclock_map" name="Mts_5Fsubmode_5Flogical_5Fclock_map">
<area href="classMts__submode.html" alt="Mts_submode" shape="rect" coords="0,0,170,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e2a78af961009a44eacddd88b0f517f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#a7e2a78af961009a44eacddd88b0f517f">schedule_next_event</a> (<a class="el" href="classRelay__log__info.html">Relay_log_info</a> *rli, <a class="el" href="classLog__event.html">Log_event</a> *ev)</td></tr>
<tr class="separator:a7e2a78af961009a44eacddd88b0f517f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d00eee05c4badebc630d80f0208fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#a611d00eee05c4badebc630d80f0208fb">attach_temp_tables</a> (THD *thd, const <a class="el" href="classRelay__log__info.html">Relay_log_info</a> *rli, <a class="el" href="classQuery__log__event.html">Query_log_event</a> *ev)</td></tr>
<tr class="separator:a611d00eee05c4badebc630d80f0208fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cff354bc8566687d40530c2cc430128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#a0cff354bc8566687d40530c2cc430128">detach_temp_tables</a> (THD *thd, const <a class="el" href="classRelay__log__info.html">Relay_log_info</a> *rli, <a class="el" href="classQuery__log__event.html">Query_log_event</a> *ev)</td></tr>
<tr class="separator:a0cff354bc8566687d40530c2cc430128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcd334c4225b2cabdcd42a9e4179071"><td class="memItemLeft" align="right" valign="top">Slave_worker *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#a2fcd334c4225b2cabdcd42a9e4179071">get_least_occupied_worker</a> (<a class="el" href="classRelay__log__info.html">Relay_log_info</a> *rli, Slave_worker_array *ws, <a class="el" href="classLog__event.html">Log_event</a> *ev)</td></tr>
<tr class="separator:a2fcd334c4225b2cabdcd42a9e4179071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb83dbd9dd69537395bfe08dc5b97bc6"><td class="memItemLeft" align="right" valign="top"><a id="acb83dbd9dd69537395bfe08dc5b97bc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>start_new_group</b> ()</td></tr>
<tr class="separator:acb83dbd9dd69537395bfe08dc5b97bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f42bc5a3528849c24ffd45b8b25aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#ab1f42bc5a3528849c24ffd45b8b25aca">withdraw_delegated_job</a> ()</td></tr>
<tr class="separator:ab1f42bc5a3528849c24ffd45b8b25aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c1ed46ea9c55f1c4a40cda0c81aa41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#ad7c1ed46ea9c55f1c4a40cda0c81aa41">wait_for_workers_to_finish</a> (<a class="el" href="classRelay__log__info.html">Relay_log_info</a> *rli, Slave_worker *ignore=NULL)</td></tr>
<tr class="separator:ad7c1ed46ea9c55f1c4a40cda0c81aa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f58da5b0597884a11feccf25f3cdc96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#a6f58da5b0597884a11feccf25f3cdc96">wait_for_last_committed_trx</a> (<a class="el" href="classRelay__log__info.html">Relay_log_info</a> *rli, longlong last_committed_arg, longlong lwm_estimate_arg)</td></tr>
<tr class="separator:a6f58da5b0597884a11feccf25f3cdc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91a392c2d94d6e6045f0ca8f1cbfa00"><td class="memItemLeft" align="right" valign="top">longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#ac91a392c2d94d6e6045f0ca8f1cbfa00">get_lwm_timestamp</a> (<a class="el" href="classRelay__log__info.html">Relay_log_info</a> *rli, bool need_lock)</td></tr>
<tr class="separator:ac91a392c2d94d6e6045f0ca8f1cbfa00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b02848ef72e31334a02a3df9854680f"><td class="memItemLeft" align="right" valign="top"><a id="a8b02848ef72e31334a02a3df9854680f"></a>
longlong&#160;</td><td class="memItemRight" valign="bottom"><b>estimate_lwm_timestamp</b> ()</td></tr>
<tr class="separator:a8b02848ef72e31334a02a3df9854680f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classMts__submode"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classMts__submode')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classMts__submode.html">Mts_submode</a></td></tr>
<tr class="memitem:a8669d5047ddf9668c5d6d5d6977cb371 inherit pub_methods_classMts__submode"><td class="memItemLeft" align="right" valign="top"><a id="a8669d5047ddf9668c5d6d5d6977cb371"></a>
enum_mts_parallel_type&#160;</td><td class="memItemRight" valign="bottom"><b>get_type</b> ()</td></tr>
<tr class="separator:a8669d5047ddf9668c5d6d5d6977cb371 inherit pub_methods_classMts__submode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a864989cdf17ff4a696b4f74dd8a00c1d"><td class="memItemLeft" align="right" valign="top"><a id="a864989cdf17ff4a696b4f74dd8a00c1d"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>clock_leq</b> (longlong a, longlong b)</td></tr>
<tr class="separator:a864989cdf17ff4a696b4f74dd8a00c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a691eb2ea538782d6dada60468d28cb0a"><td class="memItemLeft" align="right" valign="top"><a id="a691eb2ea538782d6dada60468d28cb0a"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>jobs_done</b></td></tr>
<tr class="separator:a691eb2ea538782d6dada60468d28cb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f1fd1935a78bbd7dac021de2354ea7"><td class="memItemLeft" align="right" valign="top"><a id="a62f1fd1935a78bbd7dac021de2354ea7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_error</b></td></tr>
<tr class="separator:a62f1fd1935a78bbd7dac021de2354ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4959abc53705fc3a371747de15f254a3"><td class="memItemLeft" align="right" valign="top"><a id="a4959abc53705fc3a371747de15f254a3"></a>
longlong&#160;</td><td class="memItemRight" valign="bottom"><b>min_waited_timestamp</b></td></tr>
<tr class="separator:a4959abc53705fc3a371747de15f254a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a744169bad4e3ea03a15e62ba4e24492b"><td class="memItemLeft" align="right" valign="top"><a id="a744169bad4e3ea03a15e62ba4e24492b"></a>
static const ulong&#160;</td><td class="memItemRight" valign="bottom"><b>INDEX_UNDEF</b> = (ulong) -1</td></tr>
<tr class="separator:a744169bad4e3ea03a15e62ba4e24492b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac75e4dcd258a79d3c4eb03ab0bf0ad02"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint, my_thread_id &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#ac75e4dcd258a79d3c4eb03ab0bf0ad02">get_server_and_thread_id</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ac75e4dcd258a79d3c4eb03ab0bf0ad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093957d2566da47579792a82f499e147"><td class="memItemLeft" align="right" valign="top">Slave_worker *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMts__submode__logical__clock.html#a093957d2566da47579792a82f499e147">get_free_worker</a> (<a class="el" href="classRelay__log__info.html">Relay_log_info</a> *rli)</td></tr>
<tr class="separator:a093957d2566da47579792a82f499e147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classMts__submode"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classMts__submode')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classMts__submode.html">Mts_submode</a></td></tr>
<tr class="memitem:a463807bdef1fea15c6bd7653b1e420ce inherit pro_attribs_classMts__submode"><td class="memItemLeft" align="right" valign="top"><a id="a463807bdef1fea15c6bd7653b1e420ce"></a>
enum_mts_parallel_type&#160;</td><td class="memItemRight" valign="bottom"><b>type</b></td></tr>
<tr class="separator:a463807bdef1fea15c6bd7653b1e420ce inherit pro_attribs_classMts__submode"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">Parallelization using Master parallelization information For significance of each method check definition of <a class="el" href="classMts__submode.html">Mts_submode</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a611d00eee05c4badebc630d80f0208fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611d00eee05c4badebc630d80f0208fb">&#9670;&nbsp;</a></span>attach_temp_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mts_submode_logical_clock::attach_temp_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRelay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__log__event.html">Query_log_event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Logic to attach the temporary tables from the worker threads upon event execution </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>thd THD instance rli <a class="el" href="classRelay__log__info.html">Relay_log_info</a> instance ev <a class="el" href="classQuery__log__event.html">Query_log_event</a> that is being applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: void </dd></dl>

<p>Implements <a class="el" href="classMts__submode.html">Mts_submode</a>.</p>

</div>
</div>
<a id="a0cff354bc8566687d40530c2cc430128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cff354bc8566687d40530c2cc430128">&#9670;&nbsp;</a></span>detach_temp_tables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mts_submode_logical_clock::detach_temp_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRelay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuery__log__event.html">Query_log_event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Logic to detach the temporary tables from the worker threads upon event execution </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>thd THD instance rli <a class="el" href="classRelay__log__info.html">Relay_log_info</a> instance ev <a class="el" href="classQuery__log__event.html">Query_log_event</a> that is being applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: void </dd></dl>

<p>Implements <a class="el" href="classMts__submode.html">Mts_submode</a>.</p>

</div>
</div>
<a id="a093957d2566da47579792a82f499e147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093957d2566da47579792a82f499e147">&#9670;&nbsp;</a></span>get_free_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slave_worker * Mts_submode_logical_clock::get_free_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRelay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Protected method to fetch a worker having no events assigned. The method is supposed to be called by Coordinator, therefore comparison like w_i-&gt;jobs.len == 0 must (eventually) succeed.</p>
<p class="">todo: consider to optimize scan that is getting more expensive with more # of Workers.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to Worker or NULL if none is free. </dd></dl>

</div>
</div>
<a id="a2fcd334c4225b2cabdcd42a9e4179071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcd334c4225b2cabdcd42a9e4179071">&#9670;&nbsp;</a></span>get_least_occupied_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Slave_worker * Mts_submode_logical_clock::get_least_occupied_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRelay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slave_worker_array *&#160;</td>
          <td class="paramname"><em>ws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLog__event.html">Log_event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Logic to get least occupied worker when the sql mts_submode= master_parallel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rli</td><td>relay log info of coordinator ws arrayy of worker threads ev event for which we are searching for a worker. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>slave worker thread or NULL when coordinator is killed by any worker. </dd></dl>

<p>Implements <a class="el" href="classMts__submode.html">Mts_submode</a>.</p>

</div>
</div>
<a id="ac91a392c2d94d6e6045f0ca8f1cbfa00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91a392c2d94d6e6045f0ca8f1cbfa00">&#9670;&nbsp;</a></span>get_lwm_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">longlong Mts_submode_logical_clock::get_lwm_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRelay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>need_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The method finds the minimum logical timestamp (low-water-mark) of committed transactions. The successful search results in a pair of a logical timestamp value and a GAQ index that contains it. last_lwm_timestamp may still be raised though the search does not find any satisfying running index. Search is implemented as headway scanning of GAQ from a point of a previous search's stop position (last_lwm_index). Whether the cached (memorized) index value is considered to be stale when its timestamp gets less than the current "stable" LWM: </p><pre class="fragment"> last_lwm_timestamp &lt;= GAQ.lwm.sequence_number           (*)
</pre><p class="">Staleness is caused by GAQ garbage collection that increments the rhs of (*), see ::move_queue_head(). When that's diagnozed, the search in GAQ needs restarting from the queue tail.</p>
<p class="">Formally, the undefined cached value of last_lwm_timestamp is also stale. </p><pre class="fragment">       the last time index containg lwm
           +------+
           | LWM  |
           |  |   |
           V  V   V
</pre><p> GAQ: xoooooxxxxxXXXXX...X ^ ^ | | LWM+1 | +- tne new current_lwm</p>
<p class="">&lt;-&mdash; logical (commit) time -&mdash;</p>
<p class="">here &lsquo;x&rsquo; stands for committed, &lsquo;X&rsquo; for committed and discarded from the running range of the queue, &lsquo;o&rsquo; for not committed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rli</td><td><a class="el" href="classRelay__log__info.html">Relay_log_info</a> pointer </td></tr>
    <tr><td class="paramname">need_look</td><td>Either the caller or the function must hold a mutex to avoid race with concurrent GAQ update.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>possibly updated current_lwm </dd></dl>

</div>
</div>
<a id="ac75e4dcd258a79d3c4eb03ab0bf0ad02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75e4dcd258a79d3c4eb03ab0bf0ad02">&#9670;&nbsp;</a></span>get_server_and_thread_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint, my_thread_id &gt; Mts_submode_logical_clock::get_server_and_thread_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Protected method to fetch the server_id and pseudo_thread_id from a temporary table </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>instance pointer of <a class="el" href="structTABLE.html">TABLE</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: std:pair&lt;uint, my_thread_id&gt;  : It is the caller's responsibility to make sure we call this function only for temp tables. </dd></dl>

</div>
</div>
<a id="a7e2a78af961009a44eacddd88b0f517f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2a78af961009a44eacddd88b0f517f">&#9670;&nbsp;</a></span>schedule_next_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Mts_submode_logical_clock::schedule_next_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRelay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLog__event.html">Log_event</a> *&#160;</td>
          <td class="paramname"><em>ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Does necessary arrangement before scheduling next event. The method computes the meta-group status of the being scheduled transaction represented by the event argument. When the status is found OUT (of the current meta-group) as encoded as is_new_group == true the global Scheduler (Coordinator thread) requests full synchronization with all Workers. The current being assigned group descriptor gets associated with the group's logical timestamp aka sequence_number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>Relay_log_info* rli <a class="el" href="classLog__event.html">Log_event</a> *ev </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: ER_MTS_CANT_PARALLEL, ER_MTS_INCONSISTENT_DATA 0 if no error or slave has been killed gracefully </dd></dl>

<p>Implements <a class="el" href="classMts__submode.html">Mts_submode</a>.</p>

</div>
</div>
<a id="a6f58da5b0597884a11feccf25f3cdc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f58da5b0597884a11feccf25f3cdc96">&#9670;&nbsp;</a></span>wait_for_last_committed_trx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Mts_submode_logical_clock::wait_for_last_committed_trx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRelay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">longlong&#160;</td>
          <td class="paramname"><em>last_committed_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">longlong&#160;</td>
          <td class="paramname"><em>lwm_estimate_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The method implements logical timestamp conflict detection and resolution through waiting by the calling thread. The conflict or waiting condition is like the following </p><pre class="fragment">    lwm &lt; last_committed,
</pre><p class="">where lwm is a minimum logical timestamp of committed transactions. Since the lwm's exact value is not always available its pessimistic estimate (an old version) is improved (<a class="el" href="classMts__submode__logical__clock.html#ac91a392c2d94d6e6045f0ca8f1cbfa00">get_lwm_timestamp()</a>) as the first step before to the actual waiting commitment.</p>
<p class="">Special cases include:</p>
<p class="">When <code>last_committed_arg</code> is uninitialized the calling thread must proceed without waiting for anyone. Any possible dependency with unknown commit parent transaction shall be sorted out by the parent;</p>
<p class="">When the gaq index is subsequent to the last lwm index there's no dependency of the current transaction with any regardless of lwm timestamp should it be SEQ_UNINIT. Consequently when GAQ consists of just one item there's none to wait. Such latter case is left to the caller to handle.</p>
<dl class="section note"><dt>Note</dt><dd>The caller must make sure the current transaction won't be waiting for itself. That is the method should not be caller by a Worker whose group assignment is in the GAQ front item.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_committed_arg</td><td>logical timestamp of a parent transaction </td></tr>
    <tr><td class="paramname">gaq_index</td><td>Index of the current transaction in GAQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false as success, true when the error flag is raised or the caller thread is found killed. </dd></dl>

</div>
</div>
<a id="ad7c1ed46ea9c55f1c4a40cda0c81aa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c1ed46ea9c55f1c4a40cda0c81aa41">&#9670;&nbsp;</a></span>wait_for_workers_to_finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Mts_submode_logical_clock::wait_for_workers_to_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRelay__log__info.html">Relay_log_info</a> *&#160;</td>
          <td class="paramname"><em>rli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Slave_worker *&#160;</td>
          <td class="paramname"><em>ignore</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Waits for slave workers to finish off the pending tasks before returning. Used in this submode to make sure that all assigned jobs have been done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Relay_log</td><td>info *rli coordinator rli. </td></tr>
    <tr><td class="paramname">Slave</td><td>worker to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 for error. 0 no error. </dd></dl>

<p>Implements <a class="el" href="classMts__submode.html">Mts_submode</a>.</p>

</div>
</div>
<a id="ab1f42bc5a3528849c24ffd45b8b25aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f42bc5a3528849c24ffd45b8b25aca">&#9670;&nbsp;</a></span>withdraw_delegated_job()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mts_submode_logical_clock::withdraw_delegated_job </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Withdraw the delegated_job increased by the group. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="rpl__mts__submode_8h_source.html">rpl_mts_submode.h</a></li>
<li>rpl_mts_submode.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
