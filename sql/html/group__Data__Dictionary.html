<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Data Dictionary</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Data Dictionary</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__deadlock__handler.html">MDL_deadlock_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__deadlock__discovery__repair__handler.html">MDL_deadlock_discovery_repair_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOr__node.html">Or_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAnd__node.html">And_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTable__node.html">Table_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConst__ordered__table__node.html">Const_ordered_table_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJoin__node.html">Join_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae383b8742be40b62c710380f1b5e6a6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae383b8742be40b62c710380f1b5e6a6e">UNDER_LTM</a>(thd)</td></tr>
<tr class="separator:gae383b8742be40b62c710380f1b5e6a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga176a646a5a04af4bf68c0f149af5dd00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>BELONGS_TO_P_S_UNDER_LTM</b>(thd,  tl)</td></tr>
<tr class="separator:ga176a646a5a04af4bf68c0f149af5dd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9103f1fde040b45e171c6df146d812f1"><td class="memItemLeft" align="right" valign="top"><a id="ga9103f1fde040b45e171c6df146d812f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WRONG_GRANT</b>&#160;&#160;&#160;(<a class="el" href="classField.html">Field</a>*) -1</td></tr>
<tr class="separator:ga9103f1fde040b45e171c6df146d812f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga18d16049867f49eea9781f2593b9ce5a"><td class="memItemLeft" align="right" valign="top"><a id="ga18d16049867f49eea9781f2593b9ce5a"></a>
typedef <a class="el" href="classOr__node.html">Or_node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Column_node</b></td></tr>
<tr class="separator:ga18d16049867f49eea9781f2593b9ce5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f06001a129ced07c83ece7a3ef3f76"><td class="memItemLeft" align="right" valign="top"><a id="gad8f06001a129ced07c83ece7a3ef3f76"></a>
typedef <a class="el" href="classAnd__node.html">And_node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Key_node</b></td></tr>
<tr class="separator:gad8f06001a129ced07c83ece7a3ef3f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5c31b4e7484950ef07cc7a5965edc1"><td class="memItemLeft" align="right" valign="top"><a id="gafe5c31b4e7484950ef07cc7a5965edc1"></a>
typedef <a class="el" href="classAnd__node.html">And_node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>All_columns_node</b></td></tr>
<tr class="separator:gafe5c31b4e7484950ef07cc7a5965edc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga14224b18bb5f7e175fde6932a590defa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga14224b18bb5f7e175fde6932a590defa">get_table_def_key</a> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char **key)</td></tr>
<tr class="separator:ga14224b18bb5f7e175fde6932a590defa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d02e5bbc2f45e705339a4bd9b535fe7"><td class="memItemLeft" align="right" valign="top"><a id="ga1d02e5bbc2f45e705339a4bd9b535fe7"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_key</b> (const uchar *record, size_t *length, my_bool not_used MY_ATTRIBUTE((unused)))</td></tr>
<tr class="separator:ga1d02e5bbc2f45e705339a4bd9b535fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f57ec544a178c11c18d6900e2dcf6c"><td class="memItemLeft" align="right" valign="top"><a id="gad9f57ec544a178c11c18d6900e2dcf6c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_init</b> (void)</td></tr>
<tr class="separator:gad9f57ec544a178c11c18d6900e2dcf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb94e7a0682741b06d662be41fae480f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gabb94e7a0682741b06d662be41fae480f">table_def_start_shutdown</a> (void)</td></tr>
<tr class="separator:gabb94e7a0682741b06d662be41fae480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b09d5446051abdac04bf96a4d6a0c12"><td class="memItemLeft" align="right" valign="top"><a id="ga8b09d5446051abdac04bf96a4d6a0c12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_free</b> (void)</td></tr>
<tr class="separator:ga8b09d5446051abdac04bf96a4d6a0c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb76a30ed423c4cb98689fcedae48c60"><td class="memItemLeft" align="right" valign="top"><a id="gabb76a30ed423c4cb98689fcedae48c60"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_definitions</b> (void)</td></tr>
<tr class="separator:gabb76a30ed423c4cb98689fcedae48c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c9e8583421876b16d148a82322e86e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gad9c9e8583421876b16d148a82322e86e">get_table_share</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *key, size_t key_length, uint db_flags, int *error, my_hash_value_type hash_value)</td></tr>
<tr class="separator:gad9c9e8583421876b16d148a82322e86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f27eb7444d2cec48296785a54e229f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0f27eb7444d2cec48296785a54e229f2">release_table_share</a> (<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:ga0f27eb7444d2cec48296785a54e229f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aad9b367e12ef2a26ab5fb1a73c4e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9aad9b367e12ef2a26ab5fb1a73c4e32">get_cached_table_share</a> (THD *thd, const char *db, const char *table_name)</td></tr>
<tr class="separator:ga9aad9b367e12ef2a26ab5fb1a73c4e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b0693677aeecf9a38e98f36d3d31eb"><td class="memItemLeft" align="right" valign="top"><a id="ga54b0693677aeecf9a38e98f36d3d31eb"></a>
<a class="el" href="structst__open__table__list.html">OPEN_TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>list_open_tables</b> (THD *thd, const char *db, const char *wild)</td></tr>
<tr class="separator:ga54b0693677aeecf9a38e98f36d3d31eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2849c2d4c8cec7a89054e0033a8707"><td class="memItemLeft" align="right" valign="top"><a id="gaff2849c2d4c8cec7a89054e0033a8707"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>intern_close_table</b> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:gaff2849c2d4c8cec7a89054e0033a8707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga055df8e4470e8dfd7f8b41f4402f6774"><td class="memItemLeft" align="right" valign="top"><a id="ga055df8e4470e8dfd7f8b41f4402f6774"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_io_cache</b> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ga055df8e4470e8dfd7f8b41f4402f6774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8504b9f30ae84e60749639a2d03bc0d0"><td class="memItemLeft" align="right" valign="top"><a id="ga8504b9f30ae84e60749639a2d03bc0d0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>close_cached_tables</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, bool wait_for_refresh, ulong timeout)</td></tr>
<tr class="separator:ga8504b9f30ae84e60749639a2d03bc0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cc536b80faf27a1017cf4ddcc988ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae2cc536b80faf27a1017cf4ddcc988ad">mark_tmp_table_for_reuse</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:gae2cc536b80faf27a1017cf4ddcc988ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86713fadf907edf57606406a10c1f994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga86713fadf907edf57606406a10c1f994">close_all_tables_for_name</a> (THD *thd, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, bool remove_from_locked_tables, <a class="el" href="structTABLE.html">TABLE</a> *skip_table)</td></tr>
<tr class="separator:ga86713fadf907edf57606406a10c1f994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ded5accefd985fce6ed115038ea92f7"><td class="memItemLeft" align="right" valign="top"><a id="ga3ded5accefd985fce6ed115038ea92f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_thread_tables</b> (THD *thd)</td></tr>
<tr class="separator:ga3ded5accefd985fce6ed115038ea92f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52b8d7410875b0048421f9386b4b6bd"><td class="memItemLeft" align="right" valign="top"><a id="gac52b8d7410875b0048421f9386b4b6bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_thread_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> **table_ptr)</td></tr>
<tr class="separator:gac52b8d7410875b0048421f9386b4b6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4991367acddcb2b2a0edeb169029917"><td class="memItemLeft" align="right" valign="top"><a id="gaa4991367acddcb2b2a0edeb169029917"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary_tables</b> (THD *thd)</td></tr>
<tr class="separator:gaa4991367acddcb2b2a0edeb169029917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98920037a85177667356d2364893271d"><td class="memItemLeft" align="right" valign="top"><a id="ga98920037a85177667356d2364893271d"></a>
<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_table_in_list</b> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *TABLE_LIST::*link, const char *db_name, const char *table_name)</td></tr>
<tr class="separator:ga98920037a85177667356d2364893271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97300534246ab121f6b9b9d7031fb56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga97300534246ab121f6b9b9d7031fb56e">unique_table</a> (THD *thd, const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool check_alias)</td></tr>
<tr class="separator:ga97300534246ab121f6b9b9d7031fb56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62ea49fa4b58a38f20af4754928e1be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaa62ea49fa4b58a38f20af4754928e1be">update_non_unique_table_error</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *update, const char *operation, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *duplicate)</td></tr>
<tr class="separator:gaa62ea49fa4b58a38f20af4754928e1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0734400e8b6f0dab464f0da0f177086b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0734400e8b6f0dab464f0da0f177086b">find_temporary_table</a> (THD *thd, const char *db, const char *table_name)</td></tr>
<tr class="separator:ga0734400e8b6f0dab464f0da0f177086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d31aeecf54e9bf14d05fa8a6478b7e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4d31aeecf54e9bf14d05fa8a6478b7e0">find_temporary_table</a> (THD *thd, const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="separator:ga4d31aeecf54e9bf14d05fa8a6478b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45eefb797fc5051da7202a1f96b20c1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga45eefb797fc5051da7202a1f96b20c1d">find_temporary_table</a> (THD *thd, const char *table_key, size_t table_key_length)</td></tr>
<tr class="separator:ga45eefb797fc5051da7202a1f96b20c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5683a94b25579c456f2c9f55f9f9b35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab5683a94b25579c456f2c9f55f9f9b35">drop_temporary_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *is_trans)</td></tr>
<tr class="separator:gab5683a94b25579c456f2c9f55f9f9b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f62c19b7f434d061bee6a75402aca1"><td class="memItemLeft" align="right" valign="top"><a id="ga62f62c19b7f434d061bee6a75402aca1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, bool free_share, bool delete_table)</td></tr>
<tr class="separator:ga62f62c19b7f434d061bee6a75402aca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4998a4b0d6b30f4f9669a8c1169ef41d"><td class="memItemLeft" align="right" valign="top"><a id="ga4998a4b0d6b30f4f9669a8c1169ef41d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary</b> (<a class="el" href="structTABLE.html">TABLE</a> *table, bool free_share, bool delete_table)</td></tr>
<tr class="separator:ga4998a4b0d6b30f4f9669a8c1169ef41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f79c4227effeafa7bad8b4582682e9a"><td class="memItemLeft" align="right" valign="top"><a id="ga1f79c4227effeafa7bad8b4582682e9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>rename_temporary_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const char *db, const char *table_name)</td></tr>
<tr class="separator:ga1f79c4227effeafa7bad8b4582682e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19a8c14e089f35b82dc7a2ded67ea4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac19a8c14e089f35b82dc7a2ded67ea4b">wait_while_table_is_used</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, enum ha_extra_function function)</td></tr>
<tr class="separator:gac19a8c14e089f35b82dc7a2ded67ea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f2e6710ec001734614f4a11cde9f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac9f2e6710ec001734614f4a11cde9f0f">drop_open_table</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const char *db_name, const char *table_name)</td></tr>
<tr class="separator:gac9f2e6710ec001734614f4a11cde9f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7967950b623499bad7a7fc81612e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0f7967950b623499bad7a7fc81612e16">check_if_table_exists</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, bool *exists)</td></tr>
<tr class="separator:ga0f7967950b623499bad7a7fc81612e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43cb5a9ba1064a36db89ad5c4d645528"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="classOpen__table__context.html">Open_table_context</a> *ot_ctx)</td></tr>
<tr class="separator:ga43cb5a9ba1064a36db89ad5c4d645528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4458592b1c4d9ed293e5b2033349c3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4458592b1c4d9ed293e5b2033349c3fb">find_locked_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *list, const char *db, const char *table_name)</td></tr>
<tr class="separator:ga4458592b1c4d9ed293e5b2033349c3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8692f5ebd7f6483f1dcc576eb2346f52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8692f5ebd7f6483f1dcc576eb2346f52">find_table_for_mdl_upgrade</a> (THD *thd, const char *db, const char *table_name, bool no_error)</td></tr>
<tr class="separator:ga8692f5ebd7f6483f1dcc576eb2346f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098cb47bbc8bbdb790fcf28c253ab2b6"><td class="memItemLeft" align="right" valign="top"><a id="ga098cb47bbc8bbdb790fcf28c253ab2b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign_new_table_id</b> (<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:ga098cb47bbc8bbdb790fcf28c253ab2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917237a2e99cef2eb34e64095d79fb1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga917237a2e99cef2eb34e64095d79fb1a">tdc_open_view</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *alias, const char *cache_key, size_t cache_key_length, uint flags)</td></tr>
<tr class="separator:ga917237a2e99cef2eb34e64095d79fb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fe4cc1a004bb6b5f07556a182f945b"><td class="memItemLeft" align="right" valign="top"><a id="ga24fe4cc1a004bb6b5f07556a182f945b"></a>
thr_lock_type&#160;</td><td class="memItemRight" valign="bottom"><b>read_lock_type_for_table</b> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool routine_modifies_data)</td></tr>
<tr class="separator:ga24fe4cc1a004bb6b5f07556a182f945b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b858a3ae42dbb6ac5cc1809c9ec68b5"><td class="memItemLeft" align="right" valign="top"><a id="ga9b858a3ae42dbb6ac5cc1809c9ec68b5"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>schema_set_get_key</b> (const uchar *record, size_t *length, my_bool not_used MY_ATTRIBUTE((unused)))</td></tr>
<tr class="separator:ga9b858a3ae42dbb6ac5cc1809c9ec68b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed504cf321c7fd98175f80785f6be954"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaed504cf321c7fd98175f80785f6be954">run_before_dml_hook</a> (THD *thd)</td></tr>
<tr class="separator:gaed504cf321c7fd98175f80785f6be954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae06de7ce22001b035ca61edf2a3dea09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae06de7ce22001b035ca61edf2a3dea09">lock_table_names</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_start, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_end, ulong lock_wait_timeout, uint flags)</td></tr>
<tr class="separator:gae06de7ce22001b035ca61edf2a3dea09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e488af7a3f47be08fad22370de07c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **start, uint *counter, uint flags, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="separator:ga59e488af7a3f47be08fad22370de07c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a68932d1c35b3fd820c99d185d7888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga86a68932d1c35b3fd820c99d185d7888">open_n_lock_single_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_l, thr_lock_type lock_type, uint flags, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="memdesc:ga86a68932d1c35b3fd820c99d185d7888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open and lock one table.  <a href="#ga86a68932d1c35b3fd820c99d185d7888">More...</a><br /></td></tr>
<tr class="separator:ga86a68932d1c35b3fd820c99d185d7888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5263e110baf47c9fe2f820bc649be5"><td class="memItemLeft" align="right" valign="top"><a id="ga3b5263e110baf47c9fe2f820bc649be5"></a>
<a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>open_ltable</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, thr_lock_type lock_type, uint lock_flags)</td></tr>
<tr class="separator:ga3b5263e110baf47c9fe2f820bc649be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab469748dd06a6477d4ce23f742af0794"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab469748dd06a6477d4ce23f742af0794">open_and_lock_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, uint flags, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr class="separator:gab469748dd06a6477d4ce23f742af0794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b93d2956c1e654ebe0e48ab3503410d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga6b93d2956c1e654ebe0e48ab3503410d">open_tables_for_query</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, uint flags)</td></tr>
<tr class="separator:ga6b93d2956c1e654ebe0e48ab3503410d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399ec28859bb54829b1cabbeed845f78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, uint count, uint flags)</td></tr>
<tr class="separator:ga399ec28859bb54829b1cabbeed845f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bec964ecaaa7270a429e664643b746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga92bec964ecaaa7270a429e664643b746">close_tables_for_reopen</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **tables, const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;start_of_statement_svp)</td></tr>
<tr class="separator:ga92bec964ecaaa7270a429e664643b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35659d6f0f8a6d39ee3f3db7c233df52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga35659d6f0f8a6d39ee3f3db7c233df52">open_table_uncached</a> (THD *thd, const char *path, const char *db, const char *table_name, bool add_to_temporary_tables_list, bool open_in_engine)</td></tr>
<tr class="separator:ga35659d6f0f8a6d39ee3f3db7c233df52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6730cd1feb3014042adbf998ca9203"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga2f6730cd1feb3014042adbf998ca9203">rm_temporary_table</a> (<a class="el" href="structhandlerton.html">handlerton</a> *base, const char *path)</td></tr>
<tr class="separator:ga2f6730cd1feb3014042adbf998ca9203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c68673b37e4f394de31ffe4ac80fcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab5c68673b37e4f394de31ffe4ac80fcc">open_temporary_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="separator:gab5c68673b37e4f394de31ffe4ac80fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c1cb71807d09d53273048447abf301"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac4c1cb71807d09d53273048447abf301">open_temporary_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl_list)</td></tr>
<tr class="separator:gac4c1cb71807d09d53273048447abf301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacac9a77ae494a701599bc5e1856f766c"><td class="memItemLeft" align="right" valign="top"><a id="gacac9a77ae494a701599bc5e1856f766c"></a>
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const char *name, size_t length, bool allow_rowid, uint *cached_field_index_ptr)</td></tr>
<tr class="separator:gacac9a77ae494a701599bc5e1856f766c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b8b9fd8dfbbaa3cdc71df88ff3e5d4"><td class="memItemLeft" align="right" valign="top"><a id="ga53b8b9fd8dfbbaa3cdc71df88ff3e5d4"></a>
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table_ref</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *name, size_t length, const char *item_name, const char *db_name, const char *table_name, <a class="el" href="classItem.html">Item</a> **ref, ulong want_privilege, bool allow_rowid, uint *cached_field_index_ptr, bool register_tree_change, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **actual_table)</td></tr>
<tr class="separator:ga53b8b9fd8dfbbaa3cdc71df88ff3e5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga795c727f9014b6fd6d0eed974e26c5c3"><td class="memItemLeft" align="right" valign="top"><a id="ga795c727f9014b6fd6d0eed974e26c5c3"></a>
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table_sef</b> (<a class="el" href="structTABLE.html">TABLE</a> *table, const char *name)</td></tr>
<tr class="separator:ga795c727f9014b6fd6d0eed974e26c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40da7d22bc6c9c596a10e723d1dd5b71"><td class="memItemLeft" align="right" valign="top"><a id="ga40da7d22bc6c9c596a10e723d1dd5b71"></a>
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_tables</b> (THD *thd, <a class="el" href="classItem__ident.html">Item_ident</a> *item, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *first_table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *last_table, <a class="el" href="classItem.html">Item</a> **ref, find_item_error_report_type report_error, ulong want_privilege, bool register_tree_change)</td></tr>
<tr class="separator:ga40da7d22bc6c9c596a10e723d1dd5b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8a568dc8a852240a792309974498e53"><td class="memItemLeft" align="right" valign="top"><a id="gad8a568dc8a852240a792309974498e53"></a>
<a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>find_item_in_list</b> (<a class="el" href="classItem.html">Item</a> *find, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;items, uint *counter, find_item_error_report_type report_error, enum_resolution_type *resolution)</td></tr>
<tr class="separator:gad8a568dc8a852240a792309974498e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecb35e53c52e10034b0479c304fbf206"><td class="memItemLeft" align="right" valign="top"><a id="gaecb35e53c52e10034b0479c304fbf206"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setup_natural_join_row_types</b> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *from_clause, <a class="el" href="structName__resolution__context.html">Name_resolution_context</a> *context)</td></tr>
<tr class="separator:gaecb35e53c52e10034b0479c304fbf206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d4287d0d00fc5733a67df33a193738"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaa6d4287d0d00fc5733a67df33a193738">setup_fields</a> (THD *thd, <a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, ulong want_privilege, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *sum_func_list, bool allow_sum_func, bool column_update)</td></tr>
<tr class="separator:gaa6d4287d0d00fc5733a67df33a193738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed6f7a411697a21f8e57aee4e40dcc9"><td class="memItemLeft" align="right" valign="top"><a id="ga3ed6f7a411697a21f8e57aee4e40dcc9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert_fields</b> (THD *thd, <a class="el" href="structName__resolution__context.html">Name_resolution_context</a> *context, const char *db_name, const char *table_name, <a class="el" href="classList__iterator.html">List_iterator</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *it, bool any_privileges)</td></tr>
<tr class="separator:ga3ed6f7a411697a21f8e57aee4e40dcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b0cee97465e5202815693c02ded951b"><td class="memItemLeft" align="right" valign="top"><a id="ga6b0cee97465e5202815693c02ded951b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;values, MY_BITMAP *bitmap, MY_BITMAP *insert_into_fields_bitmap)</td></tr>
<tr class="separator:ga6b0cee97465e5202815693c02ded951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a03ad3f42501f08c42bc3ab9b5eb51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga46a03ad3f42501f08c42bc3ab9b5eb51">check_record</a> (THD *thd, <a class="el" href="classField.html">Field</a> **ptr)</td></tr>
<tr class="separator:ga46a03ad3f42501f08c42bc3ab9b5eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f73b6e4ed87676502d07bd58eba7590"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga1f73b6e4ed87676502d07bd58eba7590">call_before_insert_triggers</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a> event, MY_BITMAP *insert_into_fields_bitmap)</td></tr>
<tr class="separator:ga1f73b6e4ed87676502d07bd58eba7590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga696dd055ce9b953fc7e8d76da097f41d"><td class="memItemLeft" align="right" valign="top"><a id="ga696dd055ce9b953fc7e8d76da097f41d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record_n_invoke_before_triggers</b> (THD *thd, <a class="el" href="classCOPY__INFO.html">COPY_INFO</a> *optype_info, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;values, <a class="el" href="structTABLE.html">TABLE</a> *table, enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a> event, int num_fields)</td></tr>
<tr class="separator:ga696dd055ce9b953fc7e8d76da097f41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1dd92205f9823aac391eb8889dea9d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae1dd92205f9823aac391eb8889dea9d4">fill_record</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classField.html">Field</a> **ptr, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;values, MY_BITMAP *bitmap, MY_BITMAP *insert_into_fields_bitmap)</td></tr>
<tr class="separator:gae1dd92205f9823aac391eb8889dea9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf04201d06a91143d6c13dc72e2ab3aa7"><td class="memItemLeft" align="right" valign="top"><a id="gaf04201d06a91143d6c13dc72e2ab3aa7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record_n_invoke_before_triggers</b> (THD *thd, <a class="el" href="classField.html">Field</a> **ptr, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;values, <a class="el" href="structTABLE.html">TABLE</a> *table, enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a> event, int num_fields)</td></tr>
<tr class="separator:gaf04201d06a91143d6c13dc72e2ab3aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadded8328656d64a663d994979a50b956"><td class="memItemLeft" align="right" valign="top"><a id="gadded8328656d64a663d994979a50b956"></a>
my_bool&#160;</td><td class="memItemRight" valign="bottom"><b>mysql_rm_tmp_tables</b> (void)</td></tr>
<tr class="separator:gadded8328656d64a663d994979a50b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae1459addd4c75ddbf76468ba9a26a6"><td class="memItemLeft" align="right" valign="top"><a id="gaaae1459addd4c75ddbf76468ba9a26a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tdc_flush_unused_tables</b> ()</td></tr>
<tr class="separator:gaaae1459addd4c75ddbf76468ba9a26a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8faf6c6118b6677394e14994ae614075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8faf6c6118b6677394e14994ae614075">tdc_remove_table</a> (THD *thd, enum_tdc_remove_table_type remove_type, const char *db, const char *table_name, bool has_lock)</td></tr>
<tr class="separator:ga8faf6c6118b6677394e14994ae614075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481e7e276a23583989ab7fc28bf70928"><td class="memItemLeft" align="right" valign="top"><a id="ga481e7e276a23583989ab7fc28bf70928"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setup_ftfuncs</b> (SELECT_LEX *select_lex)</td></tr>
<tr class="separator:ga481e7e276a23583989ab7fc28bf70928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673bd1c3a18bccbfeeaedccdc1434d8c"><td class="memItemLeft" align="right" valign="top"><a id="ga673bd1c3a18bccbfeeaedccdc1434d8c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>init_ftfuncs</b> (THD *thd, SELECT_LEX *select_lex)</td></tr>
<tr class="separator:ga673bd1c3a18bccbfeeaedccdc1434d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b26ffd4f5885a763dc68dccf87ae547"><td class="memItemLeft" align="right" valign="top"><a id="ga8b26ffd4f5885a763dc68dccf87ae547"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_equal</b> (const LEX_STRING *a, const LEX_STRING *b)</td></tr>
<tr class="separator:ga8b26ffd4f5885a763dc68dccf87ae547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e194df2b3923a1b4cf2f2567c829b7"><td class="memItemLeft" align="right" valign="top"><a id="ga32e194df2b3923a1b4cf2f2567c829b7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_equal</b> (const LEX_CSTRING *a, const LEX_CSTRING *b)</td></tr>
<tr class="separator:ga32e194df2b3923a1b4cf2f2567c829b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d35c9ae33217ba2b5f2aabfbebb3908"><td class="memItemLeft" align="right" valign="top"><a id="ga1d35c9ae33217ba2b5f2aabfbebb3908"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_cond_or</b> (const <a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:ga1d35c9ae33217ba2b5f2aabfbebb3908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24124224f0f88c7f84f5365b9d6746f3"><td class="memItemLeft" align="right" valign="top"><a id="ga24124224f0f88c7f84f5365b9d6746f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_order_deterministic</b> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *join_list, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:ga24124224f0f88c7f84f5365b9d6746f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df84a9b557280b7d7d36cae3c82d7bf"><td class="memItemLeft" align="right" valign="top"><a id="ga2df84a9b557280b7d7d36cae3c82d7bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_order_deterministic</b> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:ga2df84a9b557280b7d7d36cae3c82d7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5564f0cf7807256a52a9455fd4f45d4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga5564f0cf7807256a52a9455fd4f45d4e">open_nontrans_system_tables_for_read</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, Open_tables_backup *backup)</td></tr>
<tr class="separator:ga5564f0cf7807256a52a9455fd4f45d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac315ba0102697b41bdeeff67a61240eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac315ba0102697b41bdeeff67a61240eb">open_trans_system_tables_for_read</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list)</td></tr>
<tr class="separator:gac315ba0102697b41bdeeff67a61240eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d367b48b7597012ac308bbbdaa0aca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4d367b48b7597012ac308bbbdaa0aca2">close_nontrans_system_tables</a> (THD *thd, Open_tables_backup *backup)</td></tr>
<tr class="separator:ga4d367b48b7597012ac308bbbdaa0aca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ca9600b012ffde28a4a0360e91c0e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga94ca9600b012ffde28a4a0360e91c0e8">close_trans_system_tables</a> (THD *thd)</td></tr>
<tr class="separator:ga94ca9600b012ffde28a4a0360e91c0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9467ef8e03a8afbe8b937d699a0537f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9467ef8e03a8afbe8b937d699a0537f2">close_mysql_tables</a> (THD *thd)</td></tr>
<tr class="separator:ga9467ef8e03a8afbe8b937d699a0537f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f08738b93443c024318ecbcc739f6f1"><td class="memItemLeft" align="right" valign="top"><a id="ga7f08738b93443c024318ecbcc739f6f1"></a>
<a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>open_system_table_for_update</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *one_table)</td></tr>
<tr class="separator:ga7f08738b93443c024318ecbcc739f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga065f6a0326ab135938fb38fd371dace5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga065f6a0326ab135938fb38fd371dace5">open_log_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *one_table, Open_tables_backup *backup)</td></tr>
<tr class="separator:ga065f6a0326ab135938fb38fd371dace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f22fa867e1bb56d350834b5497c9d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8f22fa867e1bb56d350834b5497c9d6d">close_log_table</a> (THD *thd, Open_tables_backup *backup)</td></tr>
<tr class="separator:ga8f22fa867e1bb56d350834b5497c9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eaa3b1fdce29eac72028f96c55607d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8eaa3b1fdce29eac72028f96c55607d3">Open_table_context::Open_table_context</a> (THD *thd, uint flags)</td></tr>
<tr class="separator:ga8eaa3b1fdce29eac72028f96c55607d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35889f70c8719510fb76899cf9cf20b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaf35889f70c8719510fb76899cf9cf20b">Open_table_context::request_backoff_action</a> (enum_open_table_action action_arg, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table)</td></tr>
<tr class="separator:gaf35889f70c8719510fb76899cf9cf20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade48892bc4607303f7f4d3d6df4c39de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gade48892bc4607303f7f4d3d6df4c39de">Open_table_context::recover_from_failed_open</a> ()</td></tr>
<tr class="separator:gade48892bc4607303f7f4d3d6df4c39de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d51adf9905616e57f7b572081f537ac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4d51adf9905616e57f7b572081f537ac">DML_prelocking_strategy::handle_routine</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp, bool *need_prelocking)</td></tr>
<tr class="separator:ga4d51adf9905616e57f7b572081f537ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4041a333019fb1a8ffb4e3772f627cf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab4041a333019fb1a8ffb4e3772f627cf">DML_prelocking_strategy::handle_table</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:gab4041a333019fb1a8ffb4e3772f627cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga757cc4c5e9baf4dfae041368257e46e4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga757cc4c5e9baf4dfae041368257e46e4">DML_prelocking_strategy::handle_view</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:ga757cc4c5e9baf4dfae041368257e46e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d0312d3f9e2abb42e91b74f045d79"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga7e0d0312d3f9e2abb42e91b74f045d79">Alter_table_prelocking_strategy::handle_routine</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp, bool *need_prelocking)</td></tr>
<tr class="separator:ga7e0d0312d3f9e2abb42e91b74f045d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572cfaf98399c14ebe9e318b4197c6f5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga572cfaf98399c14ebe9e318b4197c6f5">Alter_table_prelocking_strategy::handle_table</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:ga572cfaf98399c14ebe9e318b4197c6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da56b0df4158af2defc12e836983529"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga3da56b0df4158af2defc12e836983529">Alter_table_prelocking_strategy::handle_view</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr class="separator:ga3da56b0df4158af2defc12e836983529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34629ea7d6b32851a95772a05f4dc780"><td class="memItemLeft" align="right" valign="top"><a id="ga34629ea7d6b32851a95772a05f4dc780"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Table_node::Table_node</b> (const <a class="el" href="structTABLE.html">TABLE</a> *table_arg)</td></tr>
<tr class="separator:ga34629ea7d6b32851a95772a05f4dc780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80fe690ff59e36b27a7d275e047b7271"><td class="memItemLeft" align="right" valign="top"><a id="ga80fe690ff59e36b27a7d275e047b7271"></a>
<a class="el" href="classOr__node.html">Column_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Table_node::get_column_node</b> (const <a class="el" href="classField.html">Field</a> *field) const</td></tr>
<tr class="separator:ga80fe690ff59e36b27a7d275e047b7271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e50ebcb4a7fc30f7b119a6a2cbeb4e"><td class="memItemLeft" align="right" valign="top"><a id="ga69e50ebcb4a7fc30f7b119a6a2cbeb4e"></a>
<a class="el" href="classOr__node.html">Column_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Table_node::create_column_node</b> (const <a class="el" href="classField.html">Field</a> *field)</td></tr>
<tr class="separator:ga69e50ebcb4a7fc30f7b119a6a2cbeb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d82c1751671add5ba47c4fb3baee6c"><td class="memItemLeft" align="right" valign="top"><a id="ga50d82c1751671add5ba47c4fb3baee6c"></a>
<a class="el" href="classAnd__node.html">All_columns_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Table_node::create_all_columns_node</b> ()</td></tr>
<tr class="separator:ga50d82c1751671add5ba47c4fb3baee6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b4d5d1225048986bc5245de7c35aef5"><td class="memItemLeft" align="right" valign="top"><a id="ga8b4d5d1225048986bc5245de7c35aef5"></a>
<a class="el" href="classAnd__node.html">Key_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Table_node::create_key_node</b> (const <a class="el" href="structst__key.html">KEY</a> *key_info)</td></tr>
<tr class="separator:ga8b4d5d1225048986bc5245de7c35aef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef1201635e01193a3cf29603452db4b5"><td class="memItemLeft" align="right" valign="top"><a id="gaef1201635e01193a3cf29603452db4b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Const_ordered_table_node::Const_ordered_table_node</b> (const <a class="el" href="structTABLE.html">TABLE</a> *table_arg)</td></tr>
<tr class="separator:gaef1201635e01193a3cf29603452db4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07dce568f7a23b1b2dc3bbc8f25d7d98"><td class="memItemLeft" align="right" valign="top"><a id="ga07dce568f7a23b1b2dc3bbc8f25d7d98"></a>
<a class="el" href="classOr__node.html">Column_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Const_ordered_table_node::get_ordered_column_node</b> (const <a class="el" href="classField.html">Field</a> *field) const</td></tr>
<tr class="separator:ga07dce568f7a23b1b2dc3bbc8f25d7d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7573f60971fb824bb6d23b46072e526"><td class="memItemLeft" align="right" valign="top"><a id="gab7573f60971fb824bb6d23b46072e526"></a>
<a class="el" href="classOr__node.html">Column_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>Const_ordered_table_node::get_const_column_node</b> (const <a class="el" href="classField.html">Field</a> *field) const</td></tr>
<tr class="separator:gab7573f60971fb824bb6d23b46072e526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282d4f95f5a074a72a205abb1d2c289f"><td class="memItemLeft" align="right" valign="top"><a id="ga282d4f95f5a074a72a205abb1d2c289f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Join_node::Join_node</b> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *join_list, <a class="el" href="classItem.html">Item</a> *cond, const <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:ga282d4f95f5a074a72a205abb1d2c289f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3109df9efa01b23442083d8021387df"><td class="memItemLeft" align="right" valign="top"><a id="gaf3109df9efa01b23442083d8021387df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Join_node::Join_node</b> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="classItem.html">Item</a> *cond, const <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:gaf3109df9efa01b23442083d8021387df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab922c19378cfc525876a52147dc0f90"><td class="memItemLeft" align="right" valign="top"><a id="gaab922c19378cfc525876a52147dc0f90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Join_node::is_ordered</b> () const</td></tr>
<tr class="separator:gaab922c19378cfc525876a52147dc0f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga99c8e1e3e72cd74032d5f11c486911fd"><td class="memItemLeft" align="right" valign="top">mysql_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga99c8e1e3e72cd74032d5f11c486911fd">LOCK_open</a></td></tr>
<tr class="separator:ga99c8e1e3e72cd74032d5f11c486911fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a682517d27176617b45212332a96a9d"><td class="memItemLeft" align="right" valign="top">mysql_cond_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga7a682517d27176617b45212332a96a9d">COND_open</a></td></tr>
<tr class="separator:ga7a682517d27176617b45212332a96a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f89faf859f3162a4d7476410c4a69e"><td class="memItemLeft" align="right" valign="top"><a id="gaf3f89faf859f3162a4d7476410c4a69e"></a>
HASH&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_cache</b></td></tr>
<tr class="separator:gaf3f89faf859f3162a4d7476410c4a69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9133e87930df59fe74ca492acf5295f7"><td class="memItemLeft" align="right" valign="top"><a id="ga9133e87930df59fe74ca492acf5295f7"></a>
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>not_found_field</b> = (<a class="el" href="classField.html">Field</a>*) 0x1</td></tr>
<tr class="separator:ga9133e87930df59fe74ca492acf5295f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba50986729b2cfd3be1c762e666d3d18"><td class="memItemLeft" align="right" valign="top"><a id="gaba50986729b2cfd3be1c762e666d3d18"></a>
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>view_ref_found</b> = (<a class="el" href="classField.html">Field</a>*) 0x2</td></tr>
<tr class="separator:gaba50986729b2cfd3be1c762e666d3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac130a94f4d55acec35aa42626af9f37f"><td class="memItemLeft" align="right" valign="top"><a id="gac130a94f4d55acec35aa42626af9f37f"></a>
<a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>not_found_item</b> = (<a class="el" href="classItem.html">Item</a>**) 0x1</td></tr>
<tr class="separator:gac130a94f4d55acec35aa42626af9f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga176a646a5a04af4bf68c0f149af5dd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga176a646a5a04af4bf68c0f149af5dd00">&#9670;&nbsp;</a></span>BELONGS_TO_P_S_UNDER_LTM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BELONGS_TO_P_S_UNDER_LTM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thd, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tl&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="group__Data__Dictionary.html#gae383b8742be40b62c710380f1b5e6a6e">UNDER_LTM</a>(thd) &amp;&amp; \</div><div class="line">    (!strcmp(<span class="stringliteral">&quot;performance_schema&quot;</span>, tl-&gt;db) &amp;&amp; \</div><div class="line">     strcmp(tl-&gt;table_name, <span class="stringliteral">&quot;threads&quot;</span>) &amp;&amp; \</div><div class="line">     strstr(tl-&gt;table_name, <span class="stringliteral">&quot;setup_&quot;</span>) == NULL))</div><div class="ttc" id="group__Data__Dictionary_html_gae383b8742be40b62c710380f1b5e6a6e"><div class="ttname"><a href="group__Data__Dictionary.html#gae383b8742be40b62c710380f1b5e6a6e">UNDER_LTM</a></div><div class="ttdeci">#define UNDER_LTM(thd)</div><div class="ttdef"><b>Definition:</b> sql_base.cc:1526</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gae383b8742be40b62c710380f1b5e6a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae383b8742be40b62c710380f1b5e6a6e">&#9670;&nbsp;</a></span>UNDER_LTM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNDER_LTM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thd</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(thd-&gt;locked_tables_mode == LTM_LOCK_TABLES || \</div><div class="line">   thd-&gt;locked_tables_mode == LTM_PRELOCKED_UNDER_LOCK_TABLES)</div></div><!-- fragment --><p class="">Performance Schema tables must be accessible independently of the LOCK <a class="el" href="structTABLE.html">TABLE</a> mode. These macros handle the special case of P_S tables being used under LOCK <a class="el" href="structTABLE.html">TABLE</a> mode. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1f73b6e4ed87676502d07bd58eba7590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f73b6e4ed87676502d07bd58eba7590">&#9670;&nbsp;</a></span>call_before_insert_triggers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool call_before_insert_triggers </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="trigger__def_8h.html#a25c92abc3a183d6950b0d9a4ee846e5e">enum_trigger_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MY_BITMAP *&#160;</td>
          <td class="paramname"><em>insert_into_fields_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Execute BEFORE INSERT trigger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread context </td></tr>
    <tr><td class="paramname">table</td><td><a class="el" href="structTABLE.html">TABLE</a>-object holding list of triggers to be invoked </td></tr>
    <tr><td class="paramname">event</td><td>event type for triggers to be invoked </td></tr>
    <tr><td class="paramname">insert_into_fields_bitmap</td><td><a class="el" href="classBitmap.html">Bitmap</a> for fields that is set in fill_record</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f7967950b623499bad7a7fc81612e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7967950b623499bad7a7fc81612e16">&#9670;&nbsp;</a></span>check_if_table_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_if_table_exists </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check that table exists in table definition cache, on disk or in some storage engine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table list element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exists</td><td>Out parameter which is set to TRUE if table exists and to FALSE otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function acquires LOCK_open internally.</dd>
<dd>
If there is no .FRM file for the table but it exists in one of engines (e.g. it was created on another node of NDB cluster) this function will fetch and create proper .FRM file for it.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Some error occurred </td></tr>
    <tr><td class="paramname">FALSE</td><td>No error. 'exists' out parameter set accordingly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46a03ad3f42501f08c42bc3ab9b5eb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46a03ad3f42501f08c42bc3ab9b5eb51">&#9670;&nbsp;</a></span>check_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_record </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check the NOT NULL constraint on all the fields of the current record.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">ptr</td><td>Fields.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ga86713fadf907edf57606406a10c1f994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86713fadf907edf57606406a10c1f994">&#9670;&nbsp;</a></span>close_all_tables_for_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_all_tables_for_name </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_from_locked_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>skip_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close all open instances of the table but keep the MDL lock.</p>
<p class="">Works both under LOCK TABLES and in the normal mode. Removes all closed instances of the table from the table cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">share</td><td>table share, but is just a handy way to access the table cache key</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_from_locked_tables</td><td>TRUE if the table is being dropped or renamed. In that case the documented behaviour is to implicitly remove the table from LOCK TABLES list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_table</td><td><a class="el" href="structTABLE.html">TABLE</a> instance that should be kept open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Must be called with an X MDL lock on the table. </dd></dl>

</div>
</div>
<a id="ga8f22fa867e1bb56d350834b5497c9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f22fa867e1bb56d350834b5497c9d6d">&#9670;&nbsp;</a></span>close_log_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_log_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Open_tables_backup *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close a log table. The last table opened by <a class="el" href="group__Data__Dictionary.html#ga065f6a0326ab135938fb38fd371dace5">open_log_table()</a> is closed, then the thread context is restored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">backup</td><td>[in] the context to restore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9467ef8e03a8afbe8b937d699a0537f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9467ef8e03a8afbe8b937d699a0537f2">&#9670;&nbsp;</a></span>close_mysql_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_mysql_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">A helper function to close a mysql.* table opened in an auxiliary THD during bootstrap or in the main connection, when we know that there are no locks held by the connection due to a preceding implicit commit.</p>
<p class="">This function assumes that there is no statement transaction started for the operation itself, since mysql.* tables are not transactional and when they are used the binlog is off (DDL binlogging is always statement-based.</p>
<p class="">We need this function since we'd like to not just close the system table, but also release the metadata lock on it.</p>
<p class="">Note, that in LOCK TABLES mode this function does not release the metadata lock. But in this mode the table can be opened only if it is locked explicitly with LOCK TABLES. </p>

</div>
</div>
<a id="ga4d367b48b7597012ac308bbbdaa0aca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d367b48b7597012ac308bbbdaa0aca2">&#9670;&nbsp;</a></span>close_nontrans_system_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_nontrans_system_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Open_tables_backup *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close non-transactional system tables, opened with <a class="el" href="group__Data__Dictionary.html#ga5564f0cf7807256a52a9455fd4f45d4e">open_nontrans_system_tables_for_read()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">backup</td><td>Pointer to Open_tables_backup instance which holds information about tables which were open before we decided to access non-transactional system tables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92bec964ecaaa7270a429e664643b746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bec964ecaaa7270a429e664643b746">&#9670;&nbsp;</a></span>close_tables_for_reopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_tables_for_reopen </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>start_of_statement_svp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Prepare statement for reopening of tables and recalculation of set of prelocked tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tables</td><td><a class="el" href="classList.html">List</a> of tables which we were trying to open and lock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_of_statement_svp</td><td>MDL savepoint which represents the set of metadata locks which the current transaction managed to acquire before execution of the current statement and to which we should revert before trying to reopen tables. NULL if no metadata locks were held and thus all metadata locks should be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94ca9600b012ffde28a4a0360e91c0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ca9600b012ffde28a4a0360e91c0e8">&#9670;&nbsp;</a></span>close_trans_system_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_trans_system_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close transactional system tables, opened with <a class="el" href="group__Data__Dictionary.html#gac315ba0102697b41bdeeff67a61240eb">open_trans_system_tables_for_read()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9f2e6710ec001734614f4a11cde9f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9f2e6710ec001734614f4a11cde9f0f">&#9670;&nbsp;</a></span>drop_open_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drop_open_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close a and drop a just created table in CREATE <a class="el" href="structTABLE.html">TABLE</a> ... SELECT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for the table to be dropped </td></tr>
    <tr><td class="paramname">db_name</td><td>Name of database for this table </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of this table</td></tr>
  </table>
  </dd>
</dl>
<p>This routine assumes that the table to be closed is open only by the calling thread, so we needn't wait until other threads close the table. It also assumes that the table is first in thd-&gt;open_ables and a data lock on it, if any, has been released. To sum up, it's tuned to work with CREATE <a class="el" href="structTABLE.html">TABLE</a> ... SELECT and CREATE <a class="el" href="structTABLE.html">TABLE</a> .. SELECT only. Note, that currently CREATE <a class="el" href="structTABLE.html">TABLE</a> ... SELECT is not supported under LOCK TABLES. This function, still, can be called in prelocked mode, e.g. if we do CREATE <a class="el" href="structTABLE.html">TABLE</a> .. SELECT f1(); </p>

</div>
</div>
<a id="gab5683a94b25579c456f2c9f55f9f9b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5683a94b25579c456f2c9f55f9f9b35">&#9670;&nbsp;</a></span>drop_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int drop_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Drop a temporary table.</p>
<p class="">Try to locate the table in the list of thd-&gt;temporary_tables. If the table is found:</p><ul>
<li>if the table is being used by some outer statement, fail.</li>
<li>if the table is locked with LOCK TABLES or by prelocking, unlock it and remove it from the list of locked tables (THD::lock). Currently only transactional temporary tables are locked.</li>
<li>Close the temporary table, remove its .FRM</li>
<li>remove the table from the list of temporary tables</li>
</ul>
<p class="">This function is used to drop user temporary tables, as well as internal tables created in CREATE TEMPORARY <a class="el" href="structTABLE.html">TABLE</a> ... SELECT or ALTER <a class="el" href="structTABLE.html">TABLE</a>. Even though part of the work done by this function is redundant when the table is internal, as long as we link both internal and user temporary tables into the same thd-&gt;temporary_tables list, it's impossible to tell here whether we're dealing with an internal or a user temporary table.</p>
<p class="">In is_trans out-parameter, we return the type of the table: either transactional (e.g. innodb) as TRUE or non-transactional (e.g. myisam) as FALSE.</p>
<p class="">This function assumes that table to be dropped was pre-opened using table list provided.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>the table was found and dropped successfully. </td></tr>
    <tr><td class="paramname">1</td><td>the table was not found in the list of temporary tables of this thread </td></tr>
    <tr><td class="paramname">-1</td><td>the table is in use by a outer query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1dd92205f9823aac391eb8889dea9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1dd92205f9823aac391eb8889dea9d4">&#9670;&nbsp;</a></span>fill_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fill_record </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MY_BITMAP *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MY_BITMAP *&#160;</td>
          <td class="paramname"><em>insert_into_fields_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Fill field buffer with values from <a class="el" href="classField.html">Field</a> list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">table</td><td>table reference </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer on pointer to record </td></tr>
    <tr><td class="paramname">values</td><td>list of fields </td></tr>
    <tr><td class="paramname">bitmap</td><td><a class="el" href="classBitmap.html">Bitmap</a> over fields to fill </td></tr>
    <tr><td class="paramname">insert_into_fields_bitmap</td><td><a class="el" href="classBitmap.html">Bitmap</a> for fields that is set in fill_record</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__Data__Dictionary.html#gae1dd92205f9823aac391eb8889dea9d4">fill_record()</a> may set table-&gt;auto_increment_field_not_null and a caller should make sure that it is reset after their last call to this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occured </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4458592b1c4d9ed293e5b2033349c3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4458592b1c4d9ed293e5b2033349c3fb">&#9670;&nbsp;</a></span>find_locked_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_locked_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find table in the list of open tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><a class="el" href="classList.html">List</a> of <a class="el" href="structTABLE.html">TABLE</a> objects to be inspected. </td></tr>
    <tr><td class="paramname">db</td><td>Database name </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="structTABLE.html">TABLE</a> object found, 0 if no table found. </dd></dl>

</div>
</div>
<a id="ga8692f5ebd7f6483f1dcc576eb2346f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8692f5ebd7f6483f1dcc576eb2346f52">&#9670;&nbsp;</a></span>find_table_for_mdl_upgrade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_table_for_mdl_upgrade </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find instance of <a class="el" href="structTABLE.html">TABLE</a> with upgradable or exclusive metadata lock from the list of open tables, emit error if no such table found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table. </td></tr>
    <tr><td class="paramname">no_error</td><td>Don't emit error if no suitable <a class="el" href="structTABLE.html">TABLE</a> instance were found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function checks if the connection holds a global IX metadata lock. If no such lock is found, it is not safe to upgrade the lock and ER_TABLE_NOT_LOCKED_FOR_WRITE will be reported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="structTABLE.html">TABLE</a> instance with MDL_SHARED_UPGRADABLE MDL_SHARED_NO_WRITE, MDL_SHARED_NO_READ_WRITE, or MDL_EXCLUSIVE metadata lock, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga0734400e8b6f0dab464f0da0f177086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0734400e8b6f0dab464f0da0f177086b">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find temporary table specified by database and table names in the THD::temporary_tables list.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structTABLE.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga4d31aeecf54e9bf14d05fa8a6478b7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d31aeecf54e9bf14d05fa8a6478b7e0">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find a temporary table specified by <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> instance in the THD::temporary_tables list.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structTABLE.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga45eefb797fc5051da7202a1f96b20c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45eefb797fc5051da7202a1f96b20c1d">&#9670;&nbsp;</a></span>find_temporary_table() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* find_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>table_key_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find a temporary table specified by a key in the THD::temporary_tables list.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structTABLE.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga9aad9b367e12ef2a26ab5fb1a73c4e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aad9b367e12ef2a26ab5fb1a73c4e32">&#9670;&nbsp;</a></span>get_cached_table_share()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* get_cached_table_share </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Get an existing table definition from the table definition cache.</p>
<p class="">Search the table definition cache for a share with the given key. If the share exists, check the m_open_in_progress flag. If true, the share is in the process of being opened by another thread, so we must wait for the opening to finish. This may make the share be destroyed, if open_table_def() fails, so we must repeat the search in the hash table. Return the share.</p>
<dl class="section note"><dt>Note</dt><dd>While waiting for the condition variable signaling that a table share is completely opened, the thread will temporarily release LOCK_open. Thus, the caller cannot rely on LOCK_open being held for the duration of the call.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread descriptor </td></tr>
    <tr><td class="paramname">db</td><td>database name </td></tr>
    <tr><td class="paramname">table_name</td><td>table name</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>a share for the table does not exist in the cache </td></tr>
    <tr><td class="paramname">!=</td><td>NULL pointer to existing share in the cache </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14224b18bb5f7e175fde6932a590defa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14224b18bb5f7e175fde6932a590defa">&#9670;&nbsp;</a></span>get_table_def_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_table_def_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Get table cache key for a table list element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_list[in]</td><td>Table list element. </td></tr>
    <tr><td class="paramname">key[out]</td><td>On return points to table cache key for the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike create_table_def_key() call this function doesn't construct key in a buffer provider by caller. Instead it relies on the fact that table list element for which key is requested has properly initialized <a class="el" href="classMDL__request.html">MDL_request</a> object and the fact that table definition cache key is suffix of key used in MDL subsystem. So to get table definition key it simply needs to return pointer to appropriate part of <a class="el" href="structMDL__key.html">MDL_key</a> object nested in this table list element. Indeed, this means that lifetime of key produced by this call is limited by the lifetime of table list element which it got as parameter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Length of key. </dd></dl>

</div>
</div>
<a id="gad9c9e8583421876b16d148a82322e86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9c9e8583421876b16d148a82322e86e">&#9670;&nbsp;</a></span>get_table_share()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>* get_table_share </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>db_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">my_hash_value_type&#160;</td>
          <td class="paramname"><em>hash_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Get the <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> for a table.</p>
<p class="">Get a table definition from the table definition cache. If the share does not exist, create a new one from the persistently stored table definition, and temporarily release LOCK_open while retrieving it. Re-lock LOCK_open when the table definition has been retrieved, and broadcast this to other threads waiting for the share to become opened.</p>
<p class="">If the share exists, and is in the process of being opened, wait for opening to complete before continuing.</p>
<dl class="section pre"><dt>Precondition</dt><dd>It is a precondition that the caller must own LOCK_open before calling this function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Callers of this function cannot rely on LOCK_open being held for the duration of the call. It may be temporarily released while the table definition is opened, and it may be temporarily released while the thread is waiting for a different thread to finish opening it.</dd>
<dd>
After share-&gt;m_open_in_progress is set, there should be no wait for resources like row- or metadata locks, table flushes, etc. Otherwise, we may end up in deadlocks that will not be detected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_list</td><td>table that should be opened </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>table cache key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_length</td><td>length of key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">db_flags</td><td>flags to open_table_def(): OPEN_VIEW </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">error</td><td>error code from open_table_def()</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>, or 0 if there was an error </dd></dl>

</div>
</div>
<a id="ga4d51adf9905616e57f7b572081f537ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d51adf9905616e57f7b572081f537ac">&#9670;&nbsp;</a></span>handle_routine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DML_prelocking_strategy::handle_routine </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Defines how prelocking algorithm for DML statements should handle routines:</p><ul>
<li>For CALL statements we do unrolling (i.e. open and lock tables for each sub-statement individually). So for such statements prelocking is enabled only if stored functions are used in parameter list and only for period during which we calculate values of parameters. Thus in this strategy we ignore procedure which is directly called by such statement and extend the prelocking set only with tables/functions used by SF called from the parameter list.</li>
<li>For any other statement any routine which is directly or indirectly called by statement is going to be executed in prelocked mode. So in this case we simply add all tables and routines used by it to the prelocking set.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rt</td><td>Prelocking set element describing routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga7e0d0312d3f9e2abb42e91b74f045d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0d0312d3f9e2abb42e91b74f045d79">&#9670;&nbsp;</a></span>handle_routine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Alter_table_prelocking_strategy::handle_routine </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Defines how prelocking algorithm for ALTER <a class="el" href="structTABLE.html">TABLE</a> statement should handle routines - do nothing as this statement is not supposed to call routines.</p>
<p class="">We still can end up in this method when someone tries to define a foreign key referencing a view, and not just a simple view, but one that uses stored routines. </p>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="gab4041a333019fb1a8ffb4e3772f627cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4041a333019fb1a8ffb4e3772f627cf">&#9670;&nbsp;</a></span>handle_table() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DML_prelocking_strategy::handle_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Defines how prelocking algorithm for DML statements should handle table list elements:</p><ul>
<li>If table has triggers we should add all tables and routines used by them to the prelocking set.</li>
</ul>
<p class="">We do not need to acquire metadata locks on trigger names in DML statements, since all DDL statements that change trigger metadata always lock their subject tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga572cfaf98399c14ebe9e318b4197c6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga572cfaf98399c14ebe9e318b4197c6f5">&#9670;&nbsp;</a></span>handle_table() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Alter_table_prelocking_strategy::handle_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Defines how prelocking algorithm for ALTER <a class="el" href="structTABLE.html">TABLE</a> statement should handle table list elements.</p>
<p class="">Unlike in DML, we do not process triggers here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga757cc4c5e9baf4dfae041368257e46e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga757cc4c5e9baf4dfae041368257e46e4">&#9670;&nbsp;</a></span>handle_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DML_prelocking_strategy::handle_view </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Defines how prelocking algorithm for DML statements should handle view - all view routines should be added to the prelocking set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for view. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="ga3da56b0df4158af2defc12e836983529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3da56b0df4158af2defc12e836983529">&#9670;&nbsp;</a></span>handle_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Alter_table_prelocking_strategy::handle_view </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Defines how prelocking algorithm for ALTER <a class="el" href="structTABLE.html">TABLE</a> statement should handle view - do nothing. We don't need to add view routines to the prelocking set in this case as view is not going to be materialized. </p>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a id="gae06de7ce22001b035ca61edf2a3dea09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae06de7ce22001b035ca61edf2a3dea09">&#9670;&nbsp;</a></span>lock_table_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lock_table_names </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Acquire "strong" (SRO, SNW, SNRW) metadata locks on tables used by LOCK TABLES or by a DDL statement.</p>
<p class="">Acquire lock "S" on table being created in CREATE <a class="el" href="structTABLE.html">TABLE</a> statement.</p>
<dl class="section note"><dt>Note</dt><dd>Under LOCK TABLES, we can't take new locks, so use open_tables_check_upgradable_mdl() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables_start</td><td>Start of list of tables on which locks should be acquired. </td></tr>
    <tr><td class="paramname">tables_end</td><td>End of list of tables. </td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classBitmap.html">Bitmap</a> of flags to modify how the tables will be open, see <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> description for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Success. </td></tr>
    <tr><td class="paramname">true</td><td>Failure (e.g. connection was killed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga399ec28859bb54829b1cabbeed845f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399ec28859bb54829b1cabbeed845f78">&#9670;&nbsp;</a></span>lock_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lock_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Lock all tables in a list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Tables to lock </td></tr>
    <tr><td class="paramname">count</td><td>Number of opened tables </td></tr>
    <tr><td class="paramname">flags</td><td>Options (see <a class="el" href="group__Locking.html#ga40d9de997ac2ee4f94f358ce1ac2d76a">mysql_lock_tables()</a> for details)</td></tr>
  </table>
  </dd>
</dl>
<p>You can't call <a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a> while holding thr_lock locks, as this would break the dead-lock-free handling thr_lock gives us. You must always get all needed locks at once.</p>
<p class="">If the query for which we are calling this function is marked as requiring prelocking, this function will change locked_tables_mode to LTM_PRELOCKED.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>A lock wait timeout, deadlock or out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2cc536b80faf27a1017cf4ddcc988ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2cc536b80faf27a1017cf4ddcc988ad">&#9670;&nbsp;</a></span>mark_tmp_table_for_reuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark_tmp_table_for_reuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reset a single temporary table. Effectively this "closes" one temporary table, in a session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Temporary table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab469748dd06a6477d4ce23f742af0794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab469748dd06a6477d4ce23f742af0794">&#9670;&nbsp;</a></span>open_and_lock_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_and_lock_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open all tables in list, locks them and optionally process derived tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables</td><td><a class="el" href="classList.html">List</a> of tables for open and locking. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classBitmap.html">Bitmap</a> of options to be used to open and lock tables (see <a class="el" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables()</a> and <a class="el" href="group__Locking.html#ga40d9de997ac2ee4f94f358ce1ac2d76a">mysql_lock_tables()</a> for details). </td></tr>
    <tr><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The thr_lock locks will automatically be freed by close_thread_tables().</dd>
<dd>
<a class="el" href="group__Data__Dictionary.html#gab469748dd06a6477d4ce23f742af0794">open_and_lock_tables()</a> is not intended for open-and-locking system tables in those cases when execution of statement has started already and other tables have been opened. Use <a class="el" href="group__Data__Dictionary.html#ga5564f0cf7807256a52a9455fd4f45d4e">open_nontrans_system_tables_for_read()</a> or <a class="el" href="group__Data__Dictionary.html#gac315ba0102697b41bdeeff67a61240eb">open_trans_system_tables_for_read()</a> instead.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga065f6a0326ab135938fb38fd371dace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga065f6a0326ab135938fb38fd371dace5">&#9670;&nbsp;</a></span>open_log_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* open_log_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>one_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Open_tables_backup *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open a log table. Opening such tables is performed internally in the server implementation, and is a 'nested' open, since some tables might be already opened by the current thread. The thread context before this call is saved, and is restored when calling <a class="el" href="group__Data__Dictionary.html#ga8f22fa867e1bb56d350834b5497c9d6d">close_log_table()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">one_table</td><td>Log table to open </td></tr>
    <tr><td class="paramname">backup</td><td>[out] Temporary storage used to save the thread context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86a68932d1c35b3fd820c99d185d7888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86a68932d1c35b3fd820c99d185d7888">&#9670;&nbsp;</a></span>open_n_lock_single_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* open_n_lock_single_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open and lock one table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_l</td><td>table to open is first table in this list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_type</td><td>lock to use for table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>options to be used while opening and locking table (see <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a>, <a class="el" href="group__Locking.html#ga40d9de997ac2ee4f94f358ce1ac2d76a">mysql_lock_tables()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">!=</td><td>NULL OK, opened table returned </td></tr>
    <tr><td class="paramname">NULL</td><td>Error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If ok, the following are also set: table_list-&gt;lock_type lock_type table_list-&gt;table table</dd>
<dd>
If table_l is a list, not a single table, the list is temporarily broken.</dd></dl>
<p>This function is meant as a replacement for open_ltable() when MERGE tables can be opened. open_ltable() cannot open MERGE tables.</p>
<p class="">There may be more differences between <a class="el" href="group__Data__Dictionary.html#ga86a68932d1c35b3fd820c99d185d7888" title="Open and lock one table.">open_n_lock_single_table()</a> and open_ltable(). One known difference is that open_ltable() does neither call thd-&gt;decide_logging_format() nor handle some other logging and locking issues because it does not call <a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a>. </p>

</div>
</div>
<a id="ga5564f0cf7807256a52a9455fd4f45d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5564f0cf7807256a52a9455fd4f45d4e">&#9670;&nbsp;</a></span>open_nontrans_system_tables_for_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_nontrans_system_tables_for_read </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Open_tables_backup *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open and lock non-transactional system tables for read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table_list</td><td><a class="el" href="classList.html">List</a> of tables to open. </td></tr>
    <tr><td class="paramname">backup</td><td>Pointer to Open_tables_backup instance where information about currently open tables will be saved, and from which will be restored when we will end work with non-transactional system tables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>THR_LOCK deadlocks are not possible here because of the restrictions we put on opening and locking of system tables for writing. Thus, the system tables can be opened and locked for reading even if some other tables have already been opened and locked.</dd>
<dd>
MDL-deadlocks are possible, but they are properly detected and reported.</dd>
<dd>
This call will eventually be removed as an InnoDB attachable transaction will be used to access all system tables.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="ga43cb5a9ba1064a36db89ad5c4d645528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43cb5a9ba1064a36db89ad5c4d645528">&#9670;&nbsp;</a></span>open_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpen__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open a base table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table_list</td><td>Open first table in list. </td></tr>
    <tr><td class="paramname">ot_ctx</td><td>Context with flags which modify how open works and which is used to recover from a failed <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> attempt. Some examples of flags: MYSQL_OPEN_IGNORE_FLUSH - Open table even if someone has done a flush. No version number checking is done. MYSQL_OPEN_HAS_MDL_LOCK - instead of acquiring metadata locks rely on that caller already has appropriate ones.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses a cache of open tables to find a <a class="el" href="structTABLE.html">TABLE</a> instance not in use.</p>
<p class="">If <a class="el" href="structTABLE__LIST.html#aa5584240bf59a147fff802fb18e1704e">TABLE_LIST::open_strategy</a> is set to OPEN_IF_EXISTS, the table is opened only if it exists. If the open strategy is OPEN_STUB, the underlying table is never opened. In both cases, metadata locks are always taken according to the lock strategy.</p>
<p class="">The function used to open temporary tables, but now it opens base tables only.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Open failed. "action" parameter may contain type of action needed to remedy problem before retrying again. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Success. Members of <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> structure are filled properly (e.g. TABLE_LIST::table is set for real tables and TABLE_LIST::view is set for views). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8eaa3b1fdce29eac72028f96c55607d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eaa3b1fdce29eac72028f96c55607d3">&#9670;&nbsp;</a></span>Open_table_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Open_table_context::Open_table_context </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class=""><a class="el" href="classOpen__table__context.html">Open_table_context</a> </p>

</div>
</div>
<a id="ga35659d6f0f8a6d39ee3f3db7c233df52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35659d6f0f8a6d39ee3f3db7c233df52">&#9670;&nbsp;</a></span>open_table_uncached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* open_table_uncached </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_to_temporary_tables_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>open_in_engine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open a single table without table caching and don't add it to THD::open_tables. Depending on the 'add_to_temporary_tables_list' value, the opened <a class="el" href="structTABLE.html">TABLE</a> instance will be addded to THD::temporary_tables list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">path</td><td>Path (without .frm) </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">add_to_temporary_tables_list</td><td>Specifies if the opened <a class="el" href="structTABLE.html">TABLE</a> instance should be linked into THD::temporary_tables list. </td></tr>
    <tr><td class="paramname">open_in_engine</td><td>Indicates that we need to open table in storage engine in addition to constructing <a class="el" href="structTABLE.html">TABLE</a> object for it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is used:<ul>
<li>by alter_table() to open a temporary table;</li>
<li>when creating a temporary table with CREATE TEMPORARY <a class="el" href="structTABLE.html">TABLE</a>.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structTABLE.html">TABLE</a> instance for opened table. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59e488af7a3f47be08fad22370de07c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e488af7a3f47be08fad22370de07c5">&#9670;&nbsp;</a></span>open_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open all tables in list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">start</td><td><a class="el" href="classList.html">List</a> of tables to be open (it can be adjusted for statement that uses tables only implicitly, e.g. for "SELECT f1()"). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter</td><td>Number of tables which were open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td><a class="el" href="classBitmap.html">Bitmap</a> of flags to modify how the tables will be open, see <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> description for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unless we are already in prelocked mode and prelocking strategy prescribes so this function will also precache all SP/SFs explicitly or implicitly (via views and triggers) used by the query and add tables needed for their execution to table list. Statement that uses SFs, invokes triggers or requires foreign key checks will be marked as requiring prelocking. Prelocked mode will be enabled for such query during <a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a> call.</dd></dl>
<p>If query for which we are opening tables is already marked as requiring prelocking it won't do such precaching and will simply reuse table list which is already built.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error, reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b93d2956c1e654ebe0e48ab3503410d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b93d2956c1e654ebe0e48ab3503410d">&#9670;&nbsp;</a></span>open_tables_for_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_tables_for_query </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open all tables for a query or statement, in list started by "tables"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>list of tables for open </td></tr>
    <tr><td class="paramname">flags</td><td>bitmap of flags to modify how the tables will be open: MYSQL_LOCK_IGNORE_FLUSH - open table even if someone has done a flush on it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- ok </td></tr>
    <tr><td class="paramname">true</td><td>- error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is to be used on prepare stage when you don't read any data from the tables.</dd>
<dd>
Updates Query_tables_list::table_count as side-effect. </dd></dl>

</div>
</div>
<a id="gab5c68673b37e4f394de31ffe4ac80fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c68673b37e4f394de31ffe4ac80fcc">&#9670;&nbsp;</a></span>open_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_temporary_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find a temporary table specified by <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> instance in the cache and prepare its <a class="el" href="structTABLE.html">TABLE</a> instance for use.</p>
<p class="">This function tries to resolve this table in the list of temporary tables of this thread. Temporary tables are thread-local and "shadow" base tables with the same name.</p>
<dl class="section note"><dt>Note</dt><dd>In most cases one should use <a class="el" href="group__Data__Dictionary.html#gac4c1cb71807d09d53273048447abf301">open_temporary_tables()</a> instead of this call.</dd>
<dd>
One should finalize process of opening temporary table for table list element by calling open_and_process_table(). This function is responsible for table version checking and handling of merge tables.</dd>
<dd>
We used to check global_read_lock before opening temporary tables. However, that limitation was artificial and is removed now.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>On success. If a temporary table exists for the given key, tl-&gt;table is set. </td></tr>
    <tr><td class="paramname">TRUE</td><td>On error. my_error() has been called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4c1cb71807d09d53273048447abf301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4c1cb71807d09d53273048447abf301">&#9670;&nbsp;</a></span>open_temporary_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_temporary_tables </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Pre-open temporary tables corresponding to table list elements.</p>
<dl class="section note"><dt>Note</dt><dd>One should finalize process of opening temporary tables by calling <a class="el" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables()</a>. This function is responsible for table version checking and handling of merge tables.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>On success. If a temporary tables exists for the given element, tl-&gt;table is set. </td></tr>
    <tr><td class="paramname">TRUE</td><td>On error. my_error() has been called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac315ba0102697b41bdeeff67a61240eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac315ba0102697b41bdeeff67a61240eb">&#9670;&nbsp;</a></span>open_trans_system_tables_for_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool open_trans_system_tables_for_read </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open and lock transactional system tables for read.</p>
<p class="">One must call <a class="el" href="group__Data__Dictionary.html#ga94ca9600b012ffde28a4a0360e91c0e8">close_trans_system_tables()</a> to close systems tables opened with this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table_list</td><td><a class="el" href="classList.html">List</a> of tables to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>THR_LOCK deadlocks are not possible here because of the restrictions we put on opening and locking of system tables for writing. Thus, the system tables can be opened and locked for reading even if some other tables have already been opened and locked.</dd>
<dd>
MDL-deadlocks are possible, but they are properly detected and reported.</dd>
<dd>
Row-level deadlocks should be either avoided altogether using non-locking reads (as it is done now for InnoDB), or should be correctly detected and reported (in case of other transactional SE).</dd>
<dd>
It is now technically possible to open non-transactional tables (MyISAM system tables) using this function. That situation might still happen if the user run the server on the elder data-directory or manually alters the system tables to reside in MyISAM instead of InnoDB. It will be forbidden in the future.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>

</div>
</div>
<a id="gade48892bc4607303f7f4d3d6df4c39de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade48892bc4607303f7f4d3d6df4c39de">&#9670;&nbsp;</a></span>recover_from_failed_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Open_table_context::recover_from_failed_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Recover from failed attempt of open table by performing requested action.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function should be called only with "action" != OT_NO_ACTION and after having called </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Data__Dictionary.html#ga92bec964ecaaa7270a429e664643b746">close_tables_for_reopen()</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>- Success. One should try to open tables once again. </td></tr>
    <tr><td class="paramname">TRUE</td><td>- Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f27eb7444d2cec48296785a54e229f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f27eb7444d2cec48296785a54e229f2">&#9670;&nbsp;</a></span>release_table_share()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void release_table_share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Mark that we are not using table share anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>Table share</td></tr>
  </table>
  </dd>
</dl>
<p>If the share has no open tables and (we have done a refresh or if we have already too many open table shares) then delete the definition. </p>

</div>
</div>
<a id="gaf35889f70c8719510fb76899cf9cf20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf35889f70c8719510fb76899cf9cf20b">&#9670;&nbsp;</a></span>request_backoff_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Open_table_context::request_backoff_action </td>
          <td>(</td>
          <td class="paramtype">enum_open_table_action&#160;</td>
          <td class="paramname"><em>action_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if we can back-off and set back off action if we can. Otherwise report and return error.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if back-off is impossible. </td></tr>
    <tr><td class="paramname">FALSE</td><td>if we can back off. Back off action has been set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f6730cd1feb3014042adbf998ca9203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6730cd1feb3014042adbf998ca9203">&#9670;&nbsp;</a></span>rm_temporary_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rm_temporary_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Delete a temporary table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Handlerton for table to be deleted. </td></tr>
    <tr><td class="paramname">path</td><td>Path to the table to be deleted (i.e. path to its .frm without an extension).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- success. </td></tr>
    <tr><td class="paramname">true</td><td>- failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed504cf321c7fd98175f80785f6be954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed504cf321c7fd98175f80785f6be954">&#9670;&nbsp;</a></span>run_before_dml_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int run_before_dml_hook </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Run the server hook called "before_dml". This is a hook originated from replication that allow server plugins to execute code before any DML instruction is executed. In case of negative outcome, it will set my_error to ER_BEFORE_DML_VALIDATION_ERROR</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hook outcome </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Everything is fine </td></tr>
    <tr><td class="paramname">!=0</td><td>Error in the outcome of the hook. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa6d4287d0d00fc5733a67df33a193738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6d4287d0d00fc5733a67df33a193738">&#9670;&nbsp;</a></span>setup_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setup_fields </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>want_privilege</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *&#160;</td>
          <td class="paramname"><em>sum_func_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_sum_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>column_update</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Resolve a list of expressions and setup appropriate data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ref_pointer_array</td><td>filled in with reference pointers. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fields</td><td>list of expressions, populated with resolved data about expressions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">want_privilege</td><td>privilege representing desired operation. whether the expressions are selected, inserted or updated, or no operation is done. will also decide inclusion in read/write maps. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sum_func_list</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allow_sum_func</td><td>true if set operations are allowed in context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">column_update</td><td>if true, reject expressions that do not resolve to a base table column</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gabb94e7a0682741b06d662be41fae480f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb94e7a0682741b06d662be41fae480f">&#9670;&nbsp;</a></span>table_def_start_shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void table_def_start_shutdown </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Notify table definition cache that process of shutting down server has started so it has to keep number of <a class="el" href="structTABLE.html">TABLE</a> and <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> objects minimal in order to reduce number of references to pluggable engines. </p>

</div>
</div>
<a id="ga917237a2e99cef2eb34e64095d79fb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga917237a2e99cef2eb34e64095d79fb1a">&#9670;&nbsp;</a></span>tdc_open_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tdc_open_view </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Open view by getting its definition from disk (and table cache in future).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table_list</td><td><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> with db, table_name &amp; belong_to_view </td></tr>
    <tr><td class="paramname">alias</td><td>Alias name </td></tr>
    <tr><td class="paramname">cache_key</td><td><a class="el" href="classKey.html">Key</a> for table definition cache </td></tr>
    <tr><td class="paramname">cache_key_length</td><td>Length of cache_key </td></tr>
    <tr><td class="paramname">flags</td><td>Flags which modify how we open the view</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000076">Todo:</a></b></dt><dd>This function is needed for special handling of views under LOCK TABLES. We probably should get rid of it in long term.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if success, TRUE - otherwise. </dd></dl>

</div>
</div>
<a id="ga8faf6c6118b6677394e14994ae614075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8faf6c6118b6677394e14994ae614075">&#9670;&nbsp;</a></span>tdc_remove_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tdc_remove_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_tdc_remove_table_type&#160;</td>
          <td class="paramname"><em>remove_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Remove all or some (depending on parameter) instances of <a class="el" href="structTABLE.html">TABLE</a> and <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> from the table definition cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">remove_type</td><td>Type of removal: TDC_RT_REMOVE_ALL - remove all <a class="el" href="structTABLE.html">TABLE</a> instances and <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> instance. There should be no used <a class="el" href="structTABLE.html">TABLE</a> objects and caller should have exclusive metadata lock on the table. TDC_RT_REMOVE_NOT_OWN - remove all <a class="el" href="structTABLE.html">TABLE</a> instances except those that belong to this thread. There should be no <a class="el" href="structTABLE.html">TABLE</a> objects used by other threads and caller should have exclusive metadata lock on the table. TDC_RT_REMOVE_UNUSED - remove all unused <a class="el" href="structTABLE.html">TABLE</a> instances (if there are no used instances will also remove <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>). TDC_RT_REMOVE_NOT_OWN_KEEP_SHARE - remove all <a class="el" href="structTABLE.html">TABLE</a> instances except those that belong to this thread, but don't mark <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> as old. There should be no <a class="el" href="structTABLE.html">TABLE</a> objects used by other threads and caller should have exclusive metadata lock on the table. </td></tr>
    <tr><td class="paramname">db</td><td>Name of database </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table </td></tr>
    <tr><td class="paramname">has_lock</td><td>If TRUE, LOCK_open is already acquired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It assumes that table instances are already not used by any (other) thread (this should be achieved by using meta-data locks). </dd></dl>

</div>
</div>
<a id="ga97300534246ab121f6b9b9d7031fb56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97300534246ab121f6b9b9d7031fb56e">&#9670;&nbsp;</a></span>unique_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>* unique_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Test that the subject table of INSERT/UPDATE/DELETE/CREATE or (in case of MyISAMMRG) one of its children are not used later in the query.</p>
<p class="">For MyISAMMRG tables, it is assumed that all the underlying tables of <code>table</code> (if any) are listed right after it and that their <code>parent_l</code> field points at the main table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">table</td><td>table to be checked (must be updatable base table) </td></tr>
    <tr><td class="paramname">table_list</td><td><a class="el" href="classList.html">List</a> of tables to check against </td></tr>
    <tr><td class="paramname">check_alias</td><td>whether to check tables' aliases</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">non-NULL</td><td>The table list element for the table that represents the duplicate. </td></tr>
    <tr><td class="paramname">NULL</td><td>No duplicates found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa62ea49fa4b58a38f20af4754928e1be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62ea49fa4b58a38f20af4754928e1be">&#9670;&nbsp;</a></span>update_non_unique_table_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_non_unique_table_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Issue correct error message in case we found 2 duplicate tables which prevent some update operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>table which we try to update </td></tr>
    <tr><td class="paramname">operation</td><td>name of update operation </td></tr>
    <tr><td class="paramname">duplicate</td><td>duplicate table which we found</td></tr>
  </table>
  </dd>
</dl>
<p>here we hide view underlying tables if we have them. </p>

</div>
</div>
<a id="gac19a8c14e089f35b82dc7a2ded67ea4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac19a8c14e089f35b82dc7a2ded67ea4b">&#9670;&nbsp;</a></span>wait_while_table_is_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_while_table_is_used </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_extra_function&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Force all other threads to stop using the table by upgrading metadata lock on it and remove unused <a class="el" href="structTABLE.html">TABLE</a> instances from cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">table</td><td>Table to remove from cache </td></tr>
    <tr><td class="paramname">function</td><td>HA_EXTRA_PREPARE_FOR_DROP if table is to be deleted HA_EXTRA_FORCE_REOPEN if table is not be used HA_EXTRA_PREPARE_FOR_RENAME if table is to be renamed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When returning, the table will be unusable for other threads until metadata lock is downgraded.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (e.g. because thread was killed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga7a682517d27176617b45212332a96a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a682517d27176617b45212332a96a9d">&#9670;&nbsp;</a></span>COND_open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysql_cond_t COND_open</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">COND_open synchronizes concurrent opening of the same share:</p>
<p class="">If a thread calls get_table_share, it releases the LOCK_open mutex while reading the definition from file. If a different thread calls get_table_share for the same share at this point in time, it will find the share in the TDC, but with the m_open_in_progress flag set to true. This will make the (second) thread wait for the COND_open condition, while the first thread completes opening the table definition.</p>
<p class="">When the first thread is done reading the table definition, it will set m_open_in_progress to false and broadcast the COND_open condition. Then, all threads waiting for COND_open will wake up and, re-search the TDC for the share, and:</p>
<p class="">1) If the share is gone, the thread will continue to allocate and open the table definition. This happens, e.g., if the first thread failed when opening the table defintion and had to destroy the share. 2) If the share is still in the cache, and m_open_in_progress is still true, the thread will wait for the condition again. This happens if a different thread finished opening a different share. 3) If the share is still in the cache, and m_open_in_progress has become false, the thread will check if the share is ok (no error), increment the ref counter, and return the share. </p>

</div>
</div>
<a id="ga99c8e1e3e72cd74032d5f11c486911fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c8e1e3e72cd74032d5f11c486911fd">&#9670;&nbsp;</a></span>LOCK_open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysql_mutex_t LOCK_open</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">LOCK_open protects the following variables/objects:</p>
<p class="">1) The table_def_cache This is the hash table mapping table name to a table share object. The hash table can only be manipulated while holding LOCK_open. 2) last_table_id Generation of a new unique table_map_id for a table share is done through incrementing last_table_id, a global variable used for this purpose. 3) LOCK_open protects the initialisation of the table share object and all its members, however, it does not protect reading the .frm file from where the table share is initialised. In get_table_share, the lock is temporarily released while opening the table definition in order to allow a higher degree of concurrency. Concurrent access to the same share is controlled by introducing a condition variable for signaling when opening the share is completed. 4) In particular the share-&gt;ref_count is updated each time a new table object is created that refers to a table share. This update is protected by LOCK_open. 5) oldest_unused_share, end_of_unused_share and share-&gt;next and share-&gt;prev are variables to handle the lists of table share objects, these can only be read and manipulated while holding the LOCK_open mutex. 6) table_def_shutdown_in_progress can be updated only while holding LOCK_open and ALL table cache mutexes. 7) refresh_version This variable can only be updated while holding LOCK_open AND all table cache mutexes. 8) share-&gt;version This variable is initialised while holding LOCK_open. It can only be updated while holding LOCK_open AND all table cache mutexes. So if a table share is found through a reference its version won't change if any of those mutexes are held. 9) share-&gt;m_flush_tickets </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
