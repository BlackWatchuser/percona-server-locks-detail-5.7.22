<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: MDL_lock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classMDL__lock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MDL_lock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af49d3a2db62c2c6dda844e0d4531ab12"><td class="memItemLeft" align="right" valign="top"><a id="af49d3a2db62c2c6dda844e0d4531ab12"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>bitmap_t</b></td></tr>
<tr class="separator:af49d3a2db62c2c6dda844e0d4531ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cdf73e78c2f3288e20676e9ec19ea5"><td class="memItemLeft" align="right" valign="top"><a id="a32cdf73e78c2f3288e20676e9ec19ea5"></a>
typedef <a class="el" href="classI__P__List__iterator.html">Ticket_list::List::Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Ticket_iterator</b></td></tr>
<tr class="separator:a32cdf73e78c2f3288e20676e9ec19ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc52a5a78b9a3b911e91c2fcb932981a"><td class="memItemLeft" align="right" valign="top"><a id="afc52a5a78b9a3b911e91c2fcb932981a"></a>
typedef longlong&#160;</td><td class="memItemRight" valign="bottom"><b>fast_path_state_t</b></td></tr>
<tr class="separator:afc52a5a78b9a3b911e91c2fcb932981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc63c21b6c75b3087cd273bc5125e9d0"><td class="memItemLeft" align="right" valign="top"><a id="acc63c21b6c75b3087cd273bc5125e9d0"></a>
const bitmap_t *&#160;</td><td class="memItemRight" valign="bottom"><b>incompatible_granted_types_bitmap</b> () const</td></tr>
<tr class="separator:acc63c21b6c75b3087cd273bc5125e9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90ab350d28e755dcfa69d90004de7aa"><td class="memItemLeft" align="right" valign="top"><a id="aa90ab350d28e755dcfa69d90004de7aa"></a>
const bitmap_t *&#160;</td><td class="memItemRight" valign="bottom"><b>incompatible_waiting_types_bitmap</b> () const</td></tr>
<tr class="separator:aa90ab350d28e755dcfa69d90004de7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbc9d77579dd73637b2cc95b7fc249f"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#afbbc9d77579dd73637b2cc95b7fc249f">get_incompatible_waiting_types_bitmap_idx</a> () const</td></tr>
<tr class="separator:afbbc9d77579dd73637b2cc95b7fc249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2be5e68445003d7a516849f2bceb18c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ab2be5e68445003d7a516849f2bceb18c">switch_incompatible_waiting_types_bitmap_if_needed</a> ()</td></tr>
<tr class="separator:ab2be5e68445003d7a516849f2bceb18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7707e02d9695b5694336787a622b0060"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a7707e02d9695b5694336787a622b0060">has_pending_conflicting_lock</a> (enum_mdl_type type)</td></tr>
<tr class="separator:a7707e02d9695b5694336787a622b0060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8e8e3b98525a6c8de14a745dd3ce8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a8d8e8e3b98525a6c8de14a745dd3ce8f">can_grant_lock</a> (enum_mdl_type type, const <a class="el" href="classMDL__context.html">MDL_context</a> *requestor_ctx) const</td></tr>
<tr class="separator:a8d8e8e3b98525a6c8de14a745dd3ce8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07003cc6619a99b6cc36f564c62e4e94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a07003cc6619a99b6cc36f564c62e4e94">reschedule_waiters</a> ()</td></tr>
<tr class="separator:a07003cc6619a99b6cc36f564c62e4e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7100ea62bb9af3e959d8a81ba11d4bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a7100ea62bb9af3e959d8a81ba11d4bcb">remove_ticket</a> (<a class="el" href="classMDL__context.html">MDL_context</a> *ctx, LF_PINS *pins, <a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a> MDL_lock::*queue, <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="separator:a7100ea62bb9af3e959d8a81ba11d4bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e5025d3f3cff97923bc283c715566d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a56e5025d3f3cff97923bc283c715566d">visit_subgraph</a> (<a class="el" href="classMDL__ticket.html">MDL_ticket</a> *waiting_ticket, <a class="el" href="classMDL__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *gvisitor)</td></tr>
<tr class="separator:a56e5025d3f3cff97923bc283c715566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eddfbd81b16d050a7a7d5a31e4242c6"><td class="memItemLeft" align="right" valign="top"><a id="a1eddfbd81b16d050a7a7d5a31e4242c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>needs_notification</b> (const <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *ticket) const</td></tr>
<tr class="separator:a1eddfbd81b16d050a7a7d5a31e4242c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b6aaea388daf444e3f2c0d31362b15"><td class="memItemLeft" align="right" valign="top"><a id="a20b6aaea388daf444e3f2c0d31362b15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>notify_conflicting_locks</b> (<a class="el" href="classMDL__context.html">MDL_context</a> *ctx)</td></tr>
<tr class="separator:a20b6aaea388daf444e3f2c0d31362b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb8fcb19fe7323eb0044ebb78258c75"><td class="memItemLeft" align="right" valign="top"><a id="a5bb8fcb19fe7323eb0044ebb78258c75"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>needs_connection_check</b> () const</td></tr>
<tr class="separator:a5bb8fcb19fe7323eb0044ebb78258c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af5a6e02d50241f9c6417a01572c4ee"><td class="memItemLeft" align="right" valign="top"><a id="a7af5a6e02d50241f9c6417a01572c4ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_affected_by_max_write_lock_count</b> () const</td></tr>
<tr class="separator:a7af5a6e02d50241f9c6417a01572c4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f1b569ef4a8405826d9bc9720205c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a39f1b569ef4a8405826d9bc9720205c0">count_piglets_and_hogs</a> (enum_mdl_type type)</td></tr>
<tr class="separator:a39f1b569ef4a8405826d9bc9720205c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2a62914d438aa6e97a50fc8050c74"><td class="memItemLeft" align="right" valign="top">fast_path_state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa5f2a62914d438aa6e97a50fc8050c74">get_unobtrusive_lock_increment</a> (enum_mdl_type type) const</td></tr>
<tr class="separator:aa5f2a62914d438aa6e97a50fc8050c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0438fd341e3bedb63452c44ec95a00ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a0438fd341e3bedb63452c44ec95a00ff">is_obtrusive_lock</a> (enum_mdl_type type) const</td></tr>
<tr class="separator:a0438fd341e3bedb63452c44ec95a00ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d77e8b91c3f09ac46adb6dccf7a460"><td class="memItemLeft" align="right" valign="top">bitmap_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a44d77e8b91c3f09ac46adb6dccf7a460">fast_path_granted_bitmap</a> () const</td></tr>
<tr class="separator:a44d77e8b91c3f09ac46adb6dccf7a460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9c4ffed74256bb57fca7619d141bf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aeb9c4ffed74256bb57fca7619d141bf4">MDL_lock</a> ()</td></tr>
<tr class="separator:aeb9c4ffed74256bb57fca7619d141bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2f6326006b7c7ba179075c82707d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aaa2f6326006b7c7ba179075c82707d59">reinit</a> (const <a class="el" href="structMDL__key.html">MDL_key</a> *mdl_key)</td></tr>
<tr class="separator:aaa2f6326006b7c7ba179075c82707d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada93a4c2a1f01792f9c3e352dbf900fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ada93a4c2a1f01792f9c3e352dbf900fc">get_lock_owner</a> () const</td></tr>
<tr class="separator:ada93a4c2a1f01792f9c3e352dbf900fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716b40d532b18db6c2527d1a46908c29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a716b40d532b18db6c2527d1a46908c29">fast_path_state_cas</a> (fast_path_state_t *old_state, fast_path_state_t new_state)</td></tr>
<tr class="separator:a716b40d532b18db6c2527d1a46908c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc838e4678e75b56554e1ca142439dce"><td class="memItemLeft" align="right" valign="top">fast_path_state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#afc838e4678e75b56554e1ca142439dce">fast_path_state_add</a> (fast_path_state_t value)</td></tr>
<tr class="separator:afc838e4678e75b56554e1ca142439dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedaf89f7d4526d4d59c170fed9ffe2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aeedaf89f7d4526d4d59c170fed9ffe2a">fast_path_state_reset</a> ()</td></tr>
<tr class="separator:aeedaf89f7d4526d4d59c170fed9ffe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa6cbff270ec3afad0feba7e97e9747bb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa6cbff270ec3afad0feba7e97e9747bb">needs_hton_notification</a> (<a class="el" href="structMDL__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a> mdl_namespace)</td></tr>
<tr class="separator:aa6cbff270ec3afad0feba7e97e9747bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8424d2f478663117e7ac5e435840342"><td class="memItemLeft" align="right" valign="top">static fast_path_state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa8424d2f478663117e7ac5e435840342">get_unobtrusive_lock_increment</a> (const <a class="el" href="classMDL__request.html">MDL_request</a> *request)</td></tr>
<tr class="separator:aa8424d2f478663117e7ac5e435840342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8389ffdedfe45d4fdc22624a3ad84a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMDL__lock.html">MDL_lock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a3d8389ffdedfe45d4fdc22624a3ad84a">create</a> (const <a class="el" href="structMDL__key.html">MDL_key</a> *<a class="el" href="classMDL__lock.html#aefb48179bc3f6ef64c213b253c379da4">key</a>)</td></tr>
<tr class="separator:a3d8389ffdedfe45d4fdc22624a3ad84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b25c48d98250c1603a5c55eeace3986"><td class="memItemLeft" align="right" valign="top"><a id="a0b25c48d98250c1603a5c55eeace3986"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>destroy</b> (<a class="el" href="classMDL__lock.html">MDL_lock</a> *lock)</td></tr>
<tr class="separator:a0b25c48d98250c1603a5c55eeace3986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5ce95948e006dbe957792a4be80928"><td class="memItemLeft" align="right" valign="top">static bitmap_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a8d5ce95948e006dbe957792a4be80928">scoped_lock_fast_path_granted_bitmap</a> (const <a class="el" href="classMDL__lock.html">MDL_lock</a> &amp;lock)</td></tr>
<tr class="separator:a8d5ce95948e006dbe957792a4be80928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382145d0f9b0f94a05ef03edbe922054"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a382145d0f9b0f94a05ef03edbe922054">object_lock_needs_notification</a> (const <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *ticket)</td></tr>
<tr class="separator:a382145d0f9b0f94a05ef03edbe922054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30406c0d7d46396e15c4ca66abc6fc7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aa30406c0d7d46396e15c4ca66abc6fc7">object_lock_notify_conflicting_locks</a> (<a class="el" href="classMDL__context.html">MDL_context</a> *ctx, <a class="el" href="classMDL__lock.html">MDL_lock</a> *lock)</td></tr>
<tr class="separator:aa30406c0d7d46396e15c4ca66abc6fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580d9a0d9be93f90361cee67d0b4199f"><td class="memItemLeft" align="right" valign="top">static bitmap_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a580d9a0d9be93f90361cee67d0b4199f">object_lock_fast_path_granted_bitmap</a> (const <a class="el" href="classMDL__lock.html">MDL_lock</a> &amp;lock)</td></tr>
<tr class="separator:a580d9a0d9be93f90361cee67d0b4199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab1e1914e48faa93ba2e862cddfc274"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a1ab1e1914e48faa93ba2e862cddfc274">object_lock_needs_connection_check</a> (const <a class="el" href="classMDL__lock.html">MDL_lock</a> *lock)</td></tr>
<tr class="separator:a1ab1e1914e48faa93ba2e862cddfc274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aefb48179bc3f6ef64c213b253c379da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMDL__key.html">MDL_key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aefb48179bc3f6ef64c213b253c379da4">key</a></td></tr>
<tr class="separator:aefb48179bc3f6ef64c213b253c379da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1308b4506d8cb6d754b4f173e3aa4962"><td class="memItemLeft" align="right" valign="top">mysql_prlock_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">m_rwlock</a></td></tr>
<tr class="separator:a1308b4506d8cb6d754b4f173e3aa4962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188dd53561f6cf6148277512b706ea74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a188dd53561f6cf6148277512b706ea74">m_granted</a></td></tr>
<tr class="separator:a188dd53561f6cf6148277512b706ea74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4443cad6b484e2af5c816949ddb209dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a4443cad6b484e2af5c816949ddb209dc">m_waiting</a></td></tr>
<tr class="separator:a4443cad6b484e2af5c816949ddb209dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef26eb4cf46309c494135291a82e20c"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a7ef26eb4cf46309c494135291a82e20c">m_obtrusive_locks_granted_waiting_count</a></td></tr>
<tr class="separator:a7ef26eb4cf46309c494135291a82e20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae680877b7079a862d294ccbefed6372c"><td class="memItemLeft" align="right" valign="top">volatile fast_path_state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">m_fast_path_state</a></td></tr>
<tr class="separator:ae680877b7079a862d294ccbefed6372c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a214605da83d57ac8d69c1f1c4854d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a67a214605da83d57ac8d69c1f1c4854d">m_strategy</a></td></tr>
<tr class="separator:a67a214605da83d57ac8d69c1f1c4854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1627af1fd21d2ae76c27b39901e574a3"><td class="memItemLeft" align="right" valign="top">static const fast_path_state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a1627af1fd21d2ae76c27b39901e574a3">IS_DESTROYED</a> = 1ULL &lt;&lt; 62</td></tr>
<tr class="separator:a1627af1fd21d2ae76c27b39901e574a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e55394e253bd9d0988c9a7ab243a39"><td class="memItemLeft" align="right" valign="top">static const fast_path_state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ac0e55394e253bd9d0988c9a7ab243a39">HAS_OBTRUSIVE</a> = 1ULL &lt;&lt; 61</td></tr>
<tr class="separator:ac0e55394e253bd9d0988c9a7ab243a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace80291dc2f7786288cdf1cec54bcb55"><td class="memItemLeft" align="right" valign="top">static const fast_path_state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#ace80291dc2f7786288cdf1cec54bcb55">HAS_SLOW_PATH</a> = 1ULL &lt;&lt; 60</td></tr>
<tr class="separator:ace80291dc2f7786288cdf1cec54bcb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeb101565637f92f74d4a84bdc53fa5"><td class="memItemLeft" align="right" valign="top">static const bitmap_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#abaeb101565637f92f74d4a84bdc53fa5">MDL_OBJECT_HOG_LOCK_TYPES</a></td></tr>
<tr class="separator:abaeb101565637f92f74d4a84bdc53fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7a092b4b9aa426597f599feb6bb19b"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#aed7a092b4b9aa426597f599feb6bb19b">m_scoped_lock_strategy</a></td></tr>
<tr class="separator:aed7a092b4b9aa426597f599feb6bb19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed94b58baea6bf2e22b76566aa513b3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__lock.html#a6ed94b58baea6bf2e22b76566aa513b3">m_object_lock_strategy</a></td></tr>
<tr class="separator:a6ed94b58baea6bf2e22b76566aa513b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">The lock context. Created internally for an acquired lock. For a given name, there exists only one <a class="el" href="classMDL__lock.html">MDL_lock</a> instance, and it exists only when the lock has been granted. Can be seen as an MDL subsystem's version of <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>.</p>
<p class="">This is an abstract class which lacks information about compatibility rules for lock types. They should be specified in its descendants. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeb9c4ffed74256bb57fca7619d141bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9c4ffed74256bb57fca7619d141bf4">&#9670;&nbsp;</a></span>MDL_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MDL_lock::MDL_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Do "expensive" part of <a class="el" href="classMDL__lock.html">MDL_lock</a> object initialization, Called by LF_ALLOCATOR for each newly malloc()'ed <a class="el" href="classMDL__lock.html">MDL_lock</a> object, is not called in cases when LF_ALLOCATOR decides to reuse object which was returned to it earlier. "Full" initialization happens later by calling <a class="el" href="classMDL__lock.html#aaa2f6326006b7c7ba179075c82707d59">MDL_lock::reinit()</a>. So </p><dl class="section see"><dt>See also</dt><dd>MDL_lock::reiniti() </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d8e8e3b98525a6c8de14a745dd3ce8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8e8e3b98525a6c8de14a745dd3ce8f">&#9670;&nbsp;</a></span>can_grant_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::can_grant_lock </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>type_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td>
          <td class="paramname"><em>requestor_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if request for the metadata lock can be satisfied given its current state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_arg</td><td>The requested lock type. </td></tr>
    <tr><td class="paramname">requestor_ctx</td><td>The MDL context of the requestor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Lock request can be satisfied </td></tr>
    <tr><td class="paramname">FALSE</td><td>There is some conflicting lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In cases then current context already has "stronger" type of lock on the object it will be automatically granted thanks to usage of the MDL_context::find_ticket() method. </dd></dl>

</div>
</div>
<a id="a39f1b569ef4a8405826d9bc9720205c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f1b569ef4a8405826d9bc9720205c0">&#9670;&nbsp;</a></span>count_piglets_and_hogs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::count_piglets_and_hogs </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If we just have granted a lock of "piglet" or "hog" type and there are pending lower priority locks, increase the appropriate counter. If this counter now exceeds the max_write_lock_count threshold, switch priority matrice for the <a class="el" href="classMDL__lock.html">MDL_lock</a> object.</p>
<dl class="section return"><dt>Returns</dt><dd>true - if priority matrice has been changed, false - otherwise. </dd></dl>

</div>
</div>
<a id="a3d8389ffdedfe45d4fdc22624a3ad84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8389ffdedfe45d4fdc22624a3ad84a">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock.html">MDL_lock</a> * MDL_lock::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMDL__key.html">MDL_key</a> *&#160;</td>
          <td class="paramname"><em>mdl_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Auxiliary functions needed for creation/destruction of <a class="el" href="classMDL__lock.html">MDL_lock</a> objects. </p>

</div>
</div>
<a id="a44d77e8b91c3f09ac46adb6dccf7a460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d77e8b91c3f09ac46adb6dccf7a460">&#9670;&nbsp;</a></span>fast_path_granted_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bitmap_t MDL_lock::fast_path_granted_bitmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Return set of types of lock requests which were granted using "fast path" algorithm in the bitmap_t form.</p>
<p class="">This method is only called from <a class="el" href="classMDL__lock.html#a8d8e8e3b98525a6c8de14a745dd3ce8f">MDL_lock::can_grant_lock()</a> and its return value is only important when we are trying to figure out if we can grant an obtrusive lock. But this means that the HAS_OBTRUSIVE flag is set so all changes to m_fast_path_state happen under protection of <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> (see invariant [INV1]). Since <a class="el" href="classMDL__lock.html#a8d8e8e3b98525a6c8de14a745dd3ce8f">can_grant_lock()</a> is called only when <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> is held, it is safe to do an ordinary read of m_fast_path_state here. </p>

</div>
</div>
<a id="afc838e4678e75b56554e1ca142439dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc838e4678e75b56554e1ca142439dce">&#9670;&nbsp;</a></span>fast_path_state_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fast_path_state_t MDL_lock::fast_path_state_add </td>
          <td>(</td>
          <td class="paramtype">fast_path_state_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Wrapper for my_atomic_add64 operation on m_fast_path_state member which enforces locking and other invariants. </p>

</div>
</div>
<a id="a716b40d532b18db6c2527d1a46908c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716b40d532b18db6c2527d1a46908c29">&#9670;&nbsp;</a></span>fast_path_state_cas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::fast_path_state_cas </td>
          <td>(</td>
          <td class="paramtype">fast_path_state_t *&#160;</td>
          <td class="paramname"><em>old_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fast_path_state_t&#160;</td>
          <td class="paramname"><em>new_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Wrapper for my_atomic_cas64 operation on m_fast_path_state member which enforces locking and other invariants. </p>

</div>
</div>
<a id="aeedaf89f7d4526d4d59c170fed9ffe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedaf89f7d4526d4d59c170fed9ffe2a">&#9670;&nbsp;</a></span>fast_path_state_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::fast_path_state_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Wrapper for resetting m_fast_path_state enforcing locking invariants. </p>

</div>
</div>
<a id="afbbc9d77579dd73637b2cc95b7fc249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbc9d77579dd73637b2cc95b7fc249f">&#9670;&nbsp;</a></span>get_incompatible_waiting_types_bitmap_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint MDL_lock::get_incompatible_waiting_types_bitmap_idx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get index of priority matrice in <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html#a040ce09f82f272cc3162c9eee05d45ef">MDL_lock_strategy::m_waiting_incompatible</a> array which corresponds to current values of the m_piglet_lock_count and m_hog_lock_count counters and the max_write_lock_count threshold. </p>

</div>
</div>
<a id="ada93a4c2a1f01792f9c3e352dbf900fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada93a4c2a1f01792f9c3e352dbf900fc">&#9670;&nbsp;</a></span>get_lock_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__context.html">MDL_context</a> * MDL_lock::get_lock_owner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Return the first <a class="el" href="classMDL__context.html">MDL_context</a> which owns the lock.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first <a class="el" href="classMDL__context.html">MDL_context</a> which has acquired the lock NULL if there are no such contexts.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method works properly only for locks acquired using "slow" path. It won't return context if it has used "fast" path to acquire the lock. </dd></dl>

</div>
</div>
<a id="aa8424d2f478663117e7ac5e435840342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8424d2f478663117e7ac5e435840342">&#9670;&nbsp;</a></span>get_unobtrusive_lock_increment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MDL_lock::fast_path_state_t MDL_lock::get_unobtrusive_lock_increment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__request.html">MDL_request</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>"Fast path" increment for request for "unobtrusive" type of lock, 0 - if it is request for "obtrusive" type of lock.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>We split all lock types for each of MDL namespaces in two sets:</dd></dl>
<p>A) "unobtrusive" lock types 1) Each type from this set should be compatible with all other types from the set (including itself). 2) These types should be common for DML operations</p>
<p class="">Our goal is to optimize acquisition and release of locks of this type by avoiding complex checks and manipulations on m_waiting/ m_granted bitmaps/lists. We replace them with a check of and increment/decrement of integer counters. We call the latter type of acquisition/release "fast path". Use of "fast path" reduces the size of critical section associated with <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> lock in the common case and thus increases scalability.</p>
<p class="">The amount by which acquisition/release of specific type "unobtrusive" lock increases/decreases packed counter in <a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">MDL_lock::m_fast_path_state</a> is returned by this function.</p>
<p class="">B) "obtrusive" lock types 1) Granted or pending lock of those type is incompatible with some other types of locks or with itself. 2) Not common for DML operations</p>
<p class="">These locks have to be always acquired involving manipulations on m_waiting/m_granted bitmaps/lists, i.e. we have to use "slow path" for them. Moreover in the presence of active/pending locks from "obtrusive" set we have to acquire using "slow path" even locks of "unobtrusive" type.</p>
<dl class="section see"><dt>See also</dt><dd>MDL_scoped_lock/MDL_object_lock::m_unobtrusive_lock_increment for definitions of these sets for scoped and per-object locks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>"Fast path" increment for request for "unobtrusive" type of lock, 0 - if it is request for "obtrusive" type of lock.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Description at method declaration for more details. </dd></dl>

</div>
</div>
<a id="aa5f2a62914d438aa6e97a50fc8050c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f2a62914d438aa6e97a50fc8050c74">&#9670;&nbsp;</a></span>get_unobtrusive_lock_increment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fast_path_state_t MDL_lock::get_unobtrusive_lock_increment </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>"Fast path" increment if type of lock is "unobtrusive" type, 0 - if it is "obtrusive" type of lock. </dd></dl>

</div>
</div>
<a id="a7707e02d9695b5694336787a622b0060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7707e02d9695b5694336787a622b0060">&#9670;&nbsp;</a></span>has_pending_conflicting_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::has_pending_conflicting_lock </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if we have any pending locks which conflict with existing shared lock.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The ticket must match an acquired lock.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if there is a conflicting lock request, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a0438fd341e3bedb63452c44ec95a00ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0438fd341e3bedb63452c44ec95a00ff">&#9670;&nbsp;</a></span>is_obtrusive_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::is_obtrusive_lock </td>
          <td>(</td>
          <td class="paramtype">enum_mdl_type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Check if type of lock requested is "obtrusive" type of lock.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classMDL__lock.html#aa8424d2f478663117e7ac5e435840342">MDL_lock::get_unobtrusive_lock_increment()</a> description. </dd></dl>

</div>
</div>
<a id="aa6cbff270ec3afad0feba7e97e9747bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cbff270ec3afad0feba7e97e9747bb">&#9670;&nbsp;</a></span>needs_hton_notification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::needs_hton_notification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMDL__key.html#a391ec4bd98fec6852a48f7856546ed3b">MDL_key::enum_mdl_namespace</a>&#160;</td>
          <td class="paramname"><em>mdl_namespace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Indicates whether object belongs to namespace which requires storage engine to be notified before acquiring and after releasing exclusive lock. </p>

</div>
</div>
<a id="a580d9a0d9be93f90361cee67d0b4199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580d9a0d9be93f90361cee67d0b4199f">&#9670;&nbsp;</a></span>object_lock_fast_path_granted_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bitmap_t MDL_lock::object_lock_fast_path_granted_bitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__lock.html">MDL_lock</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get bitmap of "unobtrusive" locks granted using "fast path" algorithm for per-object locks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classMDL__lock.html#a44d77e8b91c3f09ac46adb6dccf7a460">MDL_lock::fast_path_granted_bitmap()</a> for explanation about why it is safe to use non-atomic read of <a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">MDL_lock::m_fast_path_state</a> here. </dd></dl>

</div>
</div>
<a id="a1ab1e1914e48faa93ba2e862cddfc274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab1e1914e48faa93ba2e862cddfc274">&#9670;&nbsp;</a></span>object_lock_needs_connection_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool MDL_lock::object_lock_needs_connection_check </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__lock.html">MDL_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Check if <a class="el" href="classMDL__lock.html">MDL_lock</a> object represents user-level lock or locking service lock, so threads waiting for it need to check if connection is lost and abort waiting when it is. </p>

</div>
</div>
<a id="a382145d0f9b0f94a05ef03edbe922054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382145d0f9b0f94a05ef03edbe922054">&#9670;&nbsp;</a></span>object_lock_needs_notification()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool MDL_lock::object_lock_needs_notification </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Check if we are requesting X lock on the object, so threads holding conflicting S/SH metadata locks on it need to be notified.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classMDL__lock.html#aa30406c0d7d46396e15c4ca66abc6fc7">MDL_lock::object_lock_notify_conflicting_locks</a>. </dd></dl>

</div>
</div>
<a id="aa30406c0d7d46396e15c4ca66abc6fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30406c0d7d46396e15c4ca66abc6fc7">&#9670;&nbsp;</a></span>object_lock_notify_conflicting_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::object_lock_notify_conflicting_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__lock.html">MDL_lock</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Notify threads holding S/SH metadata locks on an object, which conflict with a pending X lock.</p>
<dl class="section note"><dt>Note</dt><dd>Currently this method is guaranteed to notify shared lock owners which have MDL_context::m_needs_thr_lock_abort flag set (as for others conficting locks might have been acquired on "fast path" and thus might be absent from list of granted locks). This is OK as notification for other contexts is anyway no-op now.</dd>
<dd>
We don't notify threads holding other than S/SH types of conflicting locks on the object since notification should not be needed and anyway will be no-op for them (unless they also hold S/SH locks on the object).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><a class="el" href="classMDL__context.html">MDL_context</a> for current thread. </td></tr>
    <tr><td class="paramname">lock</td><td><a class="el" href="classMDL__lock.html">MDL_lock</a> object representing lock which is to be acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa2f6326006b7c7ba179075c82707d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f6326006b7c7ba179075c82707d59">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMDL__key.html">MDL_key</a> *&#160;</td>
          <td class="paramname"><em>mdl_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Finalize initialization or re-initialize <a class="el" href="classMDL__lock.html">MDL_lock</a> returned from LF_ALLOCATOR's cache to represent object identified by provided key.</p>
<dl class="section note"><dt>Note</dt><dd>All non-static <a class="el" href="classMDL__lock.html">MDL_lock</a> members: 1) either have to be reinitialized here (like IS_DESTROYED flag in <a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">MDL_lock::m_fast_path_state</a>). 2) or need to be initialized in constructor AND returned to their pristine state once they are removed from <a class="el" href="classMDL__map.html">MDL_map</a> container (like <a class="el" href="classMDL__lock.html#a188dd53561f6cf6148277512b706ea74">MDL_lock::m_granted</a> or <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a>). Otherwise it is possible that we will end up in situation when "new" (actually reused) <a class="el" href="classMDL__lock.html">MDL_lock</a> object inserted in LF_HASH will inherit some values from old object. </dd></dl>

</div>
</div>
<a id="a7100ea62bb9af3e959d8a81ba11d4bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7100ea62bb9af3e959d8a81ba11d4bcb">&#9670;&nbsp;</a></span>remove_ticket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::remove_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__context.html">MDL_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LF_PINS *&#160;</td>
          <td class="paramname"><em>pins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a> MDL_lock::*&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>ticket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Remove a ticket from waiting or pending queue and wakeup up waiters. </p>

</div>
</div>
<a id="a07003cc6619a99b6cc36f564c62e4e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07003cc6619a99b6cc36f564c62e4e94">&#9670;&nbsp;</a></span>reschedule_waiters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MDL_lock::reschedule_waiters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Determine waiting contexts which requests for the lock can be satisfied, grant lock to them and wake them up.</p>
<dl class="section note"><dt>Note</dt><dd>Together with MDL_lock::add_ticket() this method implements fair scheduling among requests with the same priority. It tries to grant lock from the head of waiters list, while add_ticket() adds new requests to the back of this list. </dd></dl>

</div>
</div>
<a id="a8d5ce95948e006dbe957792a4be80928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5ce95948e006dbe957792a4be80928">&#9670;&nbsp;</a></span>scoped_lock_fast_path_granted_bitmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bitmap_t MDL_lock::scoped_lock_fast_path_granted_bitmap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMDL__lock.html">MDL_lock</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get bitmap of "unobtrusive" locks granted using "fast path" algorithm for scoped locks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classMDL__lock.html#a44d77e8b91c3f09ac46adb6dccf7a460">MDL_lock::fast_path_granted_bitmap()</a> for explanation about why it is safe to use non-atomic read of <a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">MDL_lock::m_fast_path_state</a> here. </dd></dl>

</div>
</div>
<a id="ab2be5e68445003d7a516849f2bceb18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2be5e68445003d7a516849f2bceb18c">&#9670;&nbsp;</a></span>switch_incompatible_waiting_types_bitmap_if_needed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::switch_incompatible_waiting_types_bitmap_if_needed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Switch priority matrice for the <a class="el" href="classMDL__lock.html">MDL_lock</a> object if m_piglet_lock_count or/ and m_hog_lock_count counters have crossed max_write_lock_count threshold.</p>
<dl class="section return"><dt>Returns</dt><dd>true - if priority matrice has been changed, false - otherwise. </dd></dl>

</div>
</div>
<a id="a56e5025d3f3cff97923bc283c715566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e5025d3f3cff97923bc283c715566d">&#9670;&nbsp;</a></span>visit_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MDL_lock::visit_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDL__ticket.html">MDL_ticket</a> *&#160;</td>
          <td class="paramname"><em>waiting_ticket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMDL__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *&#160;</td>
          <td class="paramname"><em>gvisitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">A fragment of recursive traversal of the wait-for graph in search for deadlocks. Direct the deadlock visitor to all contexts that own the lock the current node in the wait-for graph is waiting for. As long as the initial node is remembered in the visitor, a deadlock is found when the same node is seen twice. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac0e55394e253bd9d0988c9a7ab243a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e55394e253bd9d0988c9a7ab243a39">&#9670;&nbsp;</a></span>HAS_OBTRUSIVE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const fast_path_state_t MDL_lock::HAS_OBTRUSIVE = 1ULL &lt;&lt; 61</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Flag in <a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">MDL_lock::m_fast_path_state</a> that indicates that there are "obtrusive" locks which are granted, waiting or for which we are about to check if they can be granted. Corresponds to "MDL_lock::m_obtrusive_locks_granted_waiting_count == 0" predicate. Set using atomic compare-and-swap AND under protection of <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> lock. Thanks to this can be read either by using atomic compare-and-swap OR using ordinary read under protection of <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> lock.</p>
<p class="">Invariant [INV1]: When this flag is set all changes to m_fast_path_state member has to be done under protection of m_rwlock lock. </p>

</div>
</div>
<a id="ace80291dc2f7786288cdf1cec54bcb55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace80291dc2f7786288cdf1cec54bcb55">&#9670;&nbsp;</a></span>HAS_SLOW_PATH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const fast_path_state_t MDL_lock::HAS_SLOW_PATH = 1ULL &lt;&lt; 60</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Flag in <a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">MDL_lock::m_fast_path_state</a> that indicates that there are "slow" path locks which are granted, waiting or for which we are about to check if they can be granted. Corresponds to <a class="el" href="classMDL__lock.html#a188dd53561f6cf6148277512b706ea74">MDL_lock::m_granted</a>/m_waiting lists being non-empty (except special case in <a class="el" href="classMDL__context.html#ab6d07a861aaf9db6fda46da196a8b0d0">MDL_context::try_acquire_lock()</a>). Set using atomic compare-and-swap AND under protection of m_rwlock lock. The latter is necessary because value of this flag needs to be synchronized with contents of <a class="el" href="classMDL__lock.html#a188dd53561f6cf6148277512b706ea74">MDL_lock::m_granted</a>/m_waiting lists. </p>

</div>
</div>
<a id="a1627af1fd21d2ae76c27b39901e574a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1627af1fd21d2ae76c27b39901e574a3">&#9670;&nbsp;</a></span>IS_DESTROYED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const fast_path_state_t MDL_lock::IS_DESTROYED = 1ULL &lt;&lt; 62</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Flag in <a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">MDL_lock::m_fast_path_state</a> that indicates that the <a class="el" href="classMDL__lock.html">MDL_lock</a> object was marked for destruction and will be destroyed once all threads referencing to it through hazard pointers have unpinned it. Set using atomic compare-and-swap AND under protection of <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> lock. Thanks to this can be read either by using atomic compare-and-swap OR using ordinary read under protection of <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> lock. </p>

</div>
</div>
<a id="aefb48179bc3f6ef64c213b253c379da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb48179bc3f6ef64c213b253c379da4">&#9670;&nbsp;</a></span>key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMDL__key.html">MDL_key</a> MDL_lock::key</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The key of the object (data) being protected. </p>

</div>
</div>
<a id="ae680877b7079a862d294ccbefed6372c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae680877b7079a862d294ccbefed6372c">&#9670;&nbsp;</a></span>m_fast_path_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile fast_path_state_t MDL_lock::m_fast_path_state</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Combination of IS_DESTROYED/HAS_OBTRUSIVE/HAS_SLOW_PATH flags and packed counters of specific types of "unobtrusive" locks which were granted using "fast path".</p>
<dl class="section see"><dt>See also</dt><dd>MDL_scoped_lock::m_unobtrusive_lock_increment and MDL_object_lock::m_unobtrusive_lock_increment for details about how counts of different types of locks are packed into this field.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Doesn't include "unobtrusive" locks granted using "slow path".</dd>
<dd>
We use combination of atomic operations and protection by <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> lock to work with this member:</dd></dl>
<p>Write and Read-Modify-Write operations are always carried out atomically. This is necessary to avoid lost updates on 32-bit platforms among other things. In some cases Reads can be done non-atomically because we don't really care about value which they will return (for example, if further down the line there will be an atomic compare-and-swap operation, which will validate this value and provide the correct value if the validation will fail). In other cases Reads can be done non-atomically since they happen under protection of <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> and there is some invariant which ensures that concurrent updates of the m_fast_path_state member can't happen while <a class="el" href="classMDL__lock.html#a1308b4506d8cb6d754b4f173e3aa4962">MDL_lock::m_rwlock</a> is held (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classMDL__lock.html#a1627af1fd21d2ae76c27b39901e574a3">IS_DESTROYED</a>, <a class="el" href="classMDL__lock.html#ac0e55394e253bd9d0988c9a7ab243a39">HAS_OBTRUSIVE</a>, <a class="el" href="classMDL__lock.html#ace80291dc2f7786288cdf1cec54bcb55">HAS_SLOW_PATH</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>IMPORTANT!!! In order to enforce the above rules and other invariants, <a class="el" href="classMDL__lock.html#ae680877b7079a862d294ccbefed6372c">MDL_lock::m_fast_path_state</a> should not be updated directly. Use <a class="el" href="classMDL__lock.html#a716b40d532b18db6c2527d1a46908c29">fast_path_state_cas()</a>/add()/reset() wrapper methods instead.</dd>
<dd>
Needs to be volatile in order to be compatible with our my_atomic_*() API. </dd></dl>

</div>
</div>
<a id="a188dd53561f6cf6148277512b706ea74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188dd53561f6cf6148277512b706ea74">&#9670;&nbsp;</a></span>m_granted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a> MDL_lock::m_granted</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class=""><a class="el" href="classList.html">List</a> of granted tickets for this lock. </p>

</div>
</div>
<a id="a6ed94b58baea6bf2e22b76566aa513b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed94b58baea6bf2e22b76566aa513b3">&#9670;&nbsp;</a></span>m_object_lock_strategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock::MDL_lock_strategy</a> MDL_lock::m_object_lock_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Strategy instance for per-object locks. Supports all locked modes except INTENTION EXCLUSIVE locks. </p>

</div>
</div>
<a id="a7ef26eb4cf46309c494135291a82e20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef26eb4cf46309c494135291a82e20c">&#9670;&nbsp;</a></span>m_obtrusive_locks_granted_waiting_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint MDL_lock::m_obtrusive_locks_granted_waiting_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Number of granted or waiting lock requests of "obtrusive" type. Also includes "obtrusive" lock requests for which we about to check if they can be granted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classMDL__lock.html#aa8424d2f478663117e7ac5e435840342">MDL_lock::get_unobtrusive_lock_increment()</a> description.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This number doesn't include "unobtrusive" locks which were acquired using "slow path". </dd></dl>

</div>
</div>
<a id="a1308b4506d8cb6d754b4f173e3aa4962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1308b4506d8cb6d754b4f173e3aa4962">&#9670;&nbsp;</a></span>m_rwlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysql_prlock_t MDL_lock::m_rwlock</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Read-write lock protecting this lock context.</p>
<dl class="section note"><dt>Note</dt><dd>The fact that we use read-write lock prefers readers here is important as deadlock detector won't work correctly otherwise.</dd></dl>
<p>For example, imagine that we have following waiters graph: </p><pre class="fragment">         ctxA -&gt; obj1 -&gt; ctxB -&gt; obj1 -|
          ^                            |
          |----------------------------|
</pre><p class="">and both ctxA and ctxB start deadlock detection process:</p>
<p class="">ctxA read-locks obj1 ctxB read-locks obj2 ctxA goes deeper ctxB goes deeper</p>
<p class="">Now ctxC comes in who wants to start waiting on obj1, also ctxD comes in who wants to start waiting on obj2.</p>
<p class="">ctxC tries to write-lock obj1 ctxD tries to write-lock obj2 ctxC is blocked ctxD is blocked</p>
<p class="">Now ctxA and ctxB resume their search:</p>
<p class="">ctxA tries to read-lock obj2 ctxB tries to read-lock obj1</p>
<p class="">If m_rwlock prefers writes (or fair) both ctxA and ctxB would be blocked because of pending write locks from ctxD and ctxC correspondingly. Thus we will get a deadlock in deadlock detector. If m_wrlock prefers readers (actually ignoring pending writers is enough) ctxA and ctxB will continue and no deadlock will occur. </p>

</div>
</div>
<a id="aed7a092b4b9aa426597f599feb6bb19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7a092b4b9aa426597f599feb6bb19b">&#9670;&nbsp;</a></span>m_scoped_lock_strategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock::MDL_lock_strategy</a> MDL_lock::m_scoped_lock_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Strategy instances to be used with scoped metadata locks (i.e. locks from GLOBAL, COMMIT, TABLESPACE and SCHEMA namespaces). The only locking modes which are supported at the moment are SHARED and INTENTION EXCLUSIVE and EXCLUSIVE. </p>

</div>
</div>
<a id="a67a214605da83d57ac8d69c1f1c4854d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a214605da83d57ac8d69c1f1c4854d">&#9670;&nbsp;</a></span>m_strategy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structMDL__lock_1_1MDL__lock__strategy.html">MDL_lock_strategy</a>* MDL_lock::m_strategy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Pointer to strategy object which defines how different types of lock requests should be handled for the namespace to which this lock belongs. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classMDL__lock.html#aed7a092b4b9aa426597f599feb6bb19b">MDL_lock::m_scoped_lock_strategy</a> and <a class="el" href="classMDL__lock.html">MDL_lock</a>:<a class="el" href="classMDL__lock.html#a6ed94b58baea6bf2e22b76566aa513b3">m_object_lock_strategy</a>. </dd></dl>

</div>
</div>
<a id="a4443cad6b484e2af5c816949ddb209dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4443cad6b484e2af5c816949ddb209dc">&#9670;&nbsp;</a></span>m_waiting</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMDL__lock_1_1Ticket__list.html">Ticket_list</a> MDL_lock::m_waiting</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Tickets for contexts waiting to acquire a lock. </p>

</div>
</div>
<a id="abaeb101565637f92f74d4a84bdc53fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaeb101565637f92f74d4a84bdc53fa5">&#9670;&nbsp;</a></span>MDL_OBJECT_HOG_LOCK_TYPES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bitmap_t MDL_lock::MDL_OBJECT_HOG_LOCK_TYPES</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">                          (MDL_BIT(MDL_SHARED_NO_WRITE) |</div><div class="line">                           MDL_BIT(MDL_SHARED_NO_READ_WRITE) |</div><div class="line">                           MDL_BIT(MDL_EXCLUSIVE))</div></div><!-- fragment --><p class=""><a class="el" href="classBitmap.html">Bitmap</a> with "hog" lock types for object locks.</p>
<p class="">Locks of these types can easily starve out lower priority locks. To prevent this we only grant them max_write_lock_count times in a row while other lock types are waiting. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>mdl.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
