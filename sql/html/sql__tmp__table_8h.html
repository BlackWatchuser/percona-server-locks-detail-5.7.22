<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: sql_tmp_table.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sql_tmp_table.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Temporary table handling functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;my_global.h&quot;</code><br />
<code>#include &quot;my_base.h&quot;</code><br />
<code>#include &quot;item.h&quot;</code><br />
</div>
<p><a href="sql__tmp__table_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMem__root__array.html">Mem_root_array&lt; Element_type, has_trivial_destructor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classList.html">List&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a44db04362e9ad7e3ec9b5902b13348fa"><td class="memItemLeft" align="right" valign="top"><a id="a44db04362e9ad7e3ec9b5902b13348fa"></a>
typedef struct st_columndef&#160;</td><td class="memItemRight" valign="bottom"><b>MI_COLUMNDEF</b></td></tr>
<tr class="separator:a44db04362e9ad7e3ec9b5902b13348fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af476bf8bb716c73285954bbe6454b86a"><td class="memItemLeft" align="right" valign="top"><a id="af476bf8bb716c73285954bbe6454b86a"></a>
typedef struct <a class="el" href="structst__key.html">st_key</a>&#160;</td><td class="memItemRight" valign="bottom"><b>KEY</b></td></tr>
<tr class="separator:af476bf8bb716c73285954bbe6454b86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382bc7c9c36db79f121d41b7f816d40e"><td class="memItemLeft" align="right" valign="top"><a id="a382bc7c9c36db79f121d41b7f816d40e"></a>
typedef struct <a class="el" href="structst__order.html">st_order</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ORDER</b></td></tr>
<tr class="separator:a382bc7c9c36db79f121d41b7f816d40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd2288775feb1eca47e21cf66b3717c"><td class="memItemLeft" align="right" valign="top"><a id="abdd2288775feb1eca47e21cf66b3717c"></a>
typedef <a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt; <a class="el" href="classItem.html">Item</a> *, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Func_ptr_array</b></td></tr>
<tr class="separator:abdd2288775feb1eca47e21cf66b3717c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8bc0019eedd28e723495cf722bcdb8b"><td class="memItemLeft" align="right" valign="top"><a id="ae8bc0019eedd28e723495cf722bcdb8b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>enum_internal_tmp_disk_storage_engine</b> { <b>TMP_TABLE_MYISAM</b>, 
<b>TMP_TABLE_INNODB</b>
 }</td></tr>
<tr class="separator:ae8bc0019eedd28e723495cf722bcdb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adfb8ccc236ce303095c9c108c4fbf37e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#adfb8ccc236ce303095c9c108c4fbf37e">create_tmp_table</a> (THD *thd, Temp_table_param *param, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="structst__order.html">ORDER</a> *group, bool distinct, bool save_sum_fields, ulonglong select_options, ha_rows rows_limit, const char *table_alias)</td></tr>
<tr class="separator:adfb8ccc236ce303095c9c108c4fbf37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96b92fdb5742c887723b0a5cd9bb5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#ab96b92fdb5742c887723b0a5cd9bb5ed">create_virtual_tmp_table</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCreate__field.html">Create_field</a> &gt; &amp;field_list)</td></tr>
<tr class="separator:ab96b92fdb5742c887723b0a5cd9bb5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7b9fb8583e2ee5080c10b7c12828f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#acd7b9fb8583e2ee5080c10b7c12828f0">create_ondisk_from_heap</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, MI_COLUMNDEF *start_recinfo, MI_COLUMNDEF **recinfo, int error, bool ignore_last_dup, bool *is_duplicate)</td></tr>
<tr class="separator:acd7b9fb8583e2ee5080c10b7c12828f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b1e0dacb732b7a68c3e0400b98b574"><td class="memItemLeft" align="right" valign="top"><a id="a91b1e0dacb732b7a68c3e0400b98b574"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_tmp_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *entry)</td></tr>
<tr class="separator:a91b1e0dacb732b7a68c3e0400b98b574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f9e476ed3103722f6797275569bcef"><td class="memItemLeft" align="right" valign="top"><a id="a05f9e476ed3103722f6797275569bcef"></a>
<a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>create_duplicate_weedout_tmp_table</b> (THD *thd, uint uniq_tuple_length_arg, <a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *sjtbl)</td></tr>
<tr class="separator:a05f9e476ed3103722f6797275569bcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fe1c1797077c4e247f7a3d7131bbe2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#aa9fe1c1797077c4e247f7a3d7131bbe2">instantiate_tmp_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structst__key.html">KEY</a> *keyinfo, MI_COLUMNDEF *start_recinfo, MI_COLUMNDEF **recinfo, ulonglong options, my_bool big_tables, <a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *trace)</td></tr>
<tr class="memdesc:aa9fe1c1797077c4e247f7a3d7131bbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates temporary table.  <a href="#aa9fe1c1797077c4e247f7a3d7131bbe2">More...</a><br /></td></tr>
<tr class="separator:aa9fe1c1797077c4e247f7a3d7131bbe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ce71a30b8c34f5da3109d64f9c2abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#ae0ce71a30b8c34f5da3109d64f9c2abe">create_tmp_field</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classItem.html">Item</a> *item, Item::Type type, <a class="el" href="classMem__root__array.html">Func_ptr_array</a> *copy_func, <a class="el" href="classField.html">Field</a> **from_field, <a class="el" href="classField.html">Field</a> **default_field, bool group, bool modify_item, bool table_cant_handle_bit_fields, bool make_copy_field)</td></tr>
<tr class="separator:ae0ce71a30b8c34f5da3109d64f9c2abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27931d629bb2af3886439f98986a6ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#ac27931d629bb2af3886439f98986a6ae">create_tmp_field_from_field</a> (THD *thd, <a class="el" href="classField.html">Field</a> *org_field, const char *name, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classItem__field.html">Item_field</a> *item)</td></tr>
<tr class="separator:ac27931d629bb2af3886439f98986a6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad518b6a0a5b0a77d3961e81aa3686094"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#ad518b6a0a5b0a77d3961e81aa3686094">get_max_key_and_part_length</a> (uint *max_key_length, uint *max_key_part_length)</td></tr>
<tr class="separator:ad518b6a0a5b0a77d3961e81aa3686094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b030319fe92a064c1c0a930289225b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sql__tmp__table_8h.html#ad6b030319fe92a064c1c0a930289225b">init_cache_tmp_engine_properties</a> ()</td></tr>
<tr class="separator:ad6b030319fe92a064c1c0a930289225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">Temporary table handling functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acd7b9fb8583e2ee5080c10b7c12828f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7b9fb8583e2ee5080c10b7c12828f0">&#9670;&nbsp;</a></span>create_ondisk_from_heap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool create_ondisk_from_heap </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MI_COLUMNDEF *&#160;</td>
          <td class="paramname"><em>start_recinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MI_COLUMNDEF **&#160;</td>
          <td class="paramname"><em>recinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_last_dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_duplicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">If a MEMORY table gets full, create a disk-based table and copy all rows to this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD reference </td></tr>
    <tr><td class="paramname">table</td><td>Table reference </td></tr>
    <tr><td class="paramname">start_recinfo</td><td>Engine's column descriptions </td></tr>
    <tr><td class="paramname">recinfo[in,out]</td><td>End of engine's column descriptions </td></tr>
    <tr><td class="paramname">error</td><td>Reason why inserting into MEMORY table failed. </td></tr>
    <tr><td class="paramname">ignore_last_dup</td><td>If true, ignore duplicate key error for last inserted key (see detailed description below). </td></tr>
    <tr><td class="paramname">is_duplicate[out]</td><td>if non-NULL and ignore_last_dup is TRUE, return TRUE if last key was a duplicate, and FALSE otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p>Function can be called with any error code, but only HA_ERR_RECORD_FILE_FULL will be handled, all other errors cause a fatal error to be thrown. The function creates a disk-based temporary table, copies all records from the MEMORY table into this new table, deletes the old table and switches to use the new table within the table handle. The function uses table-&gt;record[1] as a temporary buffer while copying.</p>
<p class="">The function assumes that table-&gt;record[0] contains the row that caused the error when inserting into the MEMORY table (the "last row"). After all existing rows have been copied to the new table, the last row is attempted to be inserted as well. If ignore_last_dup is true, this row can be a duplicate of an existing row without throwing an error. If is_duplicate is non-NULL, an indication of whether the last row was a duplicate is returned.</p>
<dl class="section note"><dt>Note</dt><dd>that any index/scan access initialized on the MEMORY table is not replicated to the on-disk table - it's the caller's responsibility. </dd></dl>

</div>
</div>
<a id="ae0ce71a30b8c34f5da3109d64f9c2abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ce71a30b8c34f5da3109d64f9c2abe">&#9670;&nbsp;</a></span>create_tmp_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* create_tmp_field </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item::Type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMem__root__array.html">Func_ptr_array</a> *&#160;</td>
          <td class="paramname"><em>copy_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>from_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>default_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>modify_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>table_cant_handle_bit_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_copy_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create field for temporary table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">table</td><td>Temporary table </td></tr>
    <tr><td class="paramname">item</td><td><a class="el" href="classItem.html">Item</a> to create a field for </td></tr>
    <tr><td class="paramname">type</td><td>Type of item (normally item-&gt;type) </td></tr>
    <tr><td class="paramname">copy_func</td><td>If set and item is a function, store copy of item in this array </td></tr>
    <tr><td class="paramname">from_field</td><td>if field will be created using other field as example, pointer example field will be written here </td></tr>
    <tr><td class="paramname">default_field</td><td>If field has a default value field, store it here </td></tr>
    <tr><td class="paramname">group</td><td>1 if we are going to do a relative group by on result </td></tr>
    <tr><td class="paramname">modify_item</td><td>1 if item-&gt;result_field should point to new item. This is relevent for how fill_record() is going to work: If modify_item is 1 then fill_record() will update the record in the original table. If modify_item is 0 then fill_record() will update the temporary table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>On error.</td></tr>
    <tr><td class="paramname">new_created</td><td>field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac27931d629bb2af3886439f98986a6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27931d629bb2af3886439f98986a6ae">&#9670;&nbsp;</a></span>create_tmp_field_from_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classField.html">Field</a>* create_tmp_field_from_field </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>org_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create field for temporary table from given field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">org_field</td><td>field from which new field will be created </td></tr>
    <tr><td class="paramname">name</td><td>New field name </td></tr>
    <tr><td class="paramname">table</td><td>Temporary table </td></tr>
    <tr><td class="paramname">item</td><td>!=NULL if item-&gt;result_field should point to new field. This is relevant for how fill_record() is going to work: If item != NULL then fill_record() will update the record in the original table. If item == NULL then fill_record() will update the temporary table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error </td></tr>
    <tr><td class="paramname">new_created</td><td>field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfb8ccc236ce303095c9c108c4fbf37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb8ccc236ce303095c9c108c4fbf37e">&#9670;&nbsp;</a></span>create_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* create_tmp_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp_table_param *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>distinct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_sum_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>select_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">When true, enforces unique constraint (by adding a hidden hash_field and creating a key over this field) when: (1) unique key is too long or (2) number of key parts in distinct key is too big.</p>

</div>
</div>
<a id="ab96b92fdb5742c887723b0a5cd9bb5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96b92fdb5742c887723b0a5cd9bb5ed">&#9670;&nbsp;</a></span>create_virtual_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* create_virtual_tmp_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCreate__field.html">Create_field</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">General routine to change field-&gt;ptr of a NULL-terminated array of <a class="el" href="classField.html">Field</a> objects. Useful when needed to call val_int, val_str or similar and the field data is not in table-&gt;record[0] but in some other structure. set_key_field_ptr changes all fields of an index using a key_info object. All methods presume that there is at least one field to change.</p>
<p class="">Create a reduced <a class="el" href="structTABLE.html">TABLE</a> object with properly set up <a class="el" href="classField.html">Field</a> list from a list of field definitions.</p>
<p class="">The created table doesn't have a table handler associated with it, has no keys, no group/distinct, no copy_funcs array. The sole purpose of this <a class="el" href="structTABLE.html">TABLE</a> object is to use the power of <a class="el" href="classField.html">Field</a> class to read/write data to/from table-&gt;record[0]. Then one can store the record in any container (RB tree, hash, etc). The table is created in THD mem_root, so are the table's fields. Consequently, if you don't BLOB fields, you don't need to free it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>connection handle </td></tr>
    <tr><td class="paramname">field_list</td><td>list of column definitions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if out of memory, <a class="el" href="structTABLE.html">TABLE</a> object in case of success </dd></dl>

</div>
</div>
<a id="ad518b6a0a5b0a77d3961e81aa3686094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad518b6a0a5b0a77d3961e81aa3686094">&#9670;&nbsp;</a></span>get_max_key_and_part_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_max_key_and_part_length </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>max_key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>max_key_part_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Get the minimum of max_key_length and max_key_part_length between HEAP engine and internal_tmp_disk_storage_engine.</p>
<p class="">Get the minimum of max_key_length and max_key_part_length. The minimum is between HEAP engine and internal_tmp_disk_storage_engine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">max_key_length</td><td>Minimum of max_key_length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_key_part_length</td><td>Minimum of max_key_part_length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6b030319fe92a064c1c0a930289225b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b030319fe92a064c1c0a930289225b">&#9670;&nbsp;</a></span>init_cache_tmp_engine_properties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_cache_tmp_engine_properties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Initilize the storage engine properties for the alternative temporary table storage engines. </p>

</div>
</div>
<a id="aa9fe1c1797077c4e247f7a3d7131bbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fe1c1797077c4e247f7a3d7131bbe2">&#9670;&nbsp;</a></span>instantiate_tmp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instantiate_tmp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__key.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>keyinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MI_COLUMNDEF *&#160;</td>
          <td class="paramname"><em>start_recinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MI_COLUMNDEF **&#160;</td>
          <td class="paramname"><em>recinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">my_bool&#160;</td>
          <td class="paramname"><em>big_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *&#160;</td>
          <td class="paramname"><em>trace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates temporary table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table object that describes the table to be instantiated </td></tr>
    <tr><td class="paramname">keyinfo</td><td>Description of the index (there is always one index) </td></tr>
    <tr><td class="paramname">start_recinfo</td><td>Column descriptions </td></tr>
    <tr><td class="paramname">recinfo</td><td>INOUT End of column descriptions </td></tr>
    <tr><td class="paramname">options</td><td>Option bits </td></tr>
    <tr><td class="paramname">trace</td><td>Optimizer trace to write info to</td></tr>
  </table>
  </dd>
</dl>
<p>Creates tmp table and opens it.</p>
<dl class="section return"><dt>Returns</dt><dd>FALSE - OK TRUE - Error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
