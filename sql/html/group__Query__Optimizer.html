<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Query Optimizer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Query Optimizer</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__RefOptimizerModule"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RefOptimizerModule.html">Ref Optimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlan__change__watchdog.html">Plan_change_watchdog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOND__CMP.html">COND_CMP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8976c581bb885405f6b19a1753e6e6dd"><td class="memItemLeft" align="right" valign="top"><a id="ga8976c581bb885405f6b19a1753e6e6dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ICP_COND_USES_INDEX_ONLY</b>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ga8976c581bb885405f6b19a1753e6e6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa95a062cdd785687a638e01d7ad85d11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa95a062cdd785687a638e01d7ad85d11">substitute_gc</a> (THD *thd, SELECT_LEX *select_lex, <a class="el" href="classItem.html">Item</a> *where_cond, <a class="el" href="structst__order.html">ORDER</a> *group_list, <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:gaa95a062cdd785687a638e01d7ad85d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96dc524565684a4e258c98f5b7fd1541"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga96dc524565684a4e258c98f5b7fd1541">test_if_order_by_key</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="structTABLE.html">TABLE</a> *table, uint idx, uint *used_key_parts)</td></tr>
<tr class="separator:ga96dc524565684a4e258c98f5b7fd1541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0c3fdb07be77d705feaf3f8f51164f"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafd0c3fdb07be77d705feaf3f8f51164f">find_shortest_key</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *usable_keys)</td></tr>
<tr class="separator:gafd0c3fdb07be77d705feaf3f8f51164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8d854a364ab749539a9363619acf99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4a8d854a364ab749539a9363619acf99">is_subkey</a> (<a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_part, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *ref_key_part, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *ref_key_part_end)</td></tr>
<tr class="separator:ga4a8d854a364ab749539a9363619acf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe6fc3febf146805e30ce17267d4dd98"><td class="memItemLeft" align="right" valign="top">Item_equal *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafe6fc3febf146805e30ce17267d4dd98">find_item_equal</a> (COND_EQUAL *cond_equal, <a class="el" href="classItem__field.html">Item_field</a> *item_field, bool *inherited_fl)</td></tr>
<tr class="separator:gafe6fc3febf146805e30ce17267d4dd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d1175177356bf1c9b05e9104d28c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga67d1175177356bf1c9b05e9104d28c5b">get_best_field</a> (<a class="el" href="classItem__field.html">Item_field</a> *item_field, COND_EQUAL *cond_equal)</td></tr>
<tr class="separator:ga67d1175177356bf1c9b05e9104d28c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f49ad71fa53a75fa8ebae08cf775cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga51f49ad71fa53a75fa8ebae08cf775cc">build_equal_items</a> (THD *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> **retcond, COND_EQUAL *inherited, bool do_inherit, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *join_list, COND_EQUAL **cond_equal_ref)</td></tr>
<tr class="separator:ga51f49ad71fa53a75fa8ebae08cf775cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253393c0747cf378b9cefa109662bd17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga253393c0747cf378b9cefa109662bd17">substitute_for_best_equal_field</a> (<a class="el" href="classItem.html">Item</a> *cond, COND_EQUAL *cond_equal, void *table_join_idx)</td></tr>
<tr class="separator:ga253393c0747cf378b9cefa109662bd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18726347ecf92d8985617dda1d60ba3"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab18726347ecf92d8985617dda1d60ba3">build_bitmap_for_nested_joins</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *join_list, uint first_unused)</td></tr>
<tr class="separator:gab18726347ecf92d8985617dda1d60ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652bf7109dfbe0fdd7deb75c05c0a7a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga652bf7109dfbe0fdd7deb75c05c0a7a3">uses_index_fields_only</a> (<a class="el" href="classItem.html">Item</a> *item, <a class="el" href="structTABLE.html">TABLE</a> *tbl, uint keyno, bool other_tbls_ok)</td></tr>
<tr class="separator:ga652bf7109dfbe0fdd7deb75c05c0a7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa992e841315769954816105b951d3e17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa992e841315769954816105b951d3e17">is_indexed_agg_distinct</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__field.html">Item_field</a> &gt; *out_args)</td></tr>
<tr class="separator:gaa992e841315769954816105b951d3e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5efe6ddb0de3a2b43f36c3330354e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMem__root__array.html">Key_use_array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7a5efe6ddb0de3a2b43f36c3330354e7">create_keyuse_for_table</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, uint keyparts, <a class="el" href="classItem__field.html">Item_field</a> **fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; outer_exprs)</td></tr>
<tr class="separator:ga7a5efe6ddb0de3a2b43f36c3330354e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf2fb3248e5d013e6a74b29dd9e7429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaedf2fb3248e5d013e6a74b29dd9e7429">make_cond_for_table</a> (<a class="el" href="classItem.html">Item</a> *cond, table_map tables, table_map used_table, bool exclude_expensive_cond)</td></tr>
<tr class="separator:gaedf2fb3248e5d013e6a74b29dd9e7429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768e4d9b55252e39161f392f34cb5abc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga768e4d9b55252e39161f392f34cb5abc">optimize_cond</a> (THD *thd, <a class="el" href="classItem.html">Item</a> **cond, COND_EQUAL **cond_equal, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *join_list, Item::cond_result *cond_value)</td></tr>
<tr class="separator:ga768e4d9b55252e39161f392f34cb5abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c7623dfe6301253414f9155999c43b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf8c7623dfe6301253414f9155999c43b">remove_eq_conds</a> (THD *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> **retcond, Item::cond_result *cond_value)</td></tr>
<tr class="separator:gaf8c7623dfe6301253414f9155999c43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fc6278226cdb15849ecfd9c3af07b00"><td class="memItemLeft" align="right" valign="top"><a id="ga0fc6278226cdb15849ecfd9c3af07b00"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>const_expression_in_where</b> (<a class="el" href="classItem.html">Item</a> *conds, <a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classItem.html">Item</a> **comp_item)</td></tr>
<tr class="separator:ga0fc6278226cdb15849ecfd9c3af07b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77d58d476f44178e469e2cbe16e9e01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae77d58d476f44178e469e2cbe16e9e01">handle_query</a> (THD *thd, LEX *lex, Query_result *result, ulonglong added_options, ulonglong removed_options)</td></tr>
<tr class="separator:gae77d58d476f44178e469e2cbe16e9e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410e1c85b186cd5520a7d21930ead6e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga410e1c85b186cd5520a7d21930ead6e5">types_allow_materialization</a> (<a class="el" href="classItem.html">Item</a> *outer, <a class="el" href="classItem.html">Item</a> *inner)</td></tr>
<tr class="memdesc:ga410e1c85b186cd5520a7d21930ead6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two items are compatible wrt. materialization.  <a href="#ga410e1c85b186cd5520a7d21930ead6e5">More...</a><br /></td></tr>
<tr class="separator:ga410e1c85b186cd5520a7d21930ead6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be82b593cb5e0548b3b3aa4b28bc3bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4be82b593cb5e0548b3b3aa4b28bc3bf">calc_used_field_length</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, bool keep_current_rowid, uint *p_used_fields, uint *p_used_fieldlength, uint *p_used_blobs, bool *p_used_null_fields, bool *p_used_uneven_bit_fields)</td></tr>
<tr class="separator:ga4be82b593cb5e0548b3b3aa4b28bc3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f8a3668a5d5771061e14f5d87c30794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5f8a3668a5d5771061e14f5d87c30794">calc_length_and_keyparts</a> (<a class="el" href="classKey__use.html">Key_use</a> *keyuse, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, const uint key, table_map used_tables, <a class="el" href="classKey__use.html">Key_use</a> **chosen_keyuses, uint *length_out, uint *keyparts_out, table_map *dep_map, bool *maybe_null)</td></tr>
<tr class="separator:ga5f8a3668a5d5771061e14f5d87c30794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b518fb7975676afc7395b412e803368"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3b518fb7975676afc7395b412e803368">create_ref_for_key</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *j, <a class="el" href="classKey__use.html">Key_use</a> *org_keyuse, table_map used_tables)</td></tr>
<tr class="separator:ga3b518fb7975676afc7395b412e803368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c0a5624f789fb0bf0c5fc5ec057de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad3c0a5624f789fb0bf0c5fc5ec057de9">and_conditions</a> (<a class="el" href="classItem.html">Item</a> **e1, <a class="el" href="classItem.html">Item</a> *e2)</td></tr>
<tr class="separator:gad3c0a5624f789fb0bf0c5fc5ec057de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27b74179b9a9207753aa3f93a9df4225"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga27b74179b9a9207753aa3f93a9df4225">make_join_readinfo</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, uint no_jbuf_after)</td></tr>
<tr class="separator:ga27b74179b9a9207753aa3f93a9df4225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1351457ee30a4e67786117e50413541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf1351457ee30a4e67786117e50413541">error_if_full_join</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr class="separator:gaf1351457ee30a4e67786117e50413541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc980a72c17c8442fab87af085697d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gadbc980a72c17c8442fab87af085697d4">simple_remove_const</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="classItem.html">Item</a> *where)</td></tr>
<tr class="separator:gadbc980a72c17c8442fab87af085697d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8478e8df214dcc332c84d24ebe3f0785"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga8478e8df214dcc332c84d24ebe3f0785">const_expression_in_where</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> *comp_item, <a class="el" href="classField.html">Field</a> *comp_field, <a class="el" href="classItem.html">Item</a> **const_item)</td></tr>
<tr class="separator:ga8478e8df214dcc332c84d24ebe3f0785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37c57743c17000bba9bbbbd87b01d32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga37c57743c17000bba9bbbbd87b01d32f">count_field_types</a> (SELECT_LEX *select_lex, Temp_table_param *param, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, bool reset_with_sum_func, bool save_sum_fields)</td></tr>
<tr class="separator:ga37c57743c17000bba9bbbbd87b01d32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d5a2e1822e2131fcfbe6501a8a97525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4d5a2e1822e2131fcfbe6501a8a97525">test_if_subpart</a> (<a class="el" href="structst__order.html">ORDER</a> *a, <a class="el" href="structst__order.html">ORDER</a> *b)</td></tr>
<tr class="separator:ga4d5a2e1822e2131fcfbe6501a8a97525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa978828bfe7be091fb76e1c5da80d644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa978828bfe7be091fb76e1c5da80d644">calc_group_buffer</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *group)</td></tr>
<tr class="separator:gaa978828bfe7be091fb76e1c5da80d644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59080a3acd829efcf18fc56d51df215c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga59080a3acd829efcf18fc56d51df215c">free_underlaid_joins</a> (THD *thd, SELECT_LEX *select)</td></tr>
<tr class="separator:ga59080a3acd829efcf18fc56d51df215c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eec84bb823e8a5ea10710e1e4f066d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3eec84bb823e8a5ea10710e1e4f066d1">test_if_cheaper_ordering</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> usable_keys, int ref_key, ha_rows select_limit, int *new_key, int *new_key_direction, ha_rows *new_select_limit, uint *new_used_key_parts, uint *saved_best_key_parts)</td></tr>
<tr class="separator:ga3eec84bb823e8a5ea10710e1e4f066d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d8a0c25d038fddac9b92696f6845e3"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga92d8a0c25d038fddac9b92696f6845e3">get_index_for_order</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab, ha_rows limit, bool *need_sort, bool *reverse)</td></tr>
<tr class="separator:ga92d8a0c25d038fddac9b92696f6845e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6609ac0420a8a415d5a57cc6659f460d"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6609ac0420a8a415d5a57cc6659f460d">actual_key_parts</a> (const <a class="el" href="structst__key.html">KEY</a> *key_info)</td></tr>
<tr class="separator:ga6609ac0420a8a415d5a57cc6659f460d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174d79a5aef2a8abd1caec143b42837e"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga174d79a5aef2a8abd1caec143b42837e">actual_key_flags</a> (<a class="el" href="structst__key.html">KEY</a> *key_info)</td></tr>
<tr class="separator:ga174d79a5aef2a8abd1caec143b42837e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf336d1a31135fd93a5564c5e090b50a"><td class="memItemLeft" align="right" valign="top">join_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaaf336d1a31135fd93a5564c5e090b50a">calc_join_type</a> (int <a class="el" href="sql__select_8h.html#a931d06905210c0f917b25d180eeb643f">quick_type</a>)</td></tr>
<tr class="separator:gaaf336d1a31135fd93a5564c5e090b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52eaf58ec1438c6d387b55e4035e504"><td class="memItemLeft" align="right" valign="top"><a id="gaa52eaf58ec1438c6d387b55e4035e504"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::calc_record_fields</b> ()</td></tr>
<tr class="separator:gaa52eaf58ec1438c6d387b55e4035e504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64e01213d7f5f755d1ff689d5e46fd8"><td class="memItemLeft" align="right" valign="top"><a id="gaa64e01213d7f5f755d1ff689d5e46fd8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::alloc_fields</b> (uint external_fields)</td></tr>
<tr class="separator:gaa64e01213d7f5f755d1ff689d5e46fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631f7419905d1b8199d14f5fd11926d4"><td class="memItemLeft" align="right" valign="top"><a id="ga631f7419905d1b8199d14f5fd11926d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::create_flag_fields</b> ()</td></tr>
<tr class="separator:ga631f7419905d1b8199d14f5fd11926d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ab87ee19d6e92561f80933563bb147"><td class="memItemLeft" align="right" valign="top"><a id="gab3ab87ee19d6e92561f80933563bb147"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::create_remaining_fields</b> (bool all_read_fields)</td></tr>
<tr class="separator:gab3ab87ee19d6e92561f80933563bb147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e30ba1b4cfa2fd22aaf1c5bac90b7e"><td class="memItemLeft" align="right" valign="top"><a id="ga81e30ba1b4cfa2fd22aaf1c5bac90b7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::set_constants</b> ()</td></tr>
<tr class="separator:ga81e30ba1b4cfa2fd22aaf1c5bac90b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5932344e1185abf63788970856f45766"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5932344e1185abf63788970856f45766">JOIN_CACHE::alloc_buffer</a> ()</td></tr>
<tr class="separator:ga5932344e1185abf63788970856f45766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae89dde6a1925032ade263c27a87529f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaae89dde6a1925032ade263c27a87529f">JOIN_CACHE::filter_virtual_gcol_base_cols</a> ()</td></tr>
<tr class="separator:gaae89dde6a1925032ade263c27a87529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfdf6220265d56c5dc44081d89abc73e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gabfdf6220265d56c5dc44081d89abc73e">JOIN_CACHE::restore_virtual_gcol_base_cols</a> ()</td></tr>
<tr class="separator:gabfdf6220265d56c5dc44081d89abc73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dbb0f8b69dc30985e0d9a0ff94121f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab3dbb0f8b69dc30985e0d9a0ff94121f">JOIN_CACHE_BNL::init</a> ()</td></tr>
<tr class="separator:gab3dbb0f8b69dc30985e0d9a0ff94121f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga327376f63198bf31a770fb89242d49aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga327376f63198bf31a770fb89242d49aa">JOIN_CACHE_BKA::init</a> ()</td></tr>
<tr class="separator:ga327376f63198bf31a770fb89242d49aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700b94ef76d1152d7ea4816ec7b46299"><td class="memItemLeft" align="right" valign="top"><a id="ga700b94ef76d1152d7ea4816ec7b46299"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::check_emb_key_usage</b> ()</td></tr>
<tr class="separator:ga700b94ef76d1152d7ea4816ec7b46299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8661280e3da40b2c581ec758c50e1979"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga8661280e3da40b2c581ec758c50e1979">JOIN_CACHE_BKA::aux_buffer_incr</a> ()</td></tr>
<tr class="separator:ga8661280e3da40b2c581ec758c50e1979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7343f0416360c14c6134867b347c83"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaef7343f0416360c14c6134867b347c83">JOIN_CACHE_BKA::aux_buffer_min_size</a> () const</td></tr>
<tr class="separator:gaef7343f0416360c14c6134867b347c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552f68c5d61c00714ca823ff05cd7847"><td class="memItemLeft" align="right" valign="top"><a id="ga552f68c5d61c00714ca823ff05cd7847"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::skip_index_tuple</b> (range_seq_t rseq, char *range_info)</td></tr>
<tr class="separator:ga552f68c5d61c00714ca823ff05cd7847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264fccad2a1ea9271e785cb8e38432ca"><td class="memItemLeft" align="right" valign="top"><a id="ga264fccad2a1ea9271e785cb8e38432ca"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::write_record_data</b> (uchar *link, bool *is_full)</td></tr>
<tr class="separator:ga264fccad2a1ea9271e785cb8e38432ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54e309ac7f0fd377d7a422ea54f59f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8">JOIN_CACHE::reset_cache</a> (bool for_writing)</td></tr>
<tr class="memdesc:gad54e309ac7f0fd377d7a422ea54f59f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the join buffer for reading/writing: default implementation.  <a href="#gad54e309ac7f0fd377d7a422ea54f59f8">More...</a><br /></td></tr>
<tr class="separator:gad54e309ac7f0fd377d7a422ea54f59f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d55336d67514ad78878149c80528e33"><td class="memItemLeft" align="right" valign="top"><a id="ga6d55336d67514ad78878149c80528e33"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::put_record_in_cache</b> ()</td></tr>
<tr class="separator:ga6d55336d67514ad78878149c80528e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7ee01f20498b51114e1afb40806685"><td class="memItemLeft" align="right" valign="top"><a id="ga6f7ee01f20498b51114e1afb40806685"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_record</b> ()</td></tr>
<tr class="separator:ga6f7ee01f20498b51114e1afb40806685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb8c25ca124e9aeaddf1442c6167e87"><td class="memItemLeft" align="right" valign="top"><a id="gaccb8c25ca124e9aeaddf1442c6167e87"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_record_by_pos</b> (uchar *rec_ptr)</td></tr>
<tr class="separator:gaccb8c25ca124e9aeaddf1442c6167e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7955ae39f556d0141a6eb11e03a4b1e"><td class="memItemLeft" align="right" valign="top"><a id="gab7955ae39f556d0141a6eb11e03a4b1e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_match_flag_by_pos</b> (uchar *rec_ptr)</td></tr>
<tr class="separator:gab7955ae39f556d0141a6eb11e03a4b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c8bd509fba4099611e8a7b01c115d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga20c8bd509fba4099611e8a7b01c115d8">JOIN_CACHE::read_some_record_fields</a> ()</td></tr>
<tr class="separator:ga20c8bd509fba4099611e8a7b01c115d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa19cecc5eccee0ff1285c62769daf39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafa19cecc5eccee0ff1285c62769daf39">JOIN_CACHE::read_some_flag_fields</a> ()</td></tr>
<tr class="separator:gafa19cecc5eccee0ff1285c62769daf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6967798983487fe2f83ed405b5b2d1f4"><td class="memItemLeft" align="right" valign="top"><a id="ga6967798983487fe2f83ed405b5b2d1f4"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::read_record_field</b> (<a class="el" href="structst__cache__field.html">CACHE_FIELD</a> *copy, bool last_record)</td></tr>
<tr class="separator:ga6967798983487fe2f83ed405b5b2d1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b36ae5a54a63d5fb2fe863a036aa08"><td class="memItemLeft" align="right" valign="top"><a id="ga66b36ae5a54a63d5fb2fe863a036aa08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::read_referenced_field</b> (<a class="el" href="structst__cache__field.html">CACHE_FIELD</a> *copy, uchar *rec_ptr, uint *len)</td></tr>
<tr class="separator:ga66b36ae5a54a63d5fb2fe863a036aa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb269cde39ce62236de5b481296de21"><td class="memItemLeft" align="right" valign="top"><a id="gafbb269cde39ce62236de5b481296de21"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::skip_record_if_match</b> ()</td></tr>
<tr class="separator:gafbb269cde39ce62236de5b481296de21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3feda29f01cc03251f55a0b00511d7a"><td class="memItemLeft" align="right" valign="top"><a id="gae3feda29f01cc03251f55a0b00511d7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::restore_last_record</b> ()</td></tr>
<tr class="separator:gae3feda29f01cc03251f55a0b00511d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66879154541707521bc3d07829084c2e"><td class="memItemLeft" align="right" valign="top"><a id="ga66879154541707521bc3d07829084c2e"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::join_records</b> (bool skip_last)</td></tr>
<tr class="separator:ga66879154541707521bc3d07829084c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05271c0a916273b7f8b934fbaab623bd"><td class="memItemLeft" align="right" valign="top"><a id="ga05271c0a916273b7f8b934fbaab623bd"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BNL::join_matching_records</b> (bool skip_last)</td></tr>
<tr class="separator:ga05271c0a916273b7f8b934fbaab623bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680b1522161dd38adbc48197df3ea115"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga680b1522161dd38adbc48197df3ea115">JOIN_CACHE::calc_check_only_first_match</a> (const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *t) const</td></tr>
<tr class="separator:ga680b1522161dd38adbc48197df3ea115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ada3645fd27523d6cfa7fc073ba4ad"><td class="memItemLeft" align="right" valign="top"><a id="ga90ada3645fd27523d6cfa7fc073ba4ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::set_match_flag_if_none</b> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *first_inner, uchar *rec_ptr)</td></tr>
<tr class="separator:ga90ada3645fd27523d6cfa7fc073ba4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774240988bd63b547442150fd459e6d2"><td class="memItemLeft" align="right" valign="top"><a id="ga774240988bd63b547442150fd459e6d2"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::generate_full_extensions</b> (uchar *rec_ptr)</td></tr>
<tr class="separator:ga774240988bd63b547442150fd459e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab160a0ff435a7a1da8bb065ba03f1573"><td class="memItemLeft" align="right" valign="top"><a id="gab160a0ff435a7a1da8bb065ba03f1573"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::check_match</b> (uchar *rec_ptr)</td></tr>
<tr class="separator:gab160a0ff435a7a1da8bb065ba03f1573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08fb808afb3705abba0f0bfaf5798d05"><td class="memItemLeft" align="right" valign="top"><a id="ga08fb808afb3705abba0f0bfaf5798d05"></a>
virtual enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::join_null_complements</b> (bool skip_last)</td></tr>
<tr class="separator:ga08fb808afb3705abba0f0bfaf5798d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae42b1e09c108b419fb9eefac1312ef"><td class="memItemLeft" align="right" valign="top"><a id="ga5ae42b1e09c108b419fb9eefac1312ef"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::join_matching_records</b> (bool skip_last)</td></tr>
<tr class="separator:ga5ae42b1e09c108b419fb9eefac1312ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ba1e9701fe4bab26bd70d79e91cd30"><td class="memItemLeft" align="right" valign="top"><a id="ga89ba1e9701fe4bab26bd70d79e91cd30"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::init_join_matching_records</b> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq_funcs, uint ranges)</td></tr>
<tr class="separator:ga89ba1e9701fe4bab26bd70d79e91cd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812222f5f9eb4a9026c8ce89069ef8d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga812222f5f9eb4a9026c8ce89069ef8d7">JOIN_CACHE::read_all_flag_fields_by_pos</a> (uchar *rec_ptr)</td></tr>
<tr class="separator:ga812222f5f9eb4a9026c8ce89069ef8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d40beb0d805bd84dd9c1547450de48"><td class="memItemLeft" align="right" valign="top"><a id="ga31d40beb0d805bd84dd9c1547450de48"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::get_next_key</b> (uchar **key)</td></tr>
<tr class="separator:ga31d40beb0d805bd84dd9c1547450de48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ca6a85294c32bac8c69bea0c4e5fe1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa7ca6a85294c32bac8c69bea0c4e5fe1">JOIN_CACHE_BKA_UNIQUE::init</a> ()</td></tr>
<tr class="separator:gaa7ca6a85294c32bac8c69bea0c4e5fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb1afc6322b69d01ea68b677b715ddc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7">JOIN_CACHE_BKA_UNIQUE::reset_cache</a> (bool for_writing)</td></tr>
<tr class="memdesc:gafb1afc6322b69d01ea68b677b715ddc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the join buffer for reading/writing: default implementation.  <a href="#gafb1afc6322b69d01ea68b677b715ddc7">More...</a><br /></td></tr>
<tr class="separator:gafb1afc6322b69d01ea68b677b715ddc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45dfdf58092c485f346a66afd4e124ad"><td class="memItemLeft" align="right" valign="top"><a id="ga45dfdf58092c485f346a66afd4e124ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::put_record_in_cache</b> ()</td></tr>
<tr class="separator:ga45dfdf58092c485f346a66afd4e124ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15ffed7193009e4a49e1c66622217a0f"><td class="memItemLeft" align="right" valign="top"><a id="ga15ffed7193009e4a49e1c66622217a0f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::get_record</b> ()</td></tr>
<tr class="separator:ga15ffed7193009e4a49e1c66622217a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc649f4ce5bb5be551fab670511e8b8"><td class="memItemLeft" align="right" valign="top"><a id="ga2fc649f4ce5bb5be551fab670511e8b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::skip_record_if_match</b> ()</td></tr>
<tr class="separator:ga2fc649f4ce5bb5be551fab670511e8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4c98e95bbd633f5bd7df7c8bbbe4ed1"><td class="memItemLeft" align="right" valign="top"><a id="gac4c98e95bbd633f5bd7df7c8bbbe4ed1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::key_search</b> (uchar *key, uint key_len, uchar **key_ref_ptr)</td></tr>
<tr class="separator:gac4c98e95bbd633f5bd7df7c8bbbe4ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afa1e2231c8090ecae73554fca37c41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6afa1e2231c8090ecae73554fca37c41">JOIN_CACHE_BKA_UNIQUE::skip_index_tuple</a> (range_seq_t rseq, char *range_info)</td></tr>
<tr class="separator:ga6afa1e2231c8090ecae73554fca37c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c2a23d19df8e983c61ed2c25214c86d"><td class="memItemLeft" align="right" valign="top"><a id="ga1c2a23d19df8e983c61ed2c25214c86d"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::join_matching_records</b> (bool skip_last)</td></tr>
<tr class="separator:ga1c2a23d19df8e983c61ed2c25214c86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a69af2bfc11dc07fce9cdb261cdcd3"><td class="memItemLeft" align="right" valign="top"><a id="ga93a69af2bfc11dc07fce9cdb261cdcd3"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::check_all_match_flags_for_key</b> (uchar *key_chain_ptr)</td></tr>
<tr class="separator:ga93a69af2bfc11dc07fce9cdb261cdcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cacb8dfb5e5fad32b82fb0b8c572507"><td class="memItemLeft" align="right" valign="top"><a id="ga2cacb8dfb5e5fad32b82fb0b8c572507"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::get_next_key</b> (uchar **key)</td></tr>
<tr class="separator:ga2cacb8dfb5e5fad32b82fb0b8c572507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd031be055cee296d6629313a333b56f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafd031be055cee296d6629313a333b56f">JOIN_CACHE_BKA_UNIQUE::check_match</a> (uchar *rec_ptr)</td></tr>
<tr class="separator:gafd031be055cee296d6629313a333b56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f722315c64ce97cff639d705107c660"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7f722315c64ce97cff639d705107c660">JOIN::optimize</a> ()</td></tr>
<tr class="separator:ga7f722315c64ce97cff639d705107c660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a07bf891c57c62aad090896e118cd1"><td class="memItemLeft" align="right" valign="top"><a id="ga31a07bf891c57c62aad090896e118cd1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga31a07bf891c57c62aad090896e118cd1">QEP_TAB::init</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *jt)</td></tr>
<tr class="memdesc:ga31a07bf891c57c62aad090896e118cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the object from a <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a>. <br /></td></tr>
<tr class="separator:ga31a07bf891c57c62aad090896e118cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0363af5ecbde624f02fbc38a695a3b"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaee0363af5ecbde624f02fbc38a695a3b">QEP_TAB::get_sj_strategy</a> () const</td></tr>
<tr class="separator:gaee0363af5ecbde624f02fbc38a695a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada415e1d087c014e9b8a22b39980bfea"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gada415e1d087c014e9b8a22b39980bfea">QEP_TAB::effective_index</a> () const</td></tr>
<tr class="separator:gada415e1d087c014e9b8a22b39980bfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc77304fe7c751bce4fa59ef52d91fb0"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gabc77304fe7c751bce4fa59ef52d91fb0">JOIN_TAB::get_sj_strategy</a> () const</td></tr>
<tr class="separator:gabc77304fe7c751bce4fa59ef52d91fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c1cf0874f4bda777557d012148e059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae9c1cf0874f4bda777557d012148e059">JOIN::get_best_combination</a> ()</td></tr>
<tr class="separator:gae9c1cf0874f4bda777557d012148e059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa6edcfa6c4d934dd42d505d9de2fef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaeaa6edcfa6c4d934dd42d505d9de2fef">JOIN::update_equalities_for_sjm</a> ()</td></tr>
<tr class="separator:gaeaa6edcfa6c4d934dd42d505d9de2fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db5dc577ffd7662b800cc6307183c2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga0db5dc577ffd7662b800cc6307183c2b">JOIN::mark_const_table</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *table, <a class="el" href="classKey__use.html">Key_use</a> *key)</td></tr>
<tr class="separator:ga0db5dc577ffd7662b800cc6307183c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea10268473cae92c3bdbcf0ea4f97cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaaea10268473cae92c3bdbcf0ea4f97cc">JOIN::attach_join_conditions</a> (plan_idx last_tab)</td></tr>
<tr class="separator:gaaea10268473cae92c3bdbcf0ea4f97cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4b6860e6fc2137f71776590079de8a"><td class="memItemLeft" align="right" valign="top"><a id="ga5a4b6860e6fc2137f71776590079de8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN::remove_subq_pushed_predicates</b> ()</td></tr>
<tr class="separator:ga5a4b6860e6fc2137f71776590079de8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bf64a03ec666f565627fbb48ba4677"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga92bf64a03ec666f565627fbb48ba4677">JOIN::generate_derived_keys</a> ()</td></tr>
<tr class="memdesc:ga92bf64a03ec666f565627fbb48ba4677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add keys to derived tables'/views' result tables in a list.  <a href="#ga92bf64a03ec666f565627fbb48ba4677">More...</a><br /></td></tr>
<tr class="separator:ga92bf64a03ec666f565627fbb48ba4677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54392f4f40ec2c57b8263f22fa3d4296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga54392f4f40ec2c57b8263f22fa3d4296">JOIN::drop_unused_derived_keys</a> ()</td></tr>
<tr class="memdesc:ga54392f4f40ec2c57b8263f22fa3d4296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop unused keys for each materialized derived table/view.  <a href="#ga54392f4f40ec2c57b8263f22fa3d4296">More...</a><br /></td></tr>
<tr class="separator:ga54392f4f40ec2c57b8263f22fa3d4296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4408ac7e9a04a594110d2009cfcd54c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4408ac7e9a04a594110d2009cfcd54c9">JOIN::cache_const_exprs</a> ()</td></tr>
<tr class="separator:ga4408ac7e9a04a594110d2009cfcd54c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c20a9b8d13f14275a4ee01f44f8cfa2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7c20a9b8d13f14275a4ee01f44f8cfa2">JOIN::fts_index_access</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab)</td></tr>
<tr class="separator:ga7c20a9b8d13f14275a4ee01f44f8cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab466b49a22220854ef8f11a2c4a2ae8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab466b49a22220854ef8f11a2c4a2ae8a">JOIN::decide_subquery_strategy</a> ()</td></tr>
<tr class="separator:gab466b49a22220854ef8f11a2c4a2ae8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac99b2256ee62ddd1a435289c2acb8e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaac99b2256ee62ddd1a435289c2acb8e2">JOIN::optimize_rollup</a> ()</td></tr>
<tr class="separator:gaac99b2256ee62ddd1a435289c2acb8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4f64b9b280796d9abe945b2eda94ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaef4f64b9b280796d9abe945b2eda94ac">JOIN::refine_best_rowcount</a> ()</td></tr>
<tr class="separator:gaef4f64b9b280796d9abe945b2eda94ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e09d71987062663db1836d651ec4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad4e09d71987062663db1836d651ec4d4">JOIN::reset</a> ()</td></tr>
<tr class="separator:gad4e09d71987062663db1836d651ec4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed62f6e6cc8f6d042c806a154ea7137"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gabed62f6e6cc8f6d042c806a154ea7137">JOIN::prepare_result</a> ()</td></tr>
<tr class="separator:gabed62f6e6cc8f6d042c806a154ea7137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d76654da99be4012095c016ea5d4d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf2d76654da99be4012095c016ea5d4d2">JOIN::destroy</a> ()</td></tr>
<tr class="separator:gaf2d76654da99be4012095c016ea5d4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53646d8b3951fac09c190096af77f586"><td class="memItemLeft" align="right" valign="top"><a id="ga53646d8b3951fac09c190096af77f586"></a>
enum store_key_result&#160;</td><td class="memItemRight" valign="bottom"><b>store_key_hash_item::copy_inner</b> ()</td></tr>
<tr class="separator:ga53646d8b3951fac09c190096af77f586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ededf725731bb0cfd5a3871181f496e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5ededf725731bb0cfd5a3871181f496e">QEP_TAB::push_index_cond</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab, uint keyno, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *trace_obj)</td></tr>
<tr class="separator:ga5ededf725731bb0cfd5a3871181f496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c5164eb9405b18a16ca8a3ee339047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga44c5164eb9405b18a16ca8a3ee339047">QEP_TAB::init_join_cache</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:ga44c5164eb9405b18a16ca8a3ee339047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae913870950feb0d927de9b53963f0a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae913870950feb0d927de9b53963f0a6a">JOIN_TAB::cleanup</a> ()</td></tr>
<tr class="separator:gae913870950feb0d927de9b53963f0a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5426869c15b3f454986507ede09bab"><td class="memItemLeft" align="right" valign="top"><a id="gaaf5426869c15b3f454986507ede09bab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>QEP_TAB::cleanup</b> ()</td></tr>
<tr class="separator:gaaf5426869c15b3f454986507ede09bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907897f1c70ca51d710d46da42645cfc"><td class="memItemLeft" align="right" valign="top"><a id="ga907897f1c70ca51d710d46da42645cfc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>QEP_shared_owner::qs_cleanup</b> ()</td></tr>
<tr class="separator:ga907897f1c70ca51d710d46da42645cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c4cb376fec34447cf5df2b3d4c238a"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac2c4cb376fec34447cf5df2b3d4c238a">QEP_TAB::sjm_query_block_id</a> () const</td></tr>
<tr class="separator:gac2c4cb376fec34447cf5df2b3d4c238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d28b10dac195744ef3daaab70d84208"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga2d28b10dac195744ef3daaab70d84208">QEP_shared_owner::and_with_condition</a> (<a class="el" href="classItem.html">Item</a> *tmp_cond)</td></tr>
<tr class="separator:ga2d28b10dac195744ef3daaab70d84208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa62d47da29f3853e87b1069ee5c1ff21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa62d47da29f3853e87b1069ee5c1ff21">JOIN::join_free</a> ()</td></tr>
<tr class="separator:gaa62d47da29f3853e87b1069ee5c1ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633799af14ae0a6e3abbac98b428c46f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga633799af14ae0a6e3abbac98b428c46f">JOIN::cleanup</a> ()</td></tr>
<tr class="separator:ga633799af14ae0a6e3abbac98b428c46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga140c4ff912190f1c0f6279897103a720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga140c4ff912190f1c0f6279897103a720">JOIN::alloc_func_list</a> ()</td></tr>
<tr class="separator:ga140c4ff912190f1c0f6279897103a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae713fbd3faf5b5aefad41408fd11685a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae713fbd3faf5b5aefad41408fd11685a">JOIN::make_sum_func_list</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;<a class="el" href="classJOIN.html#a6664196553f3202cfc4e740358d6bc0d">all_fields</a>, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;send_fields, bool before_group_by, bool recompute=FALSE)</td></tr>
<tr class="separator:gae713fbd3faf5b5aefad41408fd11685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga076b7e6736c0bf0a9e9bf7542e4746c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga076b7e6736c0bf0a9e9bf7542e4746c8">JOIN::rollup_process_const_fields</a> ()</td></tr>
<tr class="separator:ga076b7e6736c0bf0a9e9bf7542e4746c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e92b14b52e210ce225ad4c0312f9bca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7e92b14b52e210ce225ad4c0312f9bca">JOIN::rollup_make_fields</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;<a class="el" href="classJOIN.html#a6664196553f3202cfc4e740358d6bc0d">all_fields</a>, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="classItem__sum.html">Item_sum</a> ***func)</td></tr>
<tr class="separator:ga7e92b14b52e210ce225ad4c0312f9bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacff1c1a49375e2f52301214084924bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gacff1c1a49375e2f52301214084924bf3">JOIN::clear</a> ()</td></tr>
<tr class="separator:gacff1c1a49375e2f52301214084924bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c14b8b1b7b5f002b219140b565000db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga8c14b8b1b7b5f002b219140b565000db">JOIN::add_sorting_to_table</a> (uint idx, <a class="el" href="classJOIN_1_1ORDER__with__src.html">ORDER_with_src</a> *<a class="el" href="classJOIN.html#ac06839682aae707b0e1d4fafd53abaf5">order</a>)</td></tr>
<tr class="memdesc:ga8c14b8b1b7b5f002b219140b565000db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classFilesort.html">Filesort</a> object to the given table to sort if with filesort.  <a href="#ga8c14b8b1b7b5f002b219140b565000db">More...</a><br /></td></tr>
<tr class="separator:ga8c14b8b1b7b5f002b219140b565000db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3c214b7ed8212280406d828d8354632d"><td class="memItemLeft" align="right" valign="top"><a id="ga3c214b7ed8212280406d828d8354632d"></a>
static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3c214b7ed8212280406d828d8354632d">store_key_const_item::static_name</a> [] = &quot;const&quot;</td></tr>
<tr class="memdesc:ga3c214b7ed8212280406d828d8354632d"><td class="mdescLeft">&#160;</td><td class="mdescRight">used out of this class <br /></td></tr>
<tr class="separator:ga3c214b7ed8212280406d828d8354632d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga174d79a5aef2a8abd1caec143b42837e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga174d79a5aef2a8abd1caec143b42837e">&#9670;&nbsp;</a></span>actual_key_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint actual_key_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__key.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Returns key flags depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_info</td><td>pointer to KEY structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>key flags. </dd></dl>

</div>
</div>
<a id="ga6609ac0420a8a415d5a57cc6659f460d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6609ac0420a8a415d5a57cc6659f460d">&#9670;&nbsp;</a></span>actual_key_parts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint actual_key_parts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structst__key.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Returns number of key parts depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_info</td><td>pointer to KEY structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of key parts. </dd></dl>

</div>
</div>
<a id="ga8c14b8b1b7b5f002b219140b565000db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c14b8b1b7b5f002b219140b565000db">&#9670;&nbsp;</a></span>add_sorting_to_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::add_sorting_to_table </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN_1_1ORDER__with__src.html">ORDER_with_src</a> *&#160;</td>
          <td class="paramname"><em>sort_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add <a class="el" href="classFilesort.html">Filesort</a> object to the given table to sort if with filesort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>the <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> object to attach created <a class="el" href="classFilesort.html">Filesort</a> object to </td></tr>
    <tr><td class="paramname">sort_order</td><td><a class="el" href="classList.html">List</a> of expressions to sort the table by</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function moves tab-&gt;select, if any, to filesort-&gt;select</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on OOM </dd></dl>

</div>
</div>
<a id="ga5932344e1185abf63788970856f45766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5932344e1185abf63788970856f45766">&#9670;&nbsp;</a></span>alloc_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_CACHE::alloc_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Allocate memory for a join buffer.</p>
<p class="">The function allocates a lump of memory for the join buffer. The size of the allocated memory is 'buff_size' bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>false if success, otherwise true. </dd></dl>

</div>
</div>
<a id="ga140c4ff912190f1c0f6279897103a720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga140c4ff912190f1c0f6279897103a720">&#9670;&nbsp;</a></span>alloc_func_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::alloc_func_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Make an array of pointers to sum_functions to speed up sum_func calculation.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3c0a5624f789fb0bf0c5fc5ec057de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3c0a5624f789fb0bf0c5fc5ec057de9">&#9670;&nbsp;</a></span>and_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool and_conditions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Extend e1 by AND'ing e2 to the condition e1 points to. The resulting condition is fixed. Requirement: the input Items must already have been fixed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e1</td><td>Pointer to condition that will be extended with e2 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">e2</td><td>Condition that will extend e1</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error, in which case e1 remains unchanged </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d28b10dac195744ef3daaab70d84208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d28b10dac195744ef3daaab70d84208">&#9670;&nbsp;</a></span>and_with_condition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QEP_shared_owner::and_with_condition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>add_cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Extend join_tab-&gt;cond by AND'ing add_cond to it</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">add_cond</td><td>The condition to AND with the existing cond for this <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaea10268473cae92c3bdbcf0ea4f97cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea10268473cae92c3bdbcf0ea4f97cc">&#9670;&nbsp;</a></span>attach_join_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::attach_join_conditions </td>
          <td>(</td>
          <td class="paramtype">plan_idx&#160;</td>
          <td class="paramname"><em>last_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Attach outer join conditions to generated table conditions in an optimal way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">last_tab</td><td>- Last table that has been added to the current plan. Pre-condition: If this is the last inner table of an outer join operation, a join condition is attached to the first inner table of that outer join operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error.</dd></dl>
<p>Outer join conditions are attached to individual tables, but we can analyze those conditions only when reaching the last inner table of an outer join operation. Notice also that a table can be last within several outer join nests, hence the outer for() loop of this function.</p>
<p class="">Example: SELECT * FROM t1 LEFT <a class="el" href="classJOIN.html">JOIN</a> (t2 LEFT <a class="el" href="classJOIN.html">JOIN</a> t3 ON t2.a=t3.a) ON t1.a=t2.a</p>
<p class="">Table t3 is last both in the join nest (t2 - t3) and in (t1 - (t2 - t3)) Thus, join conditions for both join nests will be evaluated when reaching this table.</p>
<p class="">For each outer join operation processed, the join condition is split optimally over the inner tables of the outer join. The split-out conditions are later referred to as table conditions (but note that several table conditions stemming from different join operations may be combined into a composite table condition).</p>
<p class="">Example: Consider the above query once more. The predicate t1.a=t2.a can be evaluated when rows from t1 and t2 are ready, ie at table t2. The predicate t2.a=t3.a can be evaluated at table t3.</p>
<p class="">Each non-constant split-out table condition is guarded by a match variable that enables it only when a matching row is found for all the embedded outer join operations.</p>
<p class="">Each split-out table condition is guarded by a variable that turns the condition off just before a null-complemented row for the outer join operation is formed. Thus, the join condition will not be checked for the null-complemented row. </p>

</div>
</div>
<a id="ga8661280e3da40b2c581ec758c50e1979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8661280e3da40b2c581ec758c50e1979">&#9670;&nbsp;</a></span>aux_buffer_incr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint JOIN_CACHE_BKA::aux_buffer_incr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Calculate the increment of the MRR buffer for a record write</p>
<p class="">Calculate the increment of the MRR buffer for a record write <br />
 This implementation of the virtual function aux_buffer_incr determines for how much the size of the MRR buffer should be increased when another record is added to the cache.</p>
<dl class="section return"><dt>Returns</dt><dd>the increment of the size of the MRR buffer for the next record </dd></dl>

<p>Reimplemented from <a class="el" href="classJOIN__CACHE.html">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="gaef7343f0416360c14c6134867b347c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef7343f0416360c14c6134867b347c83">&#9670;&nbsp;</a></span>aux_buffer_min_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint JOIN_CACHE_BKA::aux_buffer_min_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Calculate the minimume size for the MRR buffer</p>
<p class="">Calculate the minimume size for the MRR buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The minumum size that must be allocated for the MRR buffer </dd></dl>

<p>Reimplemented from <a class="el" href="classJOIN__CACHE.html#a22f1df0156fa6d176df6d6e6d4b84916">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="gab18726347ecf92d8985617dda1d60ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab18726347ecf92d8985617dda1d60ba3">&#9670;&nbsp;</a></span>build_bitmap_for_nested_joins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint build_bitmap_for_nested_joins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>first_unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Assign each nested join structure a bit in nested_join_map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_list</td><td><a class="el" href="classList.html">List</a> of tables </td></tr>
    <tr><td class="paramname">first_unused</td><td>Number of first unused bit in nested_join_map before the call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is called after simplify_joins(), when there are no redundant nested joins. We cannot have more nested joins in a query block than there are tables, so as long as the number of bits in nested_join_map is not less than the maximum number of tables in a query block, nested_join_map can never overflow.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>First unused bit in nested_join_map after the call. </dd></dl>

</div>
</div>
<a id="ga51f49ad71fa53a75fa8ebae08cf775cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f49ad71fa53a75fa8ebae08cf775cc">&#9670;&nbsp;</a></span>build_equal_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool build_equal_items </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>retcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND_EQUAL *&#160;</td>
          <td class="paramname"><em>inherited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND_EQUAL **&#160;</td>
          <td class="paramname"><em>cond_equal_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Build multiple equalities for a WHERE condition and all join conditions that inherit these multiple equalities.</p>
<p class="">The function first applies the build_equal_items_for_cond function to build all multiple equalities for condition cond utilizing equalities referred through the parameter inherited. The extended set of equalities is returned in the structure referred by the cond_equal_ref parameter. After this the function calls itself recursively for all join conditions whose direct references can be found in join_list and who inherit directly the multiple equalities just having built.</p>
<dl class="section note"><dt>Note</dt><dd>The join condition used in an outer join operation inherits all equalities from the join condition of the embedding join, if there is any, or otherwise - from the where condition. This fact is not obvious, but presumably can be proved. Consider the following query: <div class="fragment"><div class="line">SELECT * FROM (t1,t2) LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t2.a=t4.a</div><div class="line">  WHERE t1.a=t2.a;</div></div><!-- fragment --> If the join condition in the query inherits =(t1.a,t2.a), then we can build the multiple equality =(t1.a,t2.a,t3.a,t4.a) that infers the equality t3.a=t4.a. Although the join condition t1.a=t3.a AND t2.a=t4.a AND t3.a=t4.a is not equivalent to the one in the query the latter can be replaced by the former: the new query will return the same result set as the original one.</dd></dl>
<p>Interesting that multiple equality =(t1.a,t2.a,t3.a,t4.a) allows us to use t1.a=t3.a AND t3.a=t4.a under the join condition: </p><div class="fragment"><div class="line">SELECT * FROM (t1,t2) LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t3.a=t4.a</div><div class="line">  WHERE t1.a=t2.a</div></div><!-- fragment --><p> This query equivalent to: </p><div class="fragment"><div class="line">SELECT * FROM (t1 LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t3.a=t4.a),t2</div><div class="line">  WHERE t1.a=t2.a</div></div><!-- fragment --><p> Similarly the original query can be rewritten to the query: </p><div class="fragment"><div class="line">SELECT * FROM (t1,t2) LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) ON t2.a=t4.a AND t3.a=t4.a</div><div class="line">  WHERE t1.a=t2.a</div></div><!-- fragment --><p> that is equivalent to: </p><div class="fragment"><div class="line">SELECT * FROM (t2 LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4)ON t2.a=t4.a AND t3.a=t4.a), t1</div><div class="line">  WHERE t1.a=t2.a</div></div><!-- fragment --><p> Thus, applying equalities from the where condition we basically can get more freedom in performing join operations. Although we don't use this property now, it probably makes sense to use it in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>condition to build the multiple equalities for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retcond</td><td>Returned condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inherited</td><td>path to all inherited multiple equality items </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">do_inherit</td><td>whether or not to inherit equalities from other parts of the condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list of join tables that the condition refers to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_equal_ref</td><td>pointer to the structure to place built equalities in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="ga4408ac7e9a04a594110d2009cfcd54c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4408ac7e9a04a594110d2009cfcd54c9">&#9670;&nbsp;</a></span>cache_const_exprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::cache_const_exprs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Cache constant expressions in WHERE, HAVING, ON conditions.</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is run after conditions have been pushed down to individual tables, so transformation is applied to JOIN_TAB::condition and not to the WHERE condition. </dd></dl>

</div>
</div>
<a id="ga680b1522161dd38adbc48197df3ea115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680b1522161dd38adbc48197df3ea115">&#9670;&nbsp;</a></span>calc_check_only_first_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_CACHE::calc_check_only_first_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether we should check only the first match for this table </dd></dl>

</div>
</div>
<a id="gaa978828bfe7be091fb76e1c5da80d644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa978828bfe7be091fb76e1c5da80d644">&#9670;&nbsp;</a></span>calc_group_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_group_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">calc how big buffer we need for comparing group entries. </p>

</div>
</div>
<a id="gaaf336d1a31135fd93a5564c5e090b50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf336d1a31135fd93a5564c5e090b50a">&#9670;&nbsp;</a></span>calc_join_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">join_type calc_join_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quick_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>join type according to quick select type used </dd></dl>

</div>
</div>
<a id="ga5f8a3668a5d5771061e14f5d87c30794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f8a3668a5d5771061e14f5d87c30794">&#9670;&nbsp;</a></span>calc_length_and_keyparts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_length_and_keyparts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>used_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> **&#160;</td>
          <td class="paramname"><em>chosen_keyuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>length_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keyparts_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map *&#160;</td>
          <td class="paramname"><em>dep_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>maybe_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Calculate properties of ref key: key length, number of used key parts, dependency map, possibility of null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">keyuse</td><td>Array of keys to consider </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>join_tab to calculate ref parameters for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>number of the key to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">used_tables</td><td>tables read prior to this table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">chosen_keyuses</td><td>when given, this function will fill array with chosen keyuses </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length_out</td><td>calculated length of the ref </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keyparts_out</td><td>calculated number of used keyparts </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dep_map</td><td>when given, calculated dependency map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maybe_null</td><td>when given, calculated maybe_null property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4be82b593cb5e0548b3b3aa4b28bc3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4be82b593cb5e0548b3b3aa4b28bc3bf">&#9670;&nbsp;</a></span>calc_used_field_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_used_field_length </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_current_rowid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>p_used_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>p_used_fieldlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>p_used_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>p_used_null_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>p_used_uneven_bit_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find how much space the prevous read not const tables takes in cache. </p>

</div>
</div>
<a id="gafd031be055cee296d6629313a333b56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd031be055cee296d6629313a333b56f">&#9670;&nbsp;</a></span>check_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_CACHE_BKA_UNIQUE::check_match </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>rec_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Check matching to a partial join record from the join buffer, an implementation specialized for <a class="el" href="classJOIN__CACHE__BKA__UNIQUE.html">JOIN_CACHE_BKA_UNIQUE</a>. Only <a class="el" href="classJOIN__CACHE__BKA__UNIQUE.html">JOIN_CACHE_BKA_UNIQUE</a> needs that, because it's the only cache using distinct keys. <a class="el" href="classJOIN__CACHE__BKA.html">JOIN_CACHE_BKA</a>, on the other hand, does one key lookup per cached record, so can take a per-record individualized decision for the pushed index condition as soon as it has the index tuple. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Query__Optimizer.html#ga6afa1e2231c8090ecae73554fca37c41">JOIN_CACHE_BKA_UNIQUE::skip_index_tuple</a> </dd>
<dd>
JOIN_CACHE::check_match </dd></dl>

<p>Reimplemented from <a class="el" href="classJOIN__CACHE.html">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="ga633799af14ae0a6e3abbac98b428c46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga633799af14ae0a6e3abbac98b428c46f">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Cleanup this <a class="el" href="classJOIN.html">JOIN</a>. Not a full cleanup. reusable?</p>
<p class="">Free resources of given join.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fill</td><td>true if we should free all resources, call with full==1 should be last, before it this function can be called with full==0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>With subquery this function definitely will be called several times, but even for simple query it can be called several times. </dd></dl>

</div>
</div>
<a id="gae913870950feb0d927de9b53963f0a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae913870950feb0d927de9b53963f0a6a">&#9670;&nbsp;</a></span>cleanup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_TAB::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Clean up associated table after query execution, including resources</p>
<p class="">Cleanup table of join operation. </p>

</div>
</div>
<a id="gacff1c1a49375e2f52301214084924bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacff1c1a49375e2f52301214084924bf3">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">clear results if there are not rows found for group (end_send_group/end_write_group) </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>on error <br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8478e8df214dcc332c84d24ebe3f0785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8478e8df214dcc332c84d24ebe3f0785">&#9670;&nbsp;</a></span>const_expression_in_where()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool const_expression_in_where </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>comp_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>comp_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>const_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Test if a field or an item is equal to a constant value in WHERE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>WHERE clause expression </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_item</td><td><a class="el" href="classItem.html">Item</a> to find in WHERE expression (if comp_field != NULL) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_field</td><td><a class="el" href="classField.html">Field</a> to find in WHERE expression (if comp_item != NULL) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">const_item</td><td>intermediate arg, set to <a class="el" href="classItem.html">Item</a> pointer to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the field is a constant value in WHERE</dd></dl>
<dl class="section note"><dt>Note</dt><dd>comp_item and comp_field parameters are mutually exclusive. </dd></dl>

</div>
</div>
<a id="ga37c57743c17000bba9bbbbd87b01d32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37c57743c17000bba9bbbbd87b01d32f">&#9670;&nbsp;</a></span>count_field_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void count_field_types </td>
          <td>(</td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp_table_param *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset_with_sum_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_sum_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Update TMP_TABLE_PARAM with count of the different type of fields.</p>
<p class="">This function counts the number of fields, functions and sum functions (items with type SUM_FUNC_ITEM) for use by <a class="el" href="sql__tmp__table_8h.html#adfb8ccc236ce303095c9c108c4fbf37e">create_tmp_table()</a> and stores it in the Temp_table_param object. It also resets and calculates the quick_group property, which may have to be reverted if this function is called after deciding to use ROLLUP (see <a class="el" href="group__Query__Optimizer.html#gaac99b2256ee62ddd1a435289c2acb8e2">JOIN::optimize_rollup()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select_lex</td><td>SELECT_LEX of query </td></tr>
    <tr><td class="paramname">param</td><td>Description of temp table </td></tr>
    <tr><td class="paramname">fields</td><td><a class="el" href="classList.html">List</a> of fields to count </td></tr>
    <tr><td class="paramname">reset_with_sum_func</td><td>Whether to reset with_sum_func of func items </td></tr>
    <tr><td class="paramname">save_sum_fields</td><td>Count in the way <a class="el" href="sql__tmp__table_8h.html#adfb8ccc236ce303095c9c108c4fbf37e">create_tmp_table()</a> expects when given the same parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a5efe6ddb0de3a2b43f36c3330354e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a5efe6ddb0de3a2b43f36c3330354e7">&#9670;&nbsp;</a></span>create_keyuse_for_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMem__root__array.html">Key_use_array</a>* create_keyuse_for_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> **&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt;&#160;</td>
          <td class="paramname"><em>outer_exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create a keyuse array for a table with a primary key. To be used when creating a materialized temporary table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer, for memory allocation </td></tr>
    <tr><td class="paramname">table</td><td>Table object representing table </td></tr>
    <tr><td class="paramname">keyparts</td><td>Number of key parts in the primary key </td></tr>
    <tr><td class="paramname">outer_exprs</td><td><a class="el" href="classList.html">List</a> of items used for key lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to created keyuse array, or NULL if error </dd></dl>

</div>
</div>
<a id="ga3b518fb7975676afc7395b412e803368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b518fb7975676afc7395b412e803368">&#9670;&nbsp;</a></span>create_ref_for_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool create_ref_for_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>org_keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>used_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Setup a ref access for looking up rows via an index (a key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join object being handled </td></tr>
    <tr><td class="paramname">j</td><td>The join_tab which will have the ref access populated </td></tr>
    <tr><td class="paramname">first_keyuse</td><td>First key part of (possibly multi-part) key </td></tr>
    <tr><td class="paramname">used_tables</td><td><a class="el" href="classBitmap.html">Bitmap</a> of available tables</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<p>Given a <a class="el" href="classKey__use.html">Key_use</a> structure that specifies the fields that can be used for index access, this function creates and set up the structure used for index look up via one of the access methods {JT_FT, JT_CONST, JT_REF_OR_NULL, JT_REF, JT_EQ_REF} for the plan operator 'j'. Generally the function sets up the structure j-&gt;ref (of type TABLE_REF), and the access method j-&gt;type.</p>
<dl class="section note"><dt>Note</dt><dd>We cannot setup fields used for ref access before we have sorted the items within multiple equalities according to the final order of the tables involved in the join operation. Currently, this occurs in </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Query__Optimizer.html#ga253393c0747cf378b9cefa109662bd17">substitute_for_best_equal_field()</a>. The exception is ref access for const tables, which are fixed before the greedy search planner is invoked. <br />
 </dd></dl>
<p class="">The outer reference is to a const table, so we copy the value straight from that table now (during optimization), instead of from the temporary table created during execution.</p>
<p class="">TODO: Synchronize with the temporary table creation code, so that there is no need to create a column for this value.</p>

</div>
</div>
<a id="gab466b49a22220854ef8f11a2c4a2ae8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab466b49a22220854ef8f11a2c4a2ae8a">&#9670;&nbsp;</a></span>decide_subquery_strategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::decide_subquery_strategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Decides between EXISTS and materialization; performs last steps to set up the chosen strategy. </p><dl class="section return"><dt>Returns</dt><dd>'false' if no error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If UNION this is called on each contained <a class="el" href="classJOIN.html">JOIN</a>. </dd></dl>

</div>
</div>
<a id="gaf2d76654da99be4012095c016ea5d4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d76654da99be4012095c016ea5d4d2">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::destroy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Clean up and destroy join object.</p>
<dl class="section return"><dt>Returns</dt><dd>false if previous execution was successful, and true otherwise </dd></dl>

</div>
</div>
<a id="ga54392f4f40ec2c57b8263f22fa3d4296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54392f4f40ec2c57b8263f22fa3d4296">&#9670;&nbsp;</a></span>drop_unused_derived_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::drop_unused_derived_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop unused keys for each materialized derived table/view. </p>
<p class="">For each materialized derived table/view, call TABLE::use_index to save one index chosen by the optimizer and ignore others. If no key is chosen, then all keys will be ignored. </p>

</div>
</div>
<a id="gada415e1d087c014e9b8a22b39980bfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada415e1d087c014e9b8a22b39980bfea">&#9670;&nbsp;</a></span>effective_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint QEP_TAB::effective_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the index used for a table in a QEP</dd></dl>
<p>Return the index used for a table in a QEP</p>
<p class="">The various access methods have different places where the index/key number is stored, so this function is needed to return the correct value.</p>
<dl class="section return"><dt>Returns</dt><dd>index number, or MAX_KEY if not applicable.</dd></dl>
<p>JT_SYSTEM and JT_ALL does not use an index, and will always return MAX_KEY.</p>
<p class="">JT_INDEX_MERGE supports more than one index. Hence MAX_KEY is returned and a further inspection is needed. </p>

</div>
</div>
<a id="gaf1351457ee30a4e67786117e50413541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1351457ee30a4e67786117e50413541">&#9670;&nbsp;</a></span>error_if_full_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool error_if_full_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Give error if we some tables are done with a full join.</p>
<p class="">This is used by multi_table_update and multi_table_delete when running in safe mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Error (full join used) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae89dde6a1925032ade263c27a87529f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae89dde6a1925032ade263c27a87529f">&#9670;&nbsp;</a></span>filter_virtual_gcol_base_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE::filter_virtual_gcol_base_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Filter the base columns of virtual generated columns if using a covering index scan.</p>
<p class="">When setting up the join buffer, adjust read_set temporarily so that only contains the columns that are needed in the join operation and afterwards. Afterwards, the regular contents are restored (the columns to be read from input tables).</p>
<p class="">For a virtual generated column, all base columns are added to the read_set of the table. The storage engine will then copy all base column values so that the value of the GC can be calculated inside the executor. But when a virtual GC is fetched using a covering index, the actual GC value is fetched by the storage engine and the base column values are not needed. Join buffering code must not try to copy them (in create_remaining_fields()). So, we eliminate from read_set those columns that are available from the covering index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qep_tab</td><td>the table to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe6fc3febf146805e30ce17267d4dd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe6fc3febf146805e30ce17267d4dd98">&#9670;&nbsp;</a></span>find_item_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Item_equal* find_item_equal </td>
          <td>(</td>
          <td class="paramtype">COND_EQUAL *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>inherited_fl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find the multiple equality predicate containing a field.</p>
<p class="">The function retrieves the multiple equalities accessed through the cond_equal structure from current level and up looking for an equality containing a field. It stops retrieval as soon as the equality is found and set up inherited_fl to TRUE if it's found on upper levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond_equal</td><td>multiple equalities to search in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">item_field</td><td>field to look for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inherited_fl</td><td>set up to TRUE if multiple equality is found on upper levels (not on current level of cond_equal)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Item_equal for the found multiple equality predicate if a success;</li>
<li>NULL otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafd0c3fdb07be77d705feaf3f8f51164f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd0c3fdb07be77d705feaf3f8f51164f">&#9670;&nbsp;</a></span>find_shortest_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint find_shortest_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *&#160;</td>
          <td class="paramname"><em>usable_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find shortest key suitable for full table scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table to scan </td></tr>
    <tr><td class="paramname">usable_keys</td><td>Allowed keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As far as 1) clustered primary key entry data set is a set of all record fields (key fields and not key fields) and 2) secondary index entry data is a union of its key fields and primary key fields (at least InnoDB and its derivatives don't duplicate primary key fields there, even if the primary and the secondary keys have a common subset of key fields), then secondary index entry data is always a subset of primary key entry. Unfortunately, key_info[nr].key_length doesn't show the length of key/pointer pair but a sum of key field lengths only, thus we can't estimate index IO volume comparing only this key_length value of secondary keys and clustered PK. So, try secondary keys first, and choose PK only if there are no usable secondary covering keys or found best secondary key include all table fields (i.e. same as PK):</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>MAX_KEY no suitable key found key index otherwise </dd></dl>

</div>
</div>
<a id="ga59080a3acd829efcf18fc56d51df215c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59080a3acd829efcf18fc56d51df215c">&#9670;&nbsp;</a></span>free_underlaid_joins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_underlaid_joins </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Free joins of subselect of this select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">select</td><td>pointer to st_select_lex which subselects joins we will free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c20a9b8d13f14275a4ee01f44f8cfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c20a9b8d13f14275a4ee01f44f8cfa2">&#9670;&nbsp;</a></span>fts_index_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::fts_index_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if FTS index only access is possible</p>
<p class="">Check if FTS index only access is possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>pointer to <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if index only access is possible, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga92bf64a03ec666f565627fbb48ba4677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bf64a03ec666f565627fbb48ba4677">&#9670;&nbsp;</a></span>generate_derived_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::generate_derived_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add keys to derived tables'/views' result tables in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">select_lex</td><td>generate derived keys for select_lex's derived tables</td></tr>
  </table>
  </dd>
</dl>
<p>This function generates keys for all derived tables/views of the select_lex to which this join corresponds to with help of the <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>:generate_keys function.</p>
<dl class="section return"><dt>Returns</dt><dd>FALSE all keys were successfully added. </dd>
<dd>
TRUE OOM error </dd></dl>

</div>
</div>
<a id="gae9c1cf0874f4bda777557d012148e059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c1cf0874f4bda777557d012148e059">&#9670;&nbsp;</a></span>get_best_combination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::get_best_combination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Set up <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> structs according to the picked join order in best_positions. This allocates execution structures so may be called only after we have the very final plan. It must be called after Optimize_table_order::fix_semijoin_strategies().</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, True if error</dd></dl>
<ul>
<li>create join-&gt;join_tab array and copy from existing JOIN_TABs in join order</li>
<li>create helper structs for materialized semi-join handling</li>
<li>finalize semi-join strategy choices</li>
<li>Number of intermediate tables "tmp_tables" is calculated.</li>
<li>"tables" and "primary_tables" are recalculated.</li>
<li>for full and index scans info of estimated # of records is updated.</li>
<li>in a helper function:<ul>
<li>all heuristics are applied and the final access method type is picked for each join_tab (only test_if_skip_sortorder() could override it)</li>
<li>AM consistency is ensured (e.g only range and index merge are allowed to have quick select set).</li>
<li>if "Impossible WHERE" is detected - appropriate zero_result_cause is set.</li>
</ul>
</li>
</ul>
<p class="">Notice that intermediate tables will not have a POSITION reference; and they will not have a <a class="el" href="structTABLE.html">TABLE</a> reference before the final stages of code generation.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000095">Todo:</a></b></dt><dd>the block which sets tab-&gt;type should move to adjust_access_methods for unification. </dd></dl>

</div>
</div>
<a id="ga67d1175177356bf1c9b05e9104d28c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d1175177356bf1c9b05e9104d28c5b">&#9670;&nbsp;</a></span>get_best_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__field.html">Item_field</a>* get_best_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND_EQUAL *&#160;</td>
          <td class="paramname"><em>cond_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Get the best field substitution for a given field.</p>
<p class="">If the field is member of a multiple equality, look up that equality and return the most appropriate field. Usually this is the equivalenced field belonging to the outer-most table in the join order, but </p><dl class="section see"><dt>See also</dt><dd>Item_field::get_subst_item() for details. Otherwise, return the same field.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_field</td><td>The field that we are seeking a substitution for. </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The substituted field. </dd></dl>

</div>
</div>
<a id="ga92d8a0c25d038fddac9b92696f6845e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d8a0c25d038fddac9b92696f6845e3">&#9670;&nbsp;</a></span>get_index_for_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint get_index_for_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find a key to apply single table UPDATE/DELETE by a given ORDER</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table to find a key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select</td><td>Pointer to access/update select-&gt;quick (if any) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">limit</td><td>LIMIT clause parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_sort</td><td>TRUE if filesort needed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reverse</td><td>TRUE if the key is reversed again given ORDER (undefined if key == MAX_KEY)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>MAX_KEY if no key found (need_sort == TRUE)</li>
<li>MAX_KEY if quick select result order is OK (need_sort == FALSE)</li>
<li>key number (either index scan or quick select) (need_sort == FALSE)</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Side effects:<ul>
<li>may deallocate or deallocate and replace select-&gt;quick;</li>
<li>may set table-&gt;quick_condition_rows and table-&gt;quick_rows[...] to table-&gt;file-&gt;stats.records. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaee0363af5ecbde624f02fbc38a695a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee0363af5ecbde624f02fbc38a695a3b">&#9670;&nbsp;</a></span>get_sj_strategy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint QEP_TAB::get_sj_strategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>semijoin strategy for this table. </dd></dl>

</div>
</div>
<a id="gabc77304fe7c751bce4fa59ef52d91fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc77304fe7c751bce4fa59ef52d91fb0">&#9670;&nbsp;</a></span>get_sj_strategy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint JOIN_TAB::get_sj_strategy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>semijoin strategy for this table. </dd></dl>

</div>
</div>
<a id="gae77d58d476f44178e469e2cbe16e9e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae77d58d476f44178e469e2cbe16e9e01">&#9670;&nbsp;</a></span>handle_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handle_query </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_result *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>added_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>removed_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Handle a data manipulation query, from preparation through cleanup</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">lex</td><td>query to be processed </td></tr>
    <tr><td class="paramname">result</td><td>sink of result of query execution. may be protocol object (for passing result to a client), insert object, update object, delete object, etc. </td></tr>
    <tr><td class="paramname">added_options</td><td>additional options for detailed control over execution </td></tr>
    <tr><td class="paramname">removed_options</td><td>options that are not applicable for this command</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error</dd></dl>
<p>Processing a query goes through 5 phases (parsing is already done)</p><ul>
<li>Preparation</li>
<li>Locking of tables</li>
<li>Optimization</li>
<li>Execution or explain</li>
<li>Cleanup The queries handled by this function are:</li>
</ul>
<p class="">SELECT INSERT ... SELECT REPLACE ... SELECT UPDATE (multi-table) DELETE (multi-table)</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000118">Todo:</a></b></dt><dd>make this function also handle INSERT ... VALUES, single-table UPDATE and DELETE, SET and DO.</dd></dl>
<p class=""><br />
 The function processes simple query expressions without UNION and without multi-level ORDER BY/LIMIT separately. Such queries are executed with a more direct code path. </p>

</div>
</div>
<a id="gab3dbb0f8b69dc30985e0d9a0ff94121f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3dbb0f8b69dc30985e0d9a0ff94121f">&#9670;&nbsp;</a></span>init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN_CACHE_BNL::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Initialize operation's internal state. Called once per query execution. </p>

<p>Implements <a class="el" href="classJOIN__CACHE.html#a1dcdce348bba725c675b327eb90aa924">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="ga327376f63198bf31a770fb89242d49aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga327376f63198bf31a770fb89242d49aa">&#9670;&nbsp;</a></span>init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN_CACHE_BKA::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Initialize operation's internal state. Called once per query execution. </p>

<p>Implements <a class="el" href="classJOIN__CACHE.html#a1dcdce348bba725c675b327eb90aa924">JOIN_CACHE</a>.</p>

<p>Reimplemented in <a class="el" href="group__Query__Optimizer.html#gaa7ca6a85294c32bac8c69bea0c4e5fe1">JOIN_CACHE_BKA_UNIQUE</a>.</p>

</div>
</div>
<a id="gaa7ca6a85294c32bac8c69bea0c4e5fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7ca6a85294c32bac8c69bea0c4e5fe1">&#9670;&nbsp;</a></span>init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN_CACHE_BKA_UNIQUE::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Initialize operation's internal state. Called once per query execution. </p>

<p>Reimplemented from <a class="el" href="group__Query__Optimizer.html#ga327376f63198bf31a770fb89242d49aa">JOIN_CACHE_BKA</a>.</p>

</div>
</div>
<a id="ga44c5164eb9405b18a16ca8a3ee339047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44c5164eb9405b18a16ca8a3ee339047">&#9670;&nbsp;</a></span>init_join_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_TAB::init_join_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">A helper function that allocates appropriate join cache object and sets next_select function of previous tab. </p>

</div>
</div>
<a id="gaa992e841315769954816105b951d3e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa992e841315769954816105b951d3e17">&#9670;&nbsp;</a></span>is_indexed_agg_distinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_indexed_agg_distinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__field.html">Item_field</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check for the presence of AGGFN(DISTINCT a) queries that may be subject to loose index scan.</p>
<p class="">Check if the query is a subject to AGGFN(DISTINCT) using loose index scan (<a class="el" href="classQUICK__GROUP__MIN__MAX__SELECT.html">QUICK_GROUP_MIN_MAX_SELECT</a>). Optionally (if out_args is supplied) will push the arguments of AGGFN(DISTINCT) to the list</p>
<p class="">Check for every COUNT(DISTINCT), AVG(DISTINCT) or SUM(DISTINCT). These can be resolved by Loose Index Scan as long as all the aggregate distinct functions refer to the same fields. Thus:</p>
<p class="">SELECT AGGFN(DISTINCT a, b), AGGFN(DISTINCT b, a)... =&gt; can use LIS SELECT AGGFN(DISTINCT a), AGGFN(DISTINCT a) ... =&gt; can use LIS SELECT AGGFN(DISTINCT a, b), AGGFN(DISTINCT a) ... =&gt; cannot use LIS SELECT AGGFN(DISTINCT a), AGGFN(DISTINCT b) ... =&gt; cannot use LIS etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>the join to check </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_args</td><td>Collect the arguments of the aggregate functions to a list. We don't worry about duplicates as these will be sorted out later in get_best_group_min_max.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>does the query qualify for indexed AGGFN(DISTINCT) </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>it does </td></tr>
    <tr><td class="paramname">false</td><td>AGGFN(DISTINCT) must apply distinct in it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a8d854a364ab749539a9363619acf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a8d854a364ab749539a9363619acf99">&#9670;&nbsp;</a></span>is_subkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_subkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>ref_key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>ref_key_part_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Test if a second key is the subkey of the first one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key_part</td><td>First key parts </td></tr>
    <tr><td class="paramname">ref_key_part</td><td>Second key parts </td></tr>
    <tr><td class="paramname">ref_key_part_end</td><td>Last+1 part of the second key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Second key MUST be shorter than the first one.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>is a subkey </td></tr>
    <tr><td class="paramname">0</td><td>no sub key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa62d47da29f3853e87b1069ee5c1ff21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62d47da29f3853e87b1069ee5c1ff21">&#9670;&nbsp;</a></span>join_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::join_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Release memory and, if possible, the open tables held by this execution plan (and nested plans). It's used to release some tables before the end of execution in order to increase concurrency and reduce memory consumption.</p>
<p class="">Partially cleanup <a class="el" href="classJOIN.html">JOIN</a> after it has executed: close index or rnd read (table cursors), free quick selects.</p>
<p class="">This function is called in the end of execution of a <a class="el" href="classJOIN.html">JOIN</a>, before the used tables are unlocked and closed.</p>
<p class="">For a join that is resolved using a temporary table, the first sweep is performed against actual tables and an intermediate result is inserted into the temprorary table. The last sweep is performed against the temporary table. Therefore, the base tables and associated buffers used to fill the temporary table are no longer needed, and this function is called to free them.</p>
<p class="">For a join that is performed without a temporary table, this function is called after all rows are sent, but before EOF packet is sent.</p>
<p class="">For a simple SELECT with no subqueries this function performs a full cleanup of the <a class="el" href="classJOIN.html">JOIN</a> and calls mysql_unlock_read_tables to free used base tables.</p>
<p class="">If a <a class="el" href="classJOIN.html">JOIN</a> is executed for a subquery or if it has a subquery, we can't do the full cleanup and need to do a partial cleanup only.</p><ul>
<li>If a <a class="el" href="classJOIN.html">JOIN</a> is not the top level join, we must not unlock the tables because the outer select may not have been evaluated yet, and we can't unlock only selected tables of a query.</li>
<li>Additionally, if this <a class="el" href="classJOIN.html">JOIN</a> corresponds to a correlated subquery, we should not free quick selects and join buffers because they will be needed for the next execution of the correlated subquery.</li>
<li>However, if this is a <a class="el" href="classJOIN.html">JOIN</a> for a [sub]select, which is not a correlated subquery itself, but has subqueries, we can free it fully and also free JOINs of all its subqueries. The exception is a subquery in SELECT list, e.g: <br />
 SELECT a, (select max(b) from t1) group by c <br />
 This subquery will not be evaluated at first sweep and its value will not be inserted into the temporary table. Instead, it's evaluated when selecting from the temporary table. Therefore, it can't be freed here even though it's not correlated.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000119">Todo:</a></b></dt><dd>Unlock tables even if the join isn't top level select in the tree </dd></dl>

</div>
</div>
<a id="gaedf2fb3248e5d013e6a74b29dd9e7429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf2fb3248e5d013e6a74b29dd9e7429">&#9670;&nbsp;</a></span>make_cond_for_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* make_cond_for_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>used_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclude_expensive_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Extract a condition that can be checked after reading given table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to analyze </td></tr>
    <tr><td class="paramname">tables</td><td>Tables for which "current field values" are available </td></tr>
    <tr><td class="paramname">used_table</td><td>Table(s) that we are extracting the condition for (may also include PSEUDO_TABLE_BITS, and may be zero) </td></tr>
    <tr><td class="paramname">exclude_expensive_cond</td><td>Do not push expensive conditions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;&gt;NULL</td><td>Generated condition </td></tr>
    <tr><td class="paramname">=</td><td>NULL Already checked, OR error</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the condition that can be checked after reading the table(s) specified in <code>used_table</code>, given that current-field values for tables specified in <code>tables</code> bitmap are available. If <code>used_table</code> is 0, extract conditions for all tables in <code>tables</code>.</p>
<p class="">This function can be used to extract conditions relevant for a table in a join order. Together with its caller, it will ensure that all conditions are attached to the first table in the join order where all necessary fields are available, and it will also ensure that a given condition is attached to only one table. To accomplish this, first initialize <code>tables</code> to the empty set. Then, loop over all tables in the join order, set <code>used_table</code> to the bit representing the current table, accumulate <code>used_table</code> into the <code>tables</code> set, and call this function. To ensure correct handling of const expressions and outer references, add the const table map and OUTER_REF_TABLE_BIT to <code>used_table</code> for the first table. To ensure that random expressions are evaluated for the final table, add RAND_TABLE_BIT to <code>used_table</code> for the final table.</p>
<p class="">The function assumes that constant, inexpensive parts of the condition have already been checked. Constant, expensive parts will be attached to the first table in the join order, provided that the above call sequence is followed.</p>
<p class="">The call order will ensure that conditions covering tables in <code>tables</code> minus those in <code>used_table</code>, have already been checked.</p>
<p class=""><br />
 The function takes into account that some parts of the condition are guaranteed to be true by employed 'ref' access methods (the code that does this is located at the end, search down for "EQ_FUNC").</p>
<dl class="section note"><dt>Note</dt><dd>make_cond_for_info_schema() uses an algorithm similar to <a class="el" href="group__Query__Optimizer.html#gaedf2fb3248e5d013e6a74b29dd9e7429">make_cond_for_table()</a>. </dd></dl>

</div>
</div>
<a id="ga27b74179b9a9207753aa3f93a9df4225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27b74179b9a9207753aa3f93a9df4225">&#9670;&nbsp;</a></span>make_join_readinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool make_join_readinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>no_jbuf_after</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Plan refinement stage: do various setup things for the executor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join being processed </td></tr>
    <tr><td class="paramname">no_jbuf_after</td><td>Don't use join buffering after table with this number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if successful, true if error (Out of memory)</dd></dl>
<p>Plan refinement stage: do various set ups for the executioner</p><ul>
<li>setup join buffering use</li>
<li>push index conditions</li>
<li>increment relevant counters</li>
<li>etc </li>
</ul>

</div>
</div>
<a id="gae713fbd3faf5b5aefad41408fd11685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae713fbd3faf5b5aefad41408fd11685a">&#9670;&nbsp;</a></span>make_sum_func_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::make_sum_func_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>send_result_set_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>before_group_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>FALSE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Initialize 'sum_funcs' array with all <a class="el" href="classItem__sum.html">Item_sum</a> objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_list</td><td>All items </td></tr>
    <tr><td class="paramname">send_result_set_metadata</td><td>Items in select list </td></tr>
    <tr><td class="paramname">before_group_by</td><td>Set to 1 if this is called before GROUP BY handling </td></tr>
    <tr><td class="paramname">recompute</td><td>Set to TRUE if sum_funcs must be recomputed</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0db5dc577ffd7662b800cc6307183c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db5dc577ffd7662b800cc6307183c2b">&#9670;&nbsp;</a></span>mark_const_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::mark_const_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Move const tables first in the position array.</p>
<p class="">Increment the number of const tables and set same basic properties for the const table. A const table looked up by a key has type JT_CONST. A const table with a single row has type JT_SYSTEM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table that is designated as a const table </td></tr>
    <tr><td class="paramname">key</td><td>The key definition to use for this table (NULL if table scan) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f722315c64ce97cff639d705107c660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f722315c64ce97cff639d705107c660">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN::optimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Optimizes one query block into a query execution plan (QEP.)</p>
<p class="">This is the entry point to the query optimization phase. This phase applies both logical (equivalent) query rewrites, cost-based join optimization, and rule-based access path selection. Once an optimal plan is found, the member function creates/initializes all structures needed for query execution. The main optimization phases are outlined below:</p>
<ol type="1">
<li>Logical transformations:<ul>
<li>Outer to inner joins transformation.</li>
<li>Equality/constant propagation.</li>
<li>Partition pruning.</li>
<li>COUNT(*), MIN(), MAX() constant substitution in case of implicit grouping.</li>
<li>ORDER BY optimization.</li>
</ul>
</li>
<li>Perform cost-based optimization of table order and access path selection. See JOIN::make_join_plan()</li>
<li>Post-join order optimization:<ul>
<li>Create optimal table conditions from the where clause and the join conditions.</li>
<li>Inject outer-join guarding conditions.</li>
<li>Adjust data access methods after determining table condition (several times.)</li>
<li>Optimize ORDER BY/DISTINCT.</li>
</ul>
</li>
<li>Code generation<ul>
<li>Set data access functions.</li>
<li>Try to optimize away sorting/distinct.</li>
<li>Setup temporary table usage for grouping and/or sorting.</li>
</ul>
</li>
</ol>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">1</td><td>Error, error code saved in member <a class="el" href="classJOIN.html#a3af313be65a65eb809cb2f11e6e84b0b" title="set in optimize(), exec(), prepare_result()">JOIN::error</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000091">Todo:</a></b></dt><dd>This query block didn't transform itself in SELECT_LEX::prepare(), so belongs to a parent query block. That parent, or its parents, had to transform us - it has not; maybe it is itself in prepare() and evaluating the present query block as an <a class="el" href="classItem__subselect.html">Item_subselect</a>. Such evaluation in prepare() is expected to be a rare case to be eliminated in the future ("SET x=(subq)" is one such case; because it locks tables before prepare()). </dd></dl>

</div>
</div>
<a id="ga768e4d9b55252e39161f392f34cb5abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga768e4d9b55252e39161f392f34cb5abc">&#9670;&nbsp;</a></span>optimize_cond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool optimize_cond </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND_EQUAL **&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item::cond_result *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Optimize conditions by</p>
<p class="">a) applying transitivity to build multiple equality predicates (MEP): if x=y and y=z the MEP x=y=z is built. b) apply constants where possible. If the value of x is known to be 42, x is replaced with a constant of value 42. By transitivity, this also applies to MEPs, so the MEP in a) will become 42=x=y=z. c) remove conditions that are always false or always true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cond</td><td>WHERE or HAVING condition to optimize </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_equal</td><td>The built multiple equalities </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list of join operations with join conditions = NULL: Called for HAVING condition </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_value</td><td>Not changed if cond was empty COND_TRUE if cond is always true COND_FALSE if cond is impossible COND_OK otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gaac99b2256ee62ddd1a435289c2acb8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac99b2256ee62ddd1a435289c2acb8e2">&#9670;&nbsp;</a></span>optimize_rollup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::optimize_rollup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Optimize rollup specification.</p>
<p class="">Allocate objects needed for rollup processing.</p>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error. </dd></dl>

</div>
</div>
<a id="gabed62f6e6cc8f6d042c806a154ea7137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabed62f6e6cc8f6d042c806a154ea7137">&#9670;&nbsp;</a></span>prepare_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::prepare_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Prepare join result.</p>
<p class="">Prepare join result prior to join execution or describing. Instantiate derived tables and get schema tables result if necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE An error during derived or schema tables instantiation. FALSE Ok </dd></dl>

</div>
</div>
<a id="ga5ededf725731bb0cfd5a3871181f496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ededf725731bb0cfd5a3871181f496e">&#9670;&nbsp;</a></span>push_index_cond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_TAB::push_index_cond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>trace_obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Try to extract and push the index condition down to table handler</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_tab</td><td>join_tab for table </td></tr>
    <tr><td class="paramname">keyno</td><td>Index for which extract and push the condition </td></tr>
    <tr><td class="paramname">trace_obj</td><td>trace object where information is to be added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga812222f5f9eb4a9026c8ce89069ef8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga812222f5f9eb4a9026c8ce89069ef8d7">&#9670;&nbsp;</a></span>read_all_flag_fields_by_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE::read_all_flag_fields_by_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>rec_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Reads all flag fields of a positioned record from the join buffer. Including all flag fields (of this record) stored in the previous join buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec_ptr</td><td>position of the first field of the record in the join buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa19cecc5eccee0ff1285c62769daf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa19cecc5eccee0ff1285c62769daf39">&#9670;&nbsp;</a></span>read_some_flag_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE::read_some_flag_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Read some flag fields of a record from the join buffer.</p>
<p class="">Reads all flag fields stored in this join buffer, for the current record (at 'pos'). If the buffer is incremental, flag fields of this record which are stored in previous join buffers are <em>not</em> read so remain unknown: caller must then make sure to call this function on previous buffers too.</p>
<p class="">The flag fields are read starting from the position 'pos'. The function increments the value of 'pos' by the length of the read data.</p>
<p class="">Flag fields are copied back to their source. </p>

</div>
</div>
<a id="ga20c8bd509fba4099611e8a7b01c115d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20c8bd509fba4099611e8a7b01c115d8">&#9670;&nbsp;</a></span>read_some_record_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN_CACHE::read_some_record_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Read some flag and data fields of a record from the join buffer.</p>
<p class="">Reads all fields (flag and data fields) stored in this join buffer, for the current record (at 'pos'). If the buffer is incremental, fields of this record which are stored in previous join buffers are <em>not</em> read so remain unknown: caller must then make sure to call this function on previous buffers too.</p>
<p class="">The fields are read starting from the position 'pos' which is supposed to point to the beginning of the first record field. The function increments the value of 'pos' by the length of the read data.</p>
<p class="">Flag fields are copied back to their source; data fields are copied to the record's buffer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">(-1)</td><td>if there are no more records in the join buffer </td></tr>
    <tr><td class="paramname">&lt;&gt;(-1)</td><td>length of the data read from the join buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef4f64b9b280796d9abe945b2eda94ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4f64b9b280796d9abe945b2eda94ac">&#9670;&nbsp;</a></span>refine_best_rowcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::refine_best_rowcount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Refine the best_rowcount estimation based on what happens after tables have been joined: LIMIT and type of result sink. </p>

</div>
</div>
<a id="gaf8c7623dfe6301253414f9155999c43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8c7623dfe6301253414f9155999c43b">&#9670;&nbsp;</a></span>remove_eq_conds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool remove_eq_conds </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>retcond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item::cond_result *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Remove const and eq items. Return new item, or NULL if no condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>the condition to handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retcond</td><td>condition after const removal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_value</td><td>resulting value of the condition =COND_OK condition must be evaluated (e.g field = constant) =COND_TRUE always true (e.g 1 = 1) =COND_FALSE always false (e.g 1 = 2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>calls internal_remove_eq_conds() to check the complete tree.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if success, true if error </dd></dl>

</div>
</div>
<a id="gad4e09d71987062663db1836d651ec4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e09d71987062663db1836d651ec4d4">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reset the state of this join object so that it is ready for a new execution. </p>

</div>
</div>
<a id="gad54e309ac7f0fd377d7a422ea54f59f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54e309ac7f0fd377d7a422ea54f59f8">&#9670;&nbsp;</a></span>reset_cache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE::reset_cache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_writing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the join buffer for reading/writing: default implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">for_writing</td><td>if it's TRUE the function reset the buffer for writing</td></tr>
  </table>
  </dd>
</dl>
<p>This default implementation of the virtual function <a class="el" href="group__Query__Optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8" title="Reset the join buffer for reading/writing: default implementation.">reset_cache()</a> resets the join buffer for reading or writing. If the buffer is reset for reading only the 'pos' value is reset to point to the very beginning of the join buffer. If the buffer is reset for writing additionally:</p><ul>
<li>the counter of the records in the buffer is set to 0,</li>
<li>the the value of 'last_rec_pos' gets pointing at the position just before the buffer,</li>
<li>'end_pos' is set to point to the beginning of the join buffer,</li>
<li>the size of the auxiliary buffer is reset to 0,</li>
<li>the flag 'last_rec_blob_data_is_in_rec_buff' is set to 0. </li>
</ul>

<p>Reimplemented in <a class="el" href="group__Query__Optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7">JOIN_CACHE_BKA_UNIQUE</a>.</p>

</div>
</div>
<a id="gafb1afc6322b69d01ea68b677b715ddc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb1afc6322b69d01ea68b677b715ddc7">&#9670;&nbsp;</a></span>reset_cache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE_BKA_UNIQUE::reset_cache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_writing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the join buffer for reading/writing: default implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">for_writing</td><td>if it's TRUE the function reset the buffer for writing</td></tr>
  </table>
  </dd>
</dl>
<p>This default implementation of the virtual function <a class="el" href="group__Query__Optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7" title="Reset the join buffer for reading/writing: default implementation.">reset_cache()</a> resets the join buffer for reading or writing. If the buffer is reset for reading only the 'pos' value is reset to point to the very beginning of the join buffer. If the buffer is reset for writing additionally:</p><ul>
<li>the counter of the records in the buffer is set to 0,</li>
<li>the the value of 'last_rec_pos' gets pointing at the position just before the buffer,</li>
<li>'end_pos' is set to point to the beginning of the join buffer,</li>
<li>the size of the auxiliary buffer is reset to 0,</li>
<li>the flag 'last_rec_blob_data_is_in_rec_buff' is set to 0. </li>
</ul>

<p>Reimplemented from <a class="el" href="group__Query__Optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8">JOIN_CACHE</a>.</p>

</div>
</div>
<a id="gabfdf6220265d56c5dc44081d89abc73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfdf6220265d56c5dc44081d89abc73e">&#9670;&nbsp;</a></span>restore_virtual_gcol_base_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN_CACHE::restore_virtual_gcol_base_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">After <a class="el" href="classJOIN__CACHE.html">JOIN_CACHE</a> initialization, the table-&gt;read_set is restored so that the virtual generated column can be calculated during later time. </p>

</div>
</div>
<a id="ga7e92b14b52e210ce225ad4c0312f9bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e92b14b52e210ce225ad4c0312f9bca">&#9670;&nbsp;</a></span>rollup_make_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::rollup_make_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> ***&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Fill up rollup structures with pointers to fields to use.</p>
<p class="">Creates copies of item_sum items for each sum level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fields_arg</td><td><a class="el" href="classList.html">List</a> of all fields (hidden and real ones) </td></tr>
    <tr><td class="paramname">sel_fields</td><td>Pointer to selected fields </td></tr>
    <tr><td class="paramname">func</td><td>Store here a pointer to all fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ok; In this case func is pointing to next not used element. </td></tr>
    <tr><td class="paramname">1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga076b7e6736c0bf0a9e9bf7542e4746c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga076b7e6736c0bf0a9e9bf7542e4746c8">&#9670;&nbsp;</a></span>rollup_process_const_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::rollup_process_const_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Wrap all constant Items in GROUP BY list.</p>
<p class="">For ROLLUP queries each constant item referenced in GROUP BY list is wrapped up into an <a class="el" href="classItem__func.html">Item_func</a> object yielding the same value as the constant item. The objects of the wrapper class are never considered as constant items and besides they inherit all properties of the <a class="el" href="classItem__result__field.html">Item_result_field</a> class. This wrapping allows us to ensure writing constant items into temporary tables whenever the result of the ROLLUP operation has to be written into a temporary table, e.g. when ROLLUP is used together with DISTINCT in the SELECT list. Usually when creating temporary tables for a intermidiate result we do not include fields for constant expressions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ok </td></tr>
    <tr><td class="paramname">1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadbc980a72c17c8442fab87af085697d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbc980a72c17c8442fab87af085697d4">&#9670;&nbsp;</a></span>simple_remove_const()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__order.html">ORDER</a>* simple_remove_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Filter out ORDER items those are equal to constants in WHERE</p>
<p class="">This function is a limited version of remove_const() for use with non-<a class="el" href="classJOIN.html">JOIN</a> statements (i.e. single-table UPDATE and DELETE).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramname">cond</td><td>WHERE expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new filtered ORDER list or NULL if whole list eliminated</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function overwrites input order list. </dd></dl>

</div>
</div>
<a id="gac2c4cb376fec34447cf5df2b3d4c238a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2c4cb376fec34447cf5df2b3d4c238a">&#9670;&nbsp;</a></span>sjm_query_block_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint QEP_TAB::sjm_query_block_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>query block id for an inner table of materialized semi-join, and 0 for all other tables. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>implementation is not efficient (loops over all tables) - use this function only in EXPLAIN. </dd></dl>

</div>
</div>
<a id="ga6afa1e2231c8090ecae73554fca37c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6afa1e2231c8090ecae73554fca37c41">&#9670;&nbsp;</a></span>skip_index_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN_CACHE_BKA_UNIQUE::skip_index_tuple </td>
          <td>(</td>
          <td class="paramtype">range_seq_t&#160;</td>
          <td class="paramname"><em>rseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>range_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if the record combination matches the index condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rseq</td><td>Value returned by bka_range_seq_init() </td></tr>
    <tr><td class="paramname">range_info</td><td>MRR range association data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>JOIN_CACHE_BKA::skip_index_tuple(). This function is the variant for use with <a class="el" href="classJOIN__CACHE__BKA__UNIQUE.html">JOIN_CACHE_BKA_UNIQUE</a>. The difference from <a class="el" href="classJOIN__CACHE__BKA.html">JOIN_CACHE_BKA</a> case is that there may be multiple previous table record combinations that share the same key, i.e. they map to the same MRR range. And for all of those records, we have just done one single key lookup in the current table, found an index tuple. If in this function we discard this index tuple, all those records will be eliminated from the result. Thus, in this function we can discard the index tuple only if <em>all</em> those cached records and the index tuple don't match the pushed index condition. It's a "group-wide
decision". Thus we must here loop through all previous table records combinations that match the given MRR range key range_info, searching for a single one matching the index condition. If we find none, we can safely discard the index tuple here, which avoids retrieving the record from the current table. If we instead find one, we cannot discard the index tuple here; later in execution, in join_matching_records(), we can finally take one "case-by-case decision" per cached record, by checking again the index condition (</dd>
<dd>
<a class="el" href="group__Query__Optimizer.html#gafd031be055cee296d6629313a333b56f">JOIN_CACHE_BKA_UNIQUE::check_match</a>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Possible optimization: Before we unpack the record from a previous table check if this table is used in the condition. If so then unpack the record otherwise skip the unpacking. This should be done by a special virtual method get_partial_record_by_pos().</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>The record combination satisfies the index condition </td></tr>
    <tr><td class="paramname">true</td><td>Otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga253393c0747cf378b9cefa109662bd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga253393c0747cf378b9cefa109662bd17">&#9670;&nbsp;</a></span>substitute_for_best_equal_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* substitute_for_best_equal_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COND_EQUAL *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>table_join_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Substitute every field reference in a condition by the best equal field and eliminate all multiple equality predicates.</p>
<p class="">The function retrieves the cond condition and for each encountered multiple equality predicate it sorts the field references in it according to the order of tables specified by the table_join_idx parameter. Then it eliminates the multiple equality predicate it replacing it by the conjunction of simple equality predicates equating every field from the multiple equality to the first field in it, or to the constant, if there is any. After this the function retrieves all other conjuncted predicates substitute every field reference by the field reference to the first equal field or equal constant if there are any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition to process </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities to take into consideration </td></tr>
    <tr><td class="paramname">table_join_idx</td><td>index to tables determining field preference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>At the first glance full sort of fields in multiple equality seems to be an overkill. Yet it's not the case due to possible new fields in multiple equality item of lower levels. We want the order in them to comply with the order of upper levels.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed condition, or NULL in case of error </dd></dl>

</div>
</div>
<a id="gaa95a062cdd785687a638e01d7ad85d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa95a062cdd785687a638e01d7ad85d11">&#9670;&nbsp;</a></span>substitute_gc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool substitute_gc </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>where_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Substitute all expressions in the WHERE condition and ORDER/GROUP lists that match generated columns (GC) expressions with GC fields, if any.</p>
<p class="">This function does 3 things: 1) Creates list of all GC fields that are a part of a key and the GC expression is a function. All query tables are scanned. If there's no such fields, function exits. 2) By means of Item::compile() WHERE clause is transformed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classItem__func.html#acac46454222156dbb8336cc709c6cf41">Item_func::gc_subst_transformer()</a> for details. 3) If there's ORDER/GROUP BY clauses, this function tries to substitute expressions in these lists with GC too. It removes from the list of indexed GC all elements which index blocked by hints. This is done to reduce amount of further work. Next it goes through ORDER/GROUP BY list and matches the expression in it against GC expressions in indexed GC list. When a match is found, the expression is replaced with a new <a class="el" href="classItem__field.html">Item_field</a> for the matched GC field. Also, this new field is added to the hidden part of all_fields list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">select_lex</td><td>the current select </td></tr>
    <tr><td class="paramname">where_cond</td><td>the WHERE condition, possibly NULL </td></tr>
    <tr><td class="paramname">group_list</td><td>the GROUP BY clause, possibly NULL </td></tr>
    <tr><td class="paramname">order</td><td>the ORDER BY clause, possibly NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the GROUP BY clause or the ORDER BY clause was changed, false otherwise </dd></dl>

</div>
</div>
<a id="ga3eec84bb823e8a5ea10710e1e4f066d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eec84bb823e8a5ea10710e1e4f066d1">&#9670;&nbsp;</a></span>test_if_cheaper_ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool test_if_cheaper_ordering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBitmap_3_0164_01_4.html">key_map</a>&#160;</td>
          <td class="paramname"><em>usable_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>new_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>new_key_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows *&#160;</td>
          <td class="paramname"><em>new_select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>new_used_key_parts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>saved_best_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Find a cheaper access key than a given <em>key</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tab</td><td>NULL or <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> of the accessed table </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table if tab == NULL or tab-&gt;table() </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">usable_keys</td><td><a class="el" href="classKey.html">Key</a> map to find a cheaper key in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ref_key</td><td><br />
 0 &lt;= key &lt; MAX_KEY - key number (hint) to start the search -1 - no key number provided </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select_limit</td><td>LIMIT value, or HA_POS_ERROR if no limit </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_key</td><td><a class="el" href="classKey.html">Key</a> number if success, otherwise undefined </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_key_direction</td><td>Return -1 (reverse) or +1 if success, otherwise undefined </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_select_limit</td><td>Return adjusted LIMIT </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_used_key_parts</td><td>NULL by default, otherwise return number of new_key prefix columns if success or undefined if the function fails </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">saved_best_key_parts</td><td>NULL by default, otherwise preserve the value for further use in <a class="el" href="classQUICK__SELECT__DESC.html">QUICK_SELECT_DESC</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function takes into account table-&gt;quick_condition_rows statistic (that is calculated by JOIN::make_join_plan()). However, single table procedures such as mysql_update() and mysql_delete() never call JOIN::make_join_plan(), so they have to update it manually (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Query__Optimizer.html#ga92d8a0c25d038fddac9b92696f6845e3">get_index_for_order()</a>). </dd></dl>

</div>
</div>
<a id="ga96dc524565684a4e258c98f5b7fd1541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96dc524565684a4e258c98f5b7fd1541">&#9670;&nbsp;</a></span>test_if_order_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int test_if_order_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>used_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Test if one can use the key to resolve ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Sort order </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table to sort </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idx</td><td>Index to check </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">used_key_parts</td><td>NULL by default, otherwise return value for used key parts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>used_key_parts is set to correct key parts used if return value != 0 (On other cases, used_key_part may be changed) Note that the value may actually be greater than the number of index key parts. This can happen for storage engines that have the primary key parts as a suffix for every secondary key.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>key is ok. </td></tr>
    <tr><td class="paramname">0</td><td><a class="el" href="classKey.html">Key</a> can't be used </td></tr>
    <tr><td class="paramname">-1</td><td>Reverse key can be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d5a2e1822e2131fcfbe6501a8a97525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d5a2e1822e2131fcfbe6501a8a97525">&#9670;&nbsp;</a></span>test_if_subpart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool test_if_subpart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Return 1 if second is a subpart of first argument.</p>
<p class="">If first parts has different direction, change it to second part (group is sorted like order) </p>

</div>
</div>
<a id="ga410e1c85b186cd5520a7d21930ead6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga410e1c85b186cd5520a7d21930ead6e5">&#9670;&nbsp;</a></span>types_allow_materialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool types_allow_materialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two items are compatible wrt. materialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer</td><td>Expression from outer query </td></tr>
    <tr><td class="paramname">inner</td><td>Expression from inner query</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>If subquery types allow materialization. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeaa6edcfa6c4d934dd42d505d9de2fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa6edcfa6c4d934dd42d505d9de2fef">&#9670;&nbsp;</a></span>update_equalities_for_sjm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool JOIN::update_equalities_for_sjm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Update equalities and keyuse references after semi-join materialization strategy is chosen.</p>
<p class="">For each multiple equality that contains a field that is selected from a subquery, and that subquery is executed using a semi-join materialization strategy, add the corresponding column in the materialized temporary table to the equality. For each injected semi-join equality that is not converted to multiple equality, replace the reference to the expression selected from the subquery with the corresponding column in the temporary table.</p>
<p class="">This is needed to properly reflect the equalities that involve injected semi-join equalities when materialization strategy is chosen. </p><dl class="section see"><dt>See also</dt><dd>eliminate_item_equal() for how these equalities are used to generate correct equality predicates.</dd></dl>
<p>The MaterializeScan semi-join strategy requires some additional processing: All primary tables after the materialized temporary table must be inspected for keyuse objects that point to expressions from the subquery tables. These references must be replaced with references to corresponding columns in the materialized temporary table instead. Those primary tables using ref access will thus be made to depend on the materialized temporary table instead of the subquery tables.</p>
<p class="">Only the injected semi-join equalities need this treatment, other predicates will be handled correctly by the regular item substitution process.</p>
<dl class="section return"><dt>Returns</dt><dd>False if success, true if error </dd></dl>

</div>
</div>
<a id="ga652bf7109dfbe0fdd7deb75c05c0a7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga652bf7109dfbe0fdd7deb75c05c0a7a3">&#9670;&nbsp;</a></span>uses_index_fields_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uses_index_fields_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>tbl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>other_tbls_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if given expression only uses fields covered by index #keyno in the table tbl. The expression can use any fields in any other tables.</p>
<p class="">The expression is guaranteed not to be AND or OR - those constructs are handled outside of this function.</p>
<p class="">Restrict some function types from being pushed down to storage engine: a) Don't push down the triggered conditions. Nested outer joins execution code may need to evaluate a condition several times (both triggered and untriggered). b) Stored functions contain a statement that might start new operations (like DML statements) from within the storage engine. This does not work against all SEs. c) Subqueries might contain nested subqueries and involve more tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Expression to check </td></tr>
    <tr><td class="paramname">tbl</td><td>The table having the index </td></tr>
    <tr><td class="paramname">keyno</td><td>The index number </td></tr>
    <tr><td class="paramname">other_tbls_ok</td><td>TRUE &lt;=&gt; Fields of other non-const tables are allowed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if No, true if Yes </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
