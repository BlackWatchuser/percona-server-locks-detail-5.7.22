<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo <a class="el" href="classList.html">List</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="classAlter__inplace__info.html#a1774915f106804ab1aeb6629d58bcae4">Alter_inplace_info::key_info_buffer</a>  </dt>
<dd>This is mainly due to the fact that we need to keep compatibility with removed handler::add_index() call. We plan to switch to TABLE::key_info numbering later. </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="handler_8cc.html#a24d44ee426ff4454b3e832c4470d6cc7">AUTO_INC_DEFAULT_NB_ROWS</a>  </dt>
<dd>Replace all references to "next number" or NEXT_NUMBER to "auto_increment", everywhere (see below: there is table-&gt;auto_increment_field_not_null, and there also exists table-&gt;next_number_field, it's not consistent). </dd>
<dt><a class="anchor" id="_todo000003"></a>Class <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a>  </dt>
<dd>All the access functions for the flags suggest that the encapsuling is not done correctly, so try to move any logic that requires access to the flags into the cache.  </dd>
<dt><a class="anchor" id="_todo000078"></a>Class <a class="el" href="classCOPY__INFO.html">COPY_INFO</a>  </dt>
<dd>Rename this class. </dd>
<dt><a class="anchor" id="_todo000077"></a>Member <a class="el" href="classCOPY__INFO.html#a7ce8622f7a089c3b7ad02858539899ba">COPY_INFO::set_function_defaults</a>  (<a class="el" href="structTABLE.html">TABLE</a> *table)</dt>
<dd>combine this call to update_generated_write_fields() with the one in fill_record() to avoid updating virtual generated fields twice. blobs_need_not_keep_old_value() is called to unset the m_keep_old_value flag. Allowing this flag to remain might interfere with the way the old BLOB value is handled. When update_generated_write_fields() is removed, blobs_need_not_keep_old_value() can also be removed.  </dd>
<dt><a class="anchor" id="_todo000100"></a>Member <a class="el" href="group__Runtime__Environment.html#gabf07206792036bfb47e5bb8eb0f20bc4">dispatch_command</a>  (THD *thd, const COM_DATA *com_data, enum enum_server_command command)</dt>
<dd><p class="startdd">set thd-&gt;lex-&gt;sql_command to SQLCOM_END here. </p>
<p class="enddd">The following has to be changed to an 8 byte integer </p>
</dd>
<dt><a class="anchor" id="_todo000111"></a>Member <a class="el" href="classEd__connection.html#ad80317ac21aa245c7a0d1162ac98b264">Ed_connection::store_result_set</a>  ()</dt>
<dd>Use double-linked list, when this is really used. </dd>
<dt><a class="anchor" id="_todo000113"></a>Class <a class="el" href="classEd__result__set.html">Ed_result_set</a>  </dt>
<dd>Implement support for result set metadata and automatic type conversion.  </dd>
<dt><a class="anchor" id="_todo000013"></a>Class <a class="el" href="classField__bit__as__char.html">Field_bit_as_char</a>  </dt>
<dd>The inheritance relationship is backwards since <a class="el" href="classField__bit.html">Field_bit</a> is an extended version of <a class="el" href="classField__bit__as__char.html">Field_bit_as_char</a> and not the other way around. Hence, we should refactor it to fix the hierarchy order.  </dd>
<dt><a class="anchor" id="_todo000012"></a>Member <a class="el" href="classField__new__decimal.html#a05d9f15a2a8a5148871c947dfe7a9dbe">Field_new_decimal::store</a>  (double nr)</dt>
<dd>Fix following when double2my_decimal when double2decimal will return E_DEC_TRUNCATED always correctly  </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="classField__num.html#a6497614b428534475736dc71902096fd">Field_num::check_int</a>  (const CHARSET_INFO *cs, const char *str, size_t length, const char *int_end, int error)</dt>
<dd>Make this multi-byte-character safe </dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="classField__str.html#ae0a260a3e657aa6778dcf651ff3e9b95">Field_str::store_decimal</a>  (const <a class="el" href="classmy__decimal.html">my_decimal</a> *)</dt>
<dd>use decimal2string? </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="classField__temporal__with__date__and__time.html#ac497834ddc1ef395a387790d97cfb63d">Field_temporal_with_date_and_time::init_timestamp_flags</a>  ()</dt>
<dd>get rid of TIMESTAMP_FLAG and ON_UPDATE_NOW_FLAG.  </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="classField__time__common.html#ab30cf710ffb3f033da46e5e43430490d">Field_time_common::convert_number_to_TIME</a>  (longlong nr, bool unsigned_val, int nanoseconds, MYSQL_TIME *ltime, int *warning)</dt>
<dd>: convert_number_to_TIME returns conversion status through two different interfaces: return value and warning. It should be refactored to only use return value.  </dd>
<dt><a class="anchor" id="_todo000122"></a>Member <a class="el" href="sys__vars_8cc.html#a995ff555f60375cf17a4408c516c43a2">fix_delay_key_write</a>  (<a class="el" href="classsys__var.html">sys_var</a> *self, THD *thd, enum_var_type type)</dt>
<dd>When updating myisam_delay_key_write, we should do a 'flush tables' of all MyISAM tables to ensure that they are reopen with the new attribute.  </dd>
<dt><a class="anchor" id="_todo000017"></a>File <a class="el" href="gen__lex__hash_8cc.html">gen_lex_hash.cc</a>  </dt>
<dd><p class="startdd">use instead to_upper_lex, special array (substitute chars) without skip codes.. </p>
<p class="enddd">try use reverse order of comparing.. </p>
</dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="handler_8cc.html#ad012444cc24f2178ff92e9e7ecbfbc85">get_canonical_filename</a>  (handler *file, const char *path, char *tmp_path)</dt>
<dd>This may be done more efficiently when table path gets built. Convert this function to something like ASSERT_CANONICAL_FILENAME.  </dd>
<dt><a class="anchor" id="_todo000130"></a>Member <a class="el" href="structGRANT__INFO.html#afb32946497f7754ba60914d9fca5d616">GRANT_INFO::want_privilege</a>  </dt>
<dd>remove this member in 5.8.  </dd>
<dt><a class="anchor" id="_todo000060"></a>Member <a class="el" href="classGtid__set.html#a9a384be7c735d018d5fc0c8c0c64344e">Gtid_set::intersection</a>  (const <a class="el" href="classGtid__set.html">Gtid_set</a> *other, <a class="el" href="classGtid__set.html">Gtid_set</a> *result)</dt>
<dd>: This algorithm is simple, a little bit slower than necessary. It would be more efficient to iterate over intervals of 'this' and 'other' similar to add_gno_interval(). At the moment the performance of this is not super-important. /Sven  </dd>
<dt><a class="anchor" id="_todo000059"></a>Member <a class="el" href="classGtid__table__persistor.html#aeea3284db6daf718fa412a70e4afb889">Gtid_table_persistor::fetch_gtids</a>  (<a class="el" href="classGtid__set.html">Gtid_set</a> *gtid_set)</dt>
<dd>:<ul>
<li>take only global_sid_lock-&gt;rdlock(), and take gtid_state-&gt;sid_lock for each iteration.</li>
<li>Add wrapper around Gtid_set::add_gno_interval and call that instead.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="handler_8cc.html#a4b52399a74d9db4f3421851b46ff6dc9">ha_check_if_supported_system_table</a>  (handlerton *hton, const char *db, const char *table_name)</dt>
<dd>There is another function called is_system_table_name() used by get_table_category(), which is used to set <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> table_category. It checks only a subset of table name like proc, event and time*. We cannot use below function in get_table_category(), as that affects locking mechanism. If we need to unify these functions, we need to fix locking issues generated. </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="handler_8cc.html#a9a81ce45b63a150449fb897a34572bb1">ha_commit_trans</a>  (THD *thd, bool all, bool ignore_global_read_lock)</dt>
<dd>Since we don't support nested statement transactions in 5.0, we can't commit or rollback stmt transactions while we are inside stored functions or triggers. So we simply do nothing now. TODO: This should be fixed in later ( &gt;= 5.1) releases.  </dd>
<dt><a class="anchor" id="_todo000118"></a>Member <a class="el" href="group__Query__Optimizer.html#gae77d58d476f44178e469e2cbe16e9e01">handle_query</a>  (THD *thd, LEX *lex, Query_result *result, ulonglong added_options, ulonglong removed_options)</dt>
<dd>make this function also handle INSERT ... VALUES, single-table UPDATE and DELETE, SET and DO. </dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="structHybrid__type__traits__decimal.html#abacf79142edb4cc12105279b750ac73d">Hybrid_type_traits_decimal::div</a>  (<a class="el" href="structHybrid__type.html">Hybrid_type</a> *val, ulonglong u) const</dt>
<dd>what is '4' for scale?  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classItem.html#a4e68f315ba2a26543339e9f0efed3695">Item::enum_walk</a>  </dt>
<dd><ol type="1">
<li>Move this away from the <a class="el" href="classItem.html">Item</a> class. It is a property of the visitor in what direction the traversal is done, not of the visitee. </li>
</ol>
</dd>
<dt><a class="anchor" id="_todo000026"></a>Member <a class="el" href="classItem.html#a875594d2b9d99ccff3863bfd435828f0">Item::val_bool</a>  ()</dt>
<dd>Make this functions class dependent  </dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="classItem__func__format.html#a9f01cf724eacb711a5874955671fdc67">Item_func_format::val_str_ascii</a>  (String *)</dt>
<dd>This needs to be fixed for multi-byte character set where numbers are stored in more than one byte  </dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="classItem__func__replace.html#a339fa98601454ef99451c1c2daf5d1a4">Item_func_replace::val_str</a>  (String *)</dt>
<dd>Fix that this works with binary strings  </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="classItem__func__xor.html#abf20b3f1b71cb4c4b588c5a04d77ba05">Item_func_xor::val_int</a>  ()</dt>
<dd>(low priority) Change this to be optimized as: <br />
 A XOR B -&gt; (A) == 1 AND (B) &lt;&gt; 1) OR (A &lt;&gt; 1 AND (B) == 1) <br />
 To be able to do this, we would however first have to extend the MySQL range optimizer to handle OR better. </dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="classItem__in__subselect.html#a6f5b5e6374b290d5efd086002d91ff92">Item_in_subselect::row_value_in_to_exists_transformer</a>  (st_select_lex *select)</dt>
<dd>The IF-ELSE below can be refactored so that there is no duplication of the statements that create the new conditions. For this we have to invert the IF and the FOR statements as this: for (each left operand) create the equi-join condition if (is_having_used || !abort_on_null) create the "is null" and is_not_null_test items if (is_having_used) add the equi-join and the null tests to HAVING else add the equi-join and the "is null" to WHERE add the is_not_null_test to HAVING  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="classItem__param.html#aa9b9af6fd0ae3281fc3bbcd2ce6cf741">Item_param::query_val_str</a>  (THD *thd, String *str) const</dt>
<dd><ul>
<li>Change interface and implementation to fill log data in place and avoid one more memcpy/alloc between str and log string.</li>
<li>In case of error we need to notify replication that binary log contains wrong statement  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="classItem__ref.html#a6a78e05b0db89e799f61808c621b808f">Item_ref::fix_fields</a>  (THD *, <a class="el" href="classItem.html">Item</a> **)</dt>
<dd>Here we could first find the field anyway, and then test this condition, so that we can give a better error message - ER_WRONG_FIELD_WITH_GROUP, instead of the less informative ER_BAD_FIELD_ERROR which we produce now. </dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classItem__row.html#a8f0ccfbe35ebded8e8a9b3ba13ff9db3">Item_row::Item_row</a>  (const POS &amp;pos, <a class="el" href="classItem.html">Item</a> *head, <a class="el" href="classList.html">List&lt; Item &gt;</a> &amp;tail)</dt>
<dd>think placing 2-3 component items in item (as it done for function  </dd>
<dt><a class="anchor" id="_todo000036"></a>Member <a class="el" href="classItem__singlerow__subselect.html#ad94e0b9d5a9d2d386405ef76c2bd0c69">Item_singlerow_subselect::select_transformer</a>  (st_select_lex *select)</dt>
<dd><ul>
<li>We cant change name of <a class="el" href="classItem__field.html">Item_field</a> or <a class="el" href="classItem__ref.html">Item_ref</a>, because it will prevent it's correct resolving, but we should save name of removed item =&gt; we do not make optimization if top item of list is field or reference.</li>
<li>switch off this optimization for prepare statement, because we do not rollback this changes. Make rollback for it, or special name resolving mode in 5.0.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="classItem__string.html#a4226f4dfd6a0c9eb1b97c33da0b3db78">Item_string::val_int</a>  ()</dt>
<dd>Give error if we wanted a signed integer and we got an unsigned one  </dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="classItem__sum.html#ae446ff1dc1d0a43af8a3b57861512d58">Item_sum::get_arg_ptr</a>  (uint i)</dt>
<dd>delete this when we no longer support temporary transformations  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="classItem__sum__hybrid.html#ad7d563ebdca9c58beec529763623c3fb">Item_sum_hybrid::min_max_update_decimal_field</a>  ()</dt>
<dd>optimize: do not get result_field in case of args[0] is NULL  </dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="classItem__sum__sum.html#af259b3fb68c269dba5d29d7f1e2323eb">Item_sum_sum::Item_sum_sum</a>  (THD *thd, <a class="el" href="classItem__sum__sum.html">Item_sum_sum</a> *item)</dt>
<dd>check if the following assignments are really needed  </dd>
<dt><a class="anchor" id="_todo000041"></a>File <a class="el" href="item__timefunc_8cc.html">item_timefunc.cc</a>  </dt>
<dd>Move month and days to language files  </dd>
<dt><a class="anchor" id="_todo000080"></a>Member <a class="el" href="group__Query__Executor.html#ga31581f58624b85919d7c6cd632157929">JOIN::exec</a>  ()</dt>
<dd>When can we have here thd-&gt;net.report_error not zero? </dd>
<dt><a class="anchor" id="_todo000095"></a>Member <a class="el" href="group__Query__Optimizer.html#gae9c1cf0874f4bda777557d012148e059">JOIN::get_best_combination</a>  ()</dt>
<dd>the block which sets tab-&gt;type should move to adjust_access_methods for unification.  </dd>
<dt><a class="anchor" id="_todo000119"></a>Member <a class="el" href="group__Query__Optimizer.html#gaa62d47da29f3853e87b1069ee5c1ff21">JOIN::join_free</a>  ()</dt>
<dd>Unlock tables even if the join isn't top level select in the tree  </dd>
<dt><a class="anchor" id="_todo000091"></a>Member <a class="el" href="group__Query__Optimizer.html#ga7f722315c64ce97cff639d705107c660">JOIN::optimize</a>  ()</dt>
<dd>This query block didn't transform itself in SELECT_LEX::prepare(), so belongs to a parent query block. That parent, or its parents, had to transform us - it has not; maybe it is itself in prepare() and evaluating the present query block as an <a class="el" href="classItem__subselect.html">Item_subselect</a>. Such evaluation in prepare() is expected to be a rare case to be eliminated in the future ("SET x=(subq)" is one such case; because it locks tables before prepare()).  </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="handler_8cc.html#a136dfdf479102e63c8ddf02af552c445">key_uses_partial_cols</a>  (<a class="el" href="structTABLE.html">TABLE</a> *table, uint keyno)</dt>
<dd>Allow use of DS-MRR in cases where the index has partially-covered components but they are not used for scanning. </dd>
<dt><a class="anchor" id="_todo000043"></a>File <a class="el" href="lock_8cc.html">lock.cc</a>  </dt>
<dd>Change to use my_malloc() ONLY when using LOCK TABLES command or when we are forced to use mysql_lock_merge.  </dd>
<dt><a class="anchor" id="_todo000044"></a>File <a class="el" href="log_8cc.html">log.cc</a>  </dt>
<dd>Abort logging when we get an error in reading or writing log files  </dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="classLog__event__handler.html#aa9f98b8c0b48eb846877fe9d2496560e">Log_event_handler::log_general</a>  (THD *thd, ulonglong event_utime, const char *user_host, size_t user_host_len, my_thread_id thread_id, const char *command_type, size_t command_type_len, const char *sql_text, size_t sql_text_len, const CHARSET_INFO *client_cs)=0</dt>
<dd>: how?). If a write to the table has failed, the function attempts to write to a short error message to the file. The failure is also indicated in the return value. </dd>
<dt><a class="anchor" id="_todo000006"></a>Member <a class="el" href="group__Binary__Log.html#gaf81ca29b12d9e21eb2d36eee2e7a51fe">MYSQL_BIN_LOG::do_write_cache</a>  (IO_CACHE *cache, class <a class="el" href="classBinlog__event__writer.html">Binlog_event_writer</a> *writer)</dt>
<dd><p class="startdd">: this can happen in case of disk corruption in the IO_CACHE. We may have written a half transaction (even half event) to the binlog. We should rollback the transaction and truncate the binlog. /Sven </p>
<p class="enddd">: this can happen in case of disk corruption in the IO_CACHE. We may have written a half transaction (even half event) to the binlog. We should rollback the transaction and truncate the binlog. /Sven  </p>
</dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="group__Binary__Log.html#gabcd5b380680e537bdec0f093a8f2e3d6">MYSQL_BIN_LOG::generate_name</a>  (const char *log_name, const char *suffix, char *buff)</dt>
<dd>The following should be using fn_format(); We just need to first change fn_format() to cut the file name if it's too long.  </dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="group__Binary__Log.html#ga44de4e3109fc4d50d4968191ab0f3544">MYSQL_BIN_LOG::open_binlog</a>  (const char *opt_name)</dt>
<dd>keep in-memory list of prepared transactions (add to list in log(), remove on unlog()) and copy it to the new binlog if rotated but let's check the behaviour of tc_log_page_waits first!  </dd>
<dt><a class="anchor" id="_todo000121"></a>Member <a class="el" href="sql__trigger_8h.html#a1e3f2ad15ed49c6bd2a89fd4562ee8e5">mysql_create_or_drop_trigger</a>  (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, bool create)</dt>
<dd>TODO: We should check if user has TRIGGER privilege for table here. Now we just require SUPER privilege for creating/dropping because we don't have proper privilege checking for triggers in place yet. </dd>
<dt><a class="anchor" id="_todo000101"></a>Member <a class="el" href="group__Runtime__Environment.html#gac7751d9816645a7a68e879596ee7e558">mysql_execute_command</a>  (THD *thd, bool first_level)</dt>
<dd><ul>
<li>Invalidate the table in the query cache if something changed after unlocking when changes become visible. </li>
</ul>
<p class="enddd">: this is workaround. right way will be move invalidating in the unlock procedure.</p><ul>
<li>TODO: use check_change_password() </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000102"></a>Member <a class="el" href="group__Runtime__Environment.html#gab37db6950d3b6bc16bbbb2ae0484ae55">mysql_reset_thd_for_next_command</a>  (THD *thd)</dt>
<dd><p class="startdd">Remove mysql_reset_thd_for_next_command and only use the member function.</p>
<p class="enddd">Call it after we use THD for queries, not before.  </p>
</dd>
<dt><a class="anchor" id="_todo000058"></a>Member <a class="el" href="classProtocol__text.html#a66166244c73b0d710d2896c411514890">Protocol_text::store</a>  (MYSQL_TIME *time, uint precision)</dt>
<dd>Second_part format ("%06") needs to change when we support 0-6 decimals for time.  </dd>
<dt><a class="anchor" id="_todo000081"></a>Member <a class="el" href="group__Query__Executor.html#gaf6ecbbe7a1950c60e06170bce55ff70e">QEP_TAB::pick_table_access_method</a>  (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab)</dt>
<dd>join_init_read_record/join_read_(last|first) set tab-&gt;read_record.read_record internally. Do the same in other first record reading functions.  </dd>
<dt><a class="anchor" id="_todo000085"></a>Member <a class="el" href="classQEP__TAB.html#a8d6de370a4036642fa57cd2554f8758b">QEP_TAB::QEP_TAB</a>  ()</dt>
<dd>Add constructor to <a class="el" href="structREAD__RECORD.html">READ_RECORD</a>. All users do init_read_record(), which does memset(), rather than invoking a constructor.  </dd>
<dt><a class="anchor" id="_todo000079"></a>Member <a class="el" href="classQuery__result__delete.html#a7e1b51ad966a65afa34e0fc07c5b7a63">Query_result_delete::do_deletes</a>  ()</dt>
<dd>Is there any reason not use the normal nested-loops join? If not, and there is no documentation supporting it, this method and callee should be removed and there should be hooks within normal execution.  </dd>
<dt><a class="anchor" id="_todo000109"></a>Member <a class="el" href="sql__prepare_8cc.html#a230ccb139578f6e2099fcd40a6ca57ad">reinit_stmt_before_use</a>  (THD *thd, LEX *lex)</dt>
<dd>When the new table structure is ready, then have a status bit to indicate the table is altered, and re-do the setup_* and open the tables back. </dd>
<dt><a class="anchor" id="_todo000064"></a>Member <a class="el" href="classRelay__log__info.html#ab4299015e0504c30685b2e3b3e093d27">Relay_log_info::flush_info</a>  (bool force=FALSE)</dt>
<dd>Change the log file information to a binary format to avoid calling longlong2str. </dd>
<dt><a class="anchor" id="_todo000063"></a>Member <a class="el" href="classRelay__log__info.html#aec9eae2f70577d73ee930cd8223f5233">Relay_log_info::init_relay_log_pos</a>  (const char *log, ulonglong pos, bool need_data_lock, const char **errmsg, bool keep_looking_for_fd)</dt>
<dd>check proper initialization of group_master_log_name/group_master_log_pos. /alfranio </dd>
<dt><a class="anchor" id="_todo000061"></a>Member <a class="el" href="classRpl__info.html#a409b8a0921617ffd71e40977be694eef">Rpl_info::internal_id</a>  </dt>
<dd>, This is not anymore required for Master_info and <a class="el" href="classRelay__log__info.html">Relay_log_info</a>, since Channel can be used to uniquely identify this. To preserve backward compatibility, we keep this for Master_info and <a class="el" href="classRelay__log__info.html">Relay_log_info</a>. However, {id, channel} is still required for a worker info.  </dd>
<dt><a class="anchor" id="_todo000056"></a>Member <a class="el" href="classSEL__ARG.html#a35b87fe0aad5b3832782d51cf9e6d79a">SEL_ARG::increment_use_count</a>  (long count)</dt>
<dd>consider refactoring this function to also increase use_count of 'this' instead of incrementing use_count only on later keyparts.  </dd>
<dt><a class="anchor" id="_todo000082"></a>Member <a class="el" href="group__Query__Executor.html#gaea6e7f59b9cca648046cf55fe5a95732">setup_copy_fields</a>  (THD *thd, Temp_table_param *param, Ref_ptr_array ref_pointer_array, <a class="el" href="classList.html">List&lt; Item &gt;</a> &amp;res_selected_fields, <a class="el" href="classList.html">List&lt; Item &gt;</a> &amp;res_all_fields, uint elements, <a class="el" href="classList.html">List&lt; Item &gt;</a> &amp;all_fields)</dt>
<dd>In most cases this result will be sent to the user. This should be changed to use copy_int or copy_real depending on how the value is to be used: In some cases this may be an argument in a group function, like: IF(ISNULL(col),0,COUNT(*)) </dd>
<dt><a class="anchor" id="_todo000069"></a>Member <a class="el" href="classsp__head.html#a1c125eeeef415da5d45fdf16de43ecb7">sp_head::execute_function</a>  (THD *thd, <a class="el" href="classItem.html">Item</a> **args, uint argcount, <a class="el" href="classField.html">Field</a> *return_fld)</dt>
<dd><p class="startdd">We should create <a class="el" href="classsp__rcontext.html">sp_rcontext</a> once per command and reuse it on subsequent executions of a function/trigger.</p>
<p class="enddd">In future we should associate call arena/mem_root with <a class="el" href="classsp__rcontext.html">sp_rcontext</a> and allocate all these objects (and <a class="el" href="classsp__rcontext.html">sp_rcontext</a> itself) on it directly rather than juggle with arenas. </p>
</dd>
<dt><a class="anchor" id="_todo000068"></a>Member <a class="el" href="classsp__head.html#abd450e9d13f6a39c7b7477ba4b12092f">sp_head::execute_trigger</a>  (THD *thd, const LEX_CSTRING &amp;db_name, const LEX_CSTRING &amp;table_name, <a class="el" href="structGRANT__INFO.html" title="The current state of the privilege checking process for the current user, SQL statement and SQL objec...">GRANT_INFO</a> *grant_info)</dt>
<dd><ul>
<li>TODO: we should create <a class="el" href="classsp__rcontext.html">sp_rcontext</a> once per command and reuse it on subsequent executions of a trigger. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000071"></a>Member <a class="el" href="classsp__head.html#afe7c4aad6b9627d1f38b569b39f66419">sp_head::set_security_ctx</a>  (THD *thd, Security_context **save_ctx)</dt>
<dd>Cache if the definer has the rights to use the object on the first usage and reset the cache only if someone does a GRANT statement that 'may' affect this. </dd>
<dt><a class="anchor" id="_todo000073"></a>Class <a class="el" href="classsp__instr__jump.html">sp_instr_jump</a>  </dt>
<dd>later we will consider introducing a new class, which will be the base for <a class="el" href="classsp__instr__jump.html">sp_instr_jump</a>, <a class="el" href="classsp__instr__set__case__expr.html">sp_instr_set_case_expr</a> and <a class="el" href="classsp__instr__jump__case__when.html">sp_instr_jump_case_when</a>. Something like sp_regular_branch_instr (similar to <a class="el" href="classsp__lex__branch__instr.html">sp_lex_branch_instr</a>).  </dd>
<dt><a class="anchor" id="_todo000067"></a>Member <a class="el" href="classsp__parser__data.html#af658fd5aa0ce26b21268b34be0fd2c29">sp_parser_data::new_cont_backpatch</a>  ()</dt>
<dd>These functions should probably be declared in a separate interface class, but currently we try to minimize the <a class="el" href="classsp__instr.html">sp_instr</a> hierarchy. </dd>
<dt><a class="anchor" id="_todo000075"></a>Class <a class="el" href="classSql__cmd__alter__table.html">Sql_cmd_alter_table</a>  </dt>
<dd>move <a class="el" href="classAlter__info.html">Alter_info</a> and other ALTER specific structures from Lex here.  </dd>
<dt><a class="anchor" id="_todo000074"></a>Class <a class="el" href="classSql__cmd__common__alter__table.html">Sql_cmd_common_alter_table</a>  </dt>
<dd>move <a class="el" href="classAlter__info.html">Alter_info</a> and other ALTER generic structures from Lex here.  </dd>
<dt><a class="anchor" id="_todo000047"></a>Member <a class="el" href="structsql__ex__info.html#a90e3b19d97cb512779dd0bf6112d4fd0">sql_ex_info::write_data</a>  (IO_CACHE *file)</dt>
<dd>This is sensitive to field padding. We should write a char[7], not an old_sql_ex. /sven  </dd>
<dt><a class="anchor" id="_todo000127"></a>Member <a class="el" href="classSys__var__keycache.html#a7775f6e9ee55bb58461d6556f053075f">Sys_var_keycache::global_update</a>  (THD *thd, <a class="el" href="classset__var.html">set_var</a> *var)</dt>
<dd>This should be changed so that we wait until the previous assignment is done and then do the new assign  </dd>
<dt><a class="anchor" id="_todo000132"></a>Member <a class="el" href="structTABLE.html#aa76fd5e13a8b5101a247413701978730">TABLE::mem_root</a>  </dt>
<dd>This member should not be declared in-line. That makes it impossible for any function that does memory allocation to take a const reference to a <a class="el" href="structTABLE.html">TABLE</a> object.  </dd>
<dt><a class="anchor" id="_todo000133"></a>Member <a class="el" href="structTABLE__LIST.html#aa8fa2ce873ee6792e4b00bef231936be">TABLE_LIST::any_outer_leaf_table</a>  ()</dt>
<dd>when WL#6570 is implemented, replace with <a class="el" href="structTABLE__LIST.html#a18d48866823fb1e5a562c342bb93c085" title="Return first leaf table of a base table or a view/derived table.">first_leaf_table()</a>  </dd>
<dt><a class="anchor" id="_todo000131"></a>Member <a class="el" href="structTABLE__SHARE.html#ad3a3e3e4c725c1814866341fd65002bf">TABLE_SHARE::get_table_ref_type</a>  () const</dt>
<dd>perhaps we need to have a member instead of a function.  </dd>
<dt><a class="anchor" id="_todo000076"></a>Member <a class="el" href="group__Data__Dictionary.html#ga917237a2e99cef2eb34e64095d79fb1a">tdc_open_view</a>  (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *alias, const char *cache_key, size_t cache_key_length, uint flags)</dt>
<dd>This function is needed for special handling of views under LOCK TABLES. We probably should get rid of it in long term.</dd>
</dl>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
