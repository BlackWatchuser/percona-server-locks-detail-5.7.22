<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Query Executor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Executor</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1cc817dd0c7e9e7ba403b55f4b20a3fb"><td class="memItemLeft" align="right" valign="top"><a id="ga1cc817dd0c7e9e7ba403b55f4b20a3fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prepare_sum_aggregators</b> (<a class="el" href="classItem__sum.html">Item_sum</a> **func_ptr, bool need_distinct)</td></tr>
<tr class="separator:ga1cc817dd0c7e9e7ba403b55f4b20a3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1125b75ed00a408f039bb83de7c480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1b1125b75ed00a408f039bb83de7c480">setup_sum_funcs</a> (THD *thd, <a class="el" href="classItem__sum.html">Item_sum</a> **func_ptr)</td></tr>
<tr class="separator:ga1b1125b75ed00a408f039bb83de7c480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f64c00677c38e6f233e43f47a52aef7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga7f64c00677c38e6f233e43f47a52aef7">copy_funcs</a> (<a class="el" href="classMem__root__array.html">Func_ptr_array</a> *func_ptr, const THD *thd)</td></tr>
<tr class="separator:ga7f64c00677c38e6f233e43f47a52aef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b6b23af4fddf731279c6dfdbd084659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga2b6b23af4fddf731279c6dfdbd084659">setup_tmptable_write_func</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="memdesc:ga2b6b23af4fddf731279c6dfdbd084659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup write_func of <a class="el" href="classQEP__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further.">QEP_tmp_table</a> object.  <a href="#ga2b6b23af4fddf731279c6dfdbd084659">More...</a><br /></td></tr>
<tr class="separator:ga2b6b23af4fddf731279c6dfdbd084659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacddd73f0964f6141ef2666b7ac8a3997"><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gacddd73f0964f6141ef2666b7ac8a3997">sub_select_op</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, bool end_of_records)</td></tr>
<tr class="memdesc:gacddd73f0964f6141ef2666b7ac8a3997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate full or partial join result in operation and send operation's result further.  <a href="#gacddd73f0964f6141ef2666b7ac8a3997">More...</a><br /></td></tr>
<tr class="separator:gacddd73f0964f6141ef2666b7ac8a3997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a751162b6ad6ce37cc4db2c77cc158"><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga09a751162b6ad6ce37cc4db2c77cc158">sub_select</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *const qep_tab, bool end_of_records)</td></tr>
<tr class="separator:ga09a751162b6ad6ce37cc4db2c77cc158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3b77b483fa5b7bcefe0f38587480c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4c3b77b483fa5b7bcefe0f38587480c8">do_sj_dups_weedout</a> (THD *thd, <a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *sjtbl)</td></tr>
<tr class="separator:ga4c3b77b483fa5b7bcefe0f38587480c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb800e0e68d03a1b49a9cf66fda4006"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4fb800e0e68d03a1b49a9cf66fda4006">report_handler_error</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, int error)</td></tr>
<tr class="separator:ga4fb800e0e68d03a1b49a9cf66fda4006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6634e09c549559c5547496bf849a6c0d"><td class="memItemLeft" align="right" valign="top"><a id="ga6634e09c549559c5547496bf849a6c0d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>safe_index_read</b> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:ga6634e09c549559c5547496bf849a6c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c30d89f411ee0d12ecd4824f9aae1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga39c30d89f411ee0d12ecd4824f9aae1a">join_read_const_table</a> (<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *tab, <a class="el" href="structst__position.html">POSITION</a> *pos)</td></tr>
<tr class="separator:ga39c30d89f411ee0d12ecd4824f9aae1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0154a16c989becf374e885b851aaab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga2e0154a16c989becf374e885b851aaab">join_read_key_unlock_row</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:ga2e0154a16c989becf374e885b851aaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf45a16cbecb892a847bb2ac6e92a56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga9cf45a16cbecb892a847bb2ac6e92a56">join_read_last_key</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:ga9cf45a16cbecb892a847bb2ac6e92a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4478c7766644e31523194a220460a9f2"><td class="memItemLeft" align="right" valign="top"><a id="ga4478c7766644e31523194a220460a9f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_prev_same</b> (<a class="el" href="structREAD__RECORD.html">READ_RECORD</a> *info)</td></tr>
<tr class="separator:ga4478c7766644e31523194a220460a9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5bd1e4067c849c724d3d711584fb58"><td class="memItemLeft" align="right" valign="top"><a id="ga0d5bd1e4067c849c724d3d711584fb58"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_init_quick_read_record</b> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:ga0d5bd1e4067c849c724d3d711584fb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga790d98d6f46425c61c7265b7cdf16778"><td class="memItemLeft" align="right" valign="top"><a id="ga790d98d6f46425c61c7265b7cdf16778"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>read_first_record_seq</b> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:ga790d98d6f46425c61c7265b7cdf16778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4a1cc488b1586d28aa8cfd90bb875df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gad4a1cc488b1586d28aa8cfd90bb875df">join_init_read_record</a> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="memdesc:gad4a1cc488b1586d28aa8cfd90bb875df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare table for reading rows and read first record.  <a href="#gad4a1cc488b1586d28aa8cfd90bb875df">More...</a><br /></td></tr>
<tr class="separator:gad4a1cc488b1586d28aa8cfd90bb875df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacfded5a6c9ce5c5bb279b9c993b0abc"><td class="memItemLeft" align="right" valign="top"><a id="gaacfded5a6c9ce5c5bb279b9c993b0abc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_materialize_derived</b> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:gaacfded5a6c9ce5c5bb279b9c993b0abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ca6da89564963ba3ecf8928c6fbe39"><td class="memItemLeft" align="right" valign="top"><a id="ga65ca6da89564963ba3ecf8928c6fbe39"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_materialize_semijoin</b> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:ga65ca6da89564963ba3ecf8928c6fbe39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab44c4ace769049e98d1b391d2918ecb9"><td class="memItemLeft" align="right" valign="top"><a id="gab44c4ace769049e98d1b391d2918ecb9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_first</b> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:gab44c4ace769049e98d1b391d2918ecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0f901c4d15cfc0dc61c7c3dc12cee5"><td class="memItemLeft" align="right" valign="top"><a id="gabd0f901c4d15cfc0dc61c7c3dc12cee5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_last</b> (<a class="el" href="classQEP__TAB.html">QEP_TAB</a> *tab)</td></tr>
<tr class="separator:gabd0f901c4d15cfc0dc61c7c3dc12cee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f237e84d9f550f9b30b62e9cc34a69"><td class="memItemLeft" align="right" valign="top"><a id="gaf3f237e84d9f550f9b30b62e9cc34a69"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_send_group</b> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *qep_tab, bool end_of_records)</td></tr>
<tr class="separator:gaf3f237e84d9f550f9b30b62e9cc34a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa74e832cc92e35fa5e94c664b367dcad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaa74e832cc92e35fa5e94c664b367dcad">group_rec_cmp</a> (<a class="el" href="structst__order.html">ORDER</a> *group, uchar *rec0, uchar *rec1)</td></tr>
<tr class="separator:gaa74e832cc92e35fa5e94c664b367dcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5c3ba6e3e4cec96f452e9d2ca5bf9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gabf5c3ba6e3e4cec96f452e9d2ca5bf9a">table_rec_cmp</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:gabf5c3ba6e3e4cec96f452e9d2ca5bf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161ae3fce537993456b85fe09b4c3d89"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga161ae3fce537993456b85fe09b4c3d89">unique_hash</a> (<a class="el" href="classField.html">Field</a> *field, ulonglong *hash_val)</td></tr>
<tr class="separator:ga161ae3fce537993456b85fe09b4c3d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5b7476da75f3e6068a960995ac3313"><td class="memItemLeft" align="right" valign="top"><a id="ga0d5b7476da75f3e6068a960995ac3313"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>unique_hash_group</b> (<a class="el" href="structst__order.html">ORDER</a> *group)</td></tr>
<tr class="separator:ga0d5b7476da75f3e6068a960995ac3313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93219e97760f167554f60d019f3cb11f"><td class="memItemLeft" align="right" valign="top"><a id="ga93219e97760f167554f60d019f3cb11f"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>unique_hash_fields</b> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ga93219e97760f167554f60d019f3cb11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90a4e0bf6e706b42c25d6649e105bd87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga90a4e0bf6e706b42c25d6649e105bd87">check_unique_constraint</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ga90a4e0bf6e706b42c25d6649e105bd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba03c58c23ec2df563b37709e40ece2"><td class="memItemLeft" align="right" valign="top"><a id="ga0ba03c58c23ec2df563b37709e40ece2"></a>
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_write_group</b> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classQEP__TAB.html">QEP_TAB</a> *const qep_tab, bool end_of_records)</td></tr>
<tr class="separator:ga0ba03c58c23ec2df563b37709e40ece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce1ad15977cc2105276ffca627a3824"><td class="memItemLeft" align="right" valign="top"><a id="ga8ce1ad15977cc2105276ffca627a3824"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_buffer_from_ref</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structst__table__ref.html">TABLE_REF</a> *ref)</td></tr>
<tr class="separator:ga8ce1ad15977cc2105276ffca627a3824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0bd2dbcf106da50227e2eb4932b588d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaa0bd2dbcf106da50227e2eb4932b588d">make_group_fields</a> (<a class="el" href="classJOIN.html">JOIN</a> *main_join, <a class="el" href="classJOIN.html">JOIN</a> *curr_join)</td></tr>
<tr class="separator:gaa0bd2dbcf106da50227e2eb4932b588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108fbed43151ab58878335fbb84503c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga108fbed43151ab58878335fbb84503c1">alloc_group_fields</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *group)</td></tr>
<tr class="separator:ga108fbed43151ab58878335fbb84503c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1389fe70c557f844809a7bd780fc545a"><td class="memItemLeft" align="right" valign="top"><a id="ga1389fe70c557f844809a7bd780fc545a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>test_if_item_cache_changed</b> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCached__item.html">Cached_item</a> &gt; &amp;list)</td></tr>
<tr class="separator:ga1389fe70c557f844809a7bd780fc545a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6e7f59b9cca648046cf55fe5a95732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaea6e7f59b9cca648046cf55fe5a95732">setup_copy_fields</a> (THD *thd, Temp_table_param *param, <a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr class="separator:gaea6e7f59b9cca648046cf55fe5a95732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae2b33e35bb51f5250fac64ee0d231b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga6ae2b33e35bb51f5250fac64ee0d231b">copy_fields</a> (Temp_table_param *param, const THD *thd)</td></tr>
<tr class="separator:ga6ae2b33e35bb51f5250fac64ee0d231b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e985adce1ee0b0c97f2351330ba0b45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1e985adce1ee0b0c97f2351330ba0b45">change_to_use_tmp_fields</a> (THD *thd, <a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr class="separator:ga1e985adce1ee0b0c97f2351330ba0b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27d7837289ad61f55a8649b343d2ffe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gae27d7837289ad61f55a8649b343d2ffe">change_refs_to_tmp_fields</a> (THD *thd, <a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr class="separator:gae27d7837289ad61f55a8649b343d2ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31581f58624b85919d7c6cd632157929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga31581f58624b85919d7c6cd632157929">JOIN::exec</a> ()</td></tr>
<tr class="separator:ga31581f58624b85919d7c6cd632157929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148b2123bee3ebd0718d334e9f109db8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga148b2123bee3ebd0718d334e9f109db8">JOIN::rollup_send_data</a> (uint idx)</td></tr>
<tr class="separator:ga148b2123bee3ebd0718d334e9f109db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c9baf548fef3d59f993a3c13575593"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga15c9baf548fef3d59f993a3c13575593">JOIN::rollup_write_data</a> (uint idx, <a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr class="separator:ga15c9baf548fef3d59f993a3c13575593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8f8266528e6e4f33f31333f5f3cd8a"><td class="memItemLeft" align="right" valign="top">Next_select_func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga8a8f8266528e6e4f33f31333f5f3cd8a">JOIN::get_end_select_func</a> ()</td></tr>
<tr class="separator:ga8a8f8266528e6e4f33f31333f5f3cd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7e9ff5a681a6bcc59e6e1f9af62b76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga0f7e9ff5a681a6bcc59e6e1f9af62b76">QEP_TAB::prepare_scan</a> ()</td></tr>
<tr class="memdesc:ga0f7e9ff5a681a6bcc59e6e1f9af62b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare table to be scanned.  <a href="#ga0f7e9ff5a681a6bcc59e6e1f9af62b76">More...</a><br /></td></tr>
<tr class="separator:ga0f7e9ff5a681a6bcc59e6e1f9af62b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685838679adf501ece418d4bd969f2ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga685838679adf501ece418d4bd969f2ea">QEP_TAB::use_order</a> () const</td></tr>
<tr class="memdesc:ga685838679adf501ece418d4bd969f2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use ordering provided by chosen index?  <a href="#ga685838679adf501ece418d4bd969f2ea">More...</a><br /></td></tr>
<tr class="separator:ga685838679adf501ece418d4bd969f2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ead874e1e879b621085292a1c98fbbc"><td class="memItemLeft" align="right" valign="top"><a id="ga9ead874e1e879b621085292a1c98fbbc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>QEP_TAB::sort_table</b> ()</td></tr>
<tr class="separator:ga9ead874e1e879b621085292a1c98fbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6ecbbe7a1950c60e06170bce55ff70e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaf6ecbbe7a1950c60e06170bce55ff70e">QEP_TAB::pick_table_access_method</a> (const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr class="separator:gaf6ecbbe7a1950c60e06170bce55ff70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69d0ee5d7d438abeff1d7d4c99abd8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gae69d0ee5d7d438abeff1d7d4c99abd8f">QEP_TAB::set_pushed_table_access_method</a> (void)</td></tr>
<tr class="separator:gae69d0ee5d7d438abeff1d7d4c99abd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9c43f5c99dab9d64e8a5723806e47b"><td class="memItemLeft" align="right" valign="top"><a id="gabd9c43f5c99dab9d64e8a5723806e47b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>QEP_TAB::remove_duplicates</b> ()</td></tr>
<tr class="separator:gabd9c43f5c99dab9d64e8a5723806e47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cbaa4a44140f41c161eaab87c25f473"><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1cbaa4a44140f41c161eaab87c25f473">QEP_tmp_table::end_send</a> ()</td></tr>
<tr class="memdesc:ga1cbaa4a44140f41c161eaab87c25f473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish rnd/index scan after accumulating records, switch ref_array, and send accumulated records further.  <a href="#ga1cbaa4a44140f41c161eaab87c25f473">More...</a><br /></td></tr>
<tr class="separator:ga1cbaa4a44140f41c161eaab87c25f473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191937944ea06a62814887a9c104a7d7"><td class="memItemLeft" align="right" valign="top"><a id="ga191937944ea06a62814887a9c104a7d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>QEP_TAB::pfs_batch_update</b> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr class="separator:ga191937944ea06a62814887a9c104a7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga108fbed43151ab58878335fbb84503c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga108fbed43151ab58878335fbb84503c1">&#9670;&nbsp;</a></span>alloc_group_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alloc_group_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Get a list of buffers for saveing last group.</p>
<p class="">Groups are saved in reverse order for easyer check loop. </p>

</div>
</div>
<a id="gae27d7837289ad61f55a8649b343d2ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae27d7837289ad61f55a8649b343d2ffe">&#9670;&nbsp;</a></span>change_refs_to_tmp_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool change_refs_to_tmp_fields </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Change all sum_func refs to fields to point at fields in tmp table. Change all funcs to be fields in tmp table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e985adce1ee0b0c97f2351330ba0b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e985adce1ee0b0c97f2351330ba0b45">&#9670;&nbsp;</a></span>change_to_use_tmp_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool change_to_use_tmp_fields </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Change all funcs and sum_funcs to fields in tmp table, and create new list of all items.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">!=0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90a4e0bf6e706b42c25d6649e105bd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90a4e0bf6e706b42c25d6649e105bd87">&#9670;&nbsp;</a></span>check_unique_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_unique_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check unique_constraint.</p>
<p class="">Calculates record's hash and checks whether the record given in table-&gt;record[0] is already present in the tmp table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> of tmp table to check</td></tr>
  </table>
  </dd>
</dl>
<p>This function assumes record[0] is already filled by the caller. Depending on presence of table-&gt;group, it's or full list of table's fields are used to calculate hash.</p>
<dl class="section return"><dt>Returns</dt><dd>false same record was found true record wasn't found </dd></dl>

</div>
</div>
<a id="ga6ae2b33e35bb51f5250fac64ee0d231b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ae2b33e35bb51f5250fac64ee0d231b">&#9670;&nbsp;</a></span>copy_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool copy_fields </td>
          <td>(</td>
          <td class="paramtype">Temp_table_param *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Make a copy of all simple SELECT'ed items.</p>
<p class="">This is done at the start of a new group so that we can retrieve these later when the group changes. </p><dl class="section return"><dt>Returns</dt><dd>false if OK, true on error. </dd></dl>

</div>
</div>
<a id="ga7f64c00677c38e6f233e43f47a52aef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f64c00677c38e6f233e43f47a52aef7">&#9670;&nbsp;</a></span>copy_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool copy_funcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMem__root__array.html">Func_ptr_array</a> *&#160;</td>
          <td class="paramname"><em>func_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Copy result of functions to record in tmp_table.</p>
<p class="">Uses the thread pointer to check for errors in some of the val_xxx() methods called by the save_in_result_field() function. TODO: make the Item::val_xxx() return error code</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func_ptr</td><td>array of the function Items to copy to the tmp table </td></tr>
    <tr><td class="paramname">thd</td><td>pointer to the current thread for error checking </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>on error <br />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c3b77b483fa5b7bcefe0f38587480c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c3b77b483fa5b7bcefe0f38587480c8">&#9670;&nbsp;</a></span>do_sj_dups_weedout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int do_sj_dups_weedout </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *&#160;</td>
          <td class="paramname"><em>sjtbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">SemiJoinDuplicateElimination: Weed out duplicate row combinations</p>
<p class="">SYNPOSIS <a class="el" href="group__Query__Executor.html#ga4c3b77b483fa5b7bcefe0f38587480c8">do_sj_dups_weedout()</a> thd Thread handle sjtbl Duplicate weedout table</p>
<p class="">DESCRIPTION Try storing current record combination of outer tables (i.e. their rowids) in the temporary table. This records the fact that we've seen this record combination and also tells us if we've seen it before.</p>
<p class="">RETURN -1 Error 1 The row combination is a duplicate (discard it) 0 The row combination is not a duplicate (continue) </p>

</div>
</div>
<a id="ga1cbaa4a44140f41c161eaab87c25f473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cbaa4a44140f41c161eaab87c25f473">&#9670;&nbsp;</a></span>end_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state QEP_tmp_table::end_send </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish rnd/index scan after accumulating records, switch ref_array, and send accumulated records further. </p>
<dl class="section return"><dt>Returns</dt><dd>return one of enum_nested_loop_state. </dd></dl>

<p>Implements <a class="el" href="classQEP__operation.html#a4faf706cddaf3ae613fe92434776df5e">QEP_operation</a>.</p>

</div>
</div>
<a id="ga31581f58624b85919d7c6cd632157929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31581f58624b85919d7c6cd632157929">&#9670;&nbsp;</a></span>exec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void JOIN::exec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Execute select, executor entry point.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000080">Todo:</a></b></dt><dd>When can we have here thd-&gt;net.report_error not zero?</dd></dl>
<dl class="section note"><dt>Note</dt><dd>that EXPLAIN may come here (single-row derived table, uncorrelated scalar subquery in WHERE clause...). </dd></dl>

</div>
</div>
<a id="ga8a8f8266528e6e4f33f31333f5f3cd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8f8266528e6e4f33f31333f5f3cd8a">&#9670;&nbsp;</a></span>get_end_select_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Next_select_func JOIN::get_end_select_func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Rows produced by a join sweep may end up in a temporary table or be sent to a client. Setup the function of the nested loop join algorithm which handles final fully constructed and matched records.</p>
<dl class="section return"><dt>Returns</dt><dd>end_select function to use. This function can't fail. </dd></dl>

</div>
</div>
<a id="gaa74e832cc92e35fa5e94c664b367dcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa74e832cc92e35fa5e94c664b367dcad">&#9670;&nbsp;</a></span>group_rec_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool group_rec_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>rec0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>rec1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Compare GROUP BY in from tmp table's record[0] and record[1]</p>
<dl class="section return"><dt>Returns</dt><dd>true records are different false records are the same </dd></dl>

</div>
</div>
<a id="gad4a1cc488b1586d28aa8cfd90bb875df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4a1cc488b1586d28aa8cfd90bb875df">&#9670;&nbsp;</a></span>join_init_read_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int join_init_read_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare table for reading rows and read first record. </p>
<p class="">Prior to reading the table following tasks are done, (in the order of execution): .) derived tables are materialized .) duplicates removed (tmp tables only) .) table is sorted with filesort (both non-tmp and tmp tables) After this have been done this function resets quick select, if it's present, sets up table reading functions, and reads first record.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Ok </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39c30d89f411ee0d12ecd4824f9aae1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c30d89f411ee0d12ecd4824f9aae1a">&#9670;&nbsp;</a></span>join_read_const_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int join_read_const_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__position.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reads content of constant table </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>table </td></tr>
    <tr><td class="paramname">pos</td><td>position of table in query plan </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok, one row was found or one NULL-complemented row was created </td></tr>
    <tr><td class="paramname">-1</td><td>ok, no row was found and no NULL-complemented row was created </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e0154a16c989becf374e885b851aaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e0154a16c989becf374e885b851aaab">&#9670;&nbsp;</a></span>join_read_key_unlock_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void join_read_key_unlock_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Since join_read_key may buffer a record, do not unlock it if it was not used in this invocation of join_read_key(). Only count locks, thus remembering if the record was left unused, and unlock already when pruning the current value of TABLE_REF buffer. </p><dl class="section see"><dt>See also</dt><dd>join_read_key() </dd></dl>

</div>
</div>
<a id="ga9cf45a16cbecb892a847bb2ac6e92a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cf45a16cbecb892a847bb2ac6e92a56">&#9670;&nbsp;</a></span>join_read_last_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int join_read_last_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used when optimizing away ORDER BY in SELECT * FROM t1 WHERE a=1 ORDER BY a DESC,b DESC. </p>

</div>
</div>
<a id="gaa0bd2dbcf106da50227e2eb4932b588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0bd2dbcf106da50227e2eb4932b588d">&#9670;&nbsp;</a></span>make_group_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool make_group_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>main_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>curr_join</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">allocate group fields or take prepared (cached).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_join</td><td>join of current select </td></tr>
    <tr><td class="paramname">curr_join</td><td>current join (join of current select or temporary copy of it)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6ecbbe7a1950c60e06170bce55ff70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6ecbbe7a1950c60e06170bce55ff70e">&#9670;&nbsp;</a></span>pick_table_access_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_TAB::pick_table_access_method </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Pick the appropriate access method functions</p>
<p class="">Sets the functions for the selected table access method</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_tab</td><td><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> for this <a class="el" href="classQEP__TAB.html">QEP_TAB</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000081">Todo:</a></b></dt><dd>join_init_read_record/join_read_(last|first) set tab-&gt;read_record.read_record internally. Do the same in other first record reading functions. </dd></dl>

</div>
</div>
<a id="ga0f7e9ff5a681a6bcc59e6e1f9af62b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7e9ff5a681a6bcc59e6e1f9af62b76">&#9670;&nbsp;</a></span>prepare_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QEP_TAB::prepare_scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare table to be scanned. </p>
<p class="">This function is the place to do any work on the table that needs to be done before table can be scanned. Currently it only materialized derived tables and semi-joined subqueries and binds buffer for current rowid.</p>
<dl class="section return"><dt>Returns</dt><dd>false - Ok, true - error </dd></dl>

</div>
</div>
<a id="ga4fb800e0e68d03a1b49a9cf66fda4006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb800e0e68d03a1b49a9cf66fda4006">&#9670;&nbsp;</a></span>report_handler_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int report_handler_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Help function when we get some an error from the table handler. </p>

</div>
</div>
<a id="ga148b2123bee3ebd0718d334e9f109db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148b2123bee3ebd0718d334e9f109db8">&#9670;&nbsp;</a></span>rollup_send_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN::rollup_send_data </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Send all rollup levels higher than the current one to the client.</p>
<p class=""><b>SAMPLE</b> </p><div class="fragment"><div class="line">SELECT a, b, c SUM(b) FROM t1 GROUP BY a,b WITH <a class="code" href="structst__rollup.html">ROLLUP</a></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Level we are on:<ul>
<li>0 = Total sum level</li>
<li>1 = First group changed (a)</li>
<li>2 = Second group changed (a,b)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>If send_data_failed() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15c9baf548fef3d59f993a3c13575593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c9baf548fef3d59f993a3c13575593">&#9670;&nbsp;</a></span>rollup_write_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int JOIN::rollup_write_data </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Write all rollup levels higher than the current one to a temp table.</p>
<p class=""><b>SAMPLE</b> </p><div class="fragment"><div class="line">SELECT a, b, SUM(c) FROM t1 GROUP BY a,b WITH <a class="code" href="structst__rollup.html">ROLLUP</a></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Level we are on:<ul>
<li>0 = Total sum level</li>
<li>1 = First group changed (a)</li>
<li>2 = Second group changed (a,b) </li>
</ul>
</td></tr>
    <tr><td class="paramname">table</td><td>reference to temp table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>if write_data_failed() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae69d0ee5d7d438abeff1d7d4c99abd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae69d0ee5d7d438abeff1d7d4c99abd8f">&#9670;&nbsp;</a></span>set_pushed_table_access_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QEP_TAB::set_pushed_table_access_method </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Install the appropriate 'linked' access method functions if this part of the join have been converted to pushed join. </p>
<p class="">Setup modified access function for children of pushed joins.</p>
<p class="">Is child of a pushed join operation: Replace access functions with its linked counterpart. ... Which is effectively a NOOP as the row is already fetched together with the root of the linked operation.</p>

</div>
</div>
<a id="gaea6e7f59b9cca648046cf55fe5a95732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea6e7f59b9cca648046cf55fe5a95732">&#9670;&nbsp;</a></span>setup_copy_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setup_copy_fields </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Temp_table_param *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Setup copy_fields to save fields at start of new group.</p>
<p class="">Setup copy_fields to save fields at start of new group</p>
<p class="">Only FIELD_ITEM:s and FUNC_ITEM:s needs to be saved between groups. Change old item_field to use a new field with points at saved fieldvalue This function is only called before use of send_result_set_metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">param</td><td>temporary table parameters </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000082">Todo:</a></b></dt><dd>In most cases this result will be sent to the user. This should be changed to use copy_int or copy_real depending on how the value is to be used: In some cases this may be an argument in a group function, like: IF(ISNULL(col),0,COUNT(*))</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">!=0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b1125b75ed00a408f039bb83de7c480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1125b75ed00a408f039bb83de7c480">&#9670;&nbsp;</a></span>setup_sum_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setup_sum_funcs </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Call ::setup for all sum functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">func_ptr</td><td>sum function list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>ok </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b6b23af4fddf731279c6dfdbd084659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b6b23af4fddf731279c6dfdbd084659">&#9670;&nbsp;</a></span>setup_tmptable_write_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setup_tmptable_write_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setup write_func of <a class="el" href="classQEP__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further.">QEP_tmp_table</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_tab</td><td><a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> of a tmp table</td></tr>
  </table>
  </dd>
</dl>
<p>Function sets up write_func according to how <a class="el" href="classQEP__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further.">QEP_tmp_table</a> object that is attached to the given join_tab will be used in the query. </p>

</div>
</div>
<a id="ga09a751162b6ad6ce37cc4db2c77cc158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09a751162b6ad6ce37cc4db2c77cc158">&#9670;&nbsp;</a></span>sub_select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state sub_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *const&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Retrieve records ends with a given beginning from the result of a join.</p>
<p class="">SYNPOSIS <a class="el" href="group__Query__Executor.html#ga09a751162b6ad6ce37cc4db2c77cc158">sub_select()</a> join pointer to the structure providing all context info for the query join_tab the first next table of the execution plan to be retrieved end_records true when we need to perform final steps of retrival <br />
 DESCRIPTION For a given partial join record consisting of records from the tables preceding the table join_tab in the execution plan, the function retrieves all matching full records from the result set and send them to the result set stream.</p>
<dl class="section note"><dt>Note</dt><dd>The function effectively implements the final (n-k) nested loops of nested loops join algorithm, where k is the ordinal number of the join_tab table and n is the total number of tables in the join query. It performs nested loops joins with all conjunctive predicates from the where condition pushed as low to the tables as possible. E.g. for the query <div class="fragment"><div class="line">SELECT * FROM t1,t2,t3</div><div class="line">WHERE t1.a=t2.a AND t2.b=t3.b AND t1.a BETWEEN 5 AND 9</div></div><!-- fragment --> the predicate (t1.a BETWEEN 5 AND 9) will be pushed to table t1, given the selected plan prescribes to nest retrievals of the joined tables in the following order: t1,t2,t3. A pushed down predicate are attached to the table which it pushed to, at the field join_tab-&gt;cond. When executing a nested loop of level k the function runs through the rows of 'join_tab' and for each row checks the pushed condition attached to the table. If it is false the function moves to the next row of the table. If the condition is true the function recursively executes (n-k-1) remaining embedded nested loops. The situation becomes more complicated if outer joins are involved in the execution plan. In this case the pushed down predicates can be checked only at certain conditions. Suppose for the query <div class="fragment"><div class="line">SELECT * FROM t1 LEFT <a class="code" href="classJOIN.html">JOIN</a> (t2,t3) ON t3.a=t1.a</div><div class="line">WHERE t1&gt;2 AND (t2.b&gt;5 OR t2.b IS NULL)</div></div><!-- fragment --> the optimizer has chosen a plan with the table order t1,t2,t3. The predicate P1=t1&gt;2 will be pushed down to the table t1, while the predicate P2=(t2.b&gt;5 OR t2.b IS NULL) will be attached to the table t2. But the second predicate can not be unconditionally tested right after a row from t2 has been read. This can be done only after the first row with t3.a=t1.a has been encountered. Thus, the second predicate P2 is supplied with a guarded value that are stored in the field 'found' of the first inner table for the outer join (table t2). When the first row with t3.a=t1.a for the current row of table t1 appears, the value becomes true. For now on the predicate is evaluated immediately after the row of table t2 has been read. When the first row with t3.a=t1.a has been encountered all conditions attached to the inner tables t2,t3 must be evaluated. Only when all of them are true the row is sent to the output stream. If not, the function returns to the lowest nest level that has a false attached condition. The predicates from on expressions are also pushed down. If in the the above example the on expression were (t3.a=t1.a AND t2.a=t1.a), then t1.a=t2.a would be pushed down to table t2, and without any guard. If after the run through all rows of table t2, the first inner table for the outer join operation, it turns out that no matches are found for the current row of t1, then current row from table t1 is complemented by nulls for t2 and t3. Then the pushed down predicates are checked for the composed row almost in the same way as it had been done for the first row with a match. The only difference is the predicates from on expressions are not checked.</dd></dl>
<dl class="section user"><dt></dt><dd><b>IMPLEMENTATION</b> </dd></dl>
<dl class="section user"><dt></dt><dd>The function forms output rows for a current partial join of k tables tables recursively. For each partial join record ending with a certain row from join_tab it calls sub_select that builds all possible matching tails from the result set. To be able check predicates conditionally items of the class <a class="el" href="classItem__func__trig__cond.html">Item_func_trig_cond</a> are employed. An object of this class is constructed from an item of class COND and a pointer to a guarding boolean variable. When the value of the guard variable is true the value of the object is the same as the value of the predicate, otherwise it's just returns true. To carry out a return to a nested loop level of join table t the pointer to t is remembered in the field 'return_tab' of the join structure. Consider the following query: <div class="fragment"><div class="line">SELECT * FROM t1,</div><div class="line">              LEFT <a class="code" href="classJOIN.html">JOIN</a></div><div class="line">              (t2, t3 LEFT <a class="code" href="classJOIN.html">JOIN</a> (t4,t5) ON t5.a=t3.a)</div><div class="line">              ON t4.a=t2.a</div><div class="line">   WHERE (t2.b=5 OR t2.b IS NULL) AND (t4.b=2 OR t4.b IS NULL)</div></div><!-- fragment --> Suppose the chosen execution plan dictates the order t1,t2,t3,t4,t5 and suppose for a given joined rows from tables t1,t2,t3 there are no rows in the result set yet. When first row from t5 that satisfies the on condition t5.a=t3.a is found, the pushed down predicate t4.b=2 OR t4.b IS NULL becomes 'activated', as well the predicate t4.a=t2.a. But the predicate (t2.b=5 OR t2.b IS NULL) can not be checked until t4.a=t2.a becomes true. In order not to re-evaluate the predicates that were already evaluated as attached pushed down predicates, a pointer to the the first most inner unmatched table is maintained in join_tab-&gt;first_unmatched. Thus, when the first row from t5 with t5.a=t3.a is found this pointer for t5 is changed from t4 to t2. <br />
 </dd></dl>
<dl class="section user"><dt></dt><dd><b>STRUCTURE</b> <b>NOTES</b> </dd></dl>
<dl class="section user"><dt></dt><dd>join_tab-&gt;first_unmatched points always backwards to the first inner table of the embedding nested join, if any.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>pointer to the structure providing all context info for the query </td></tr>
    <tr><td class="paramname">join_tab</td><td>the first next table of the execution plan to be retrieved </td></tr>
    <tr><td class="paramname">end_records</td><td>true when we need to perform final steps of retrival <br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return one of enum_nested_loop_state, except NESTED_LOOP_NO_MORE_ROWS. </dd></dl>

</div>
</div>
<a id="gacddd73f0964f6141ef2666b7ac8a3997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacddd73f0964f6141ef2666b7ac8a3997">&#9670;&nbsp;</a></span>sub_select_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state sub_select_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQEP__TAB.html">QEP_TAB</a> *&#160;</td>
          <td class="paramname"><em>qep_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate full or partial join result in operation and send operation's result further. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>pointer to the structure providing all context info for the query </td></tr>
    <tr><td class="paramname">join_tab</td><td>the <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> object to which the operation is attached </td></tr>
    <tr><td class="paramname">end_records</td><td>TRUE &lt;=&gt; all records were accumulated, send them further</td></tr>
  </table>
  </dd>
</dl>
<p>This function accumulates records, one by one, in QEP operation's buffer by calling op-&gt;put_record(). When there is no more records to save, in this case the end_of_records argument == true, function tells QEP operation to send records further by calling op-&gt;send_records(). When all records are sent this function passes 'end_of_records' signal further by calling <a class="el" href="group__Query__Executor.html#ga09a751162b6ad6ce37cc4db2c77cc158">sub_select()</a> with end_of_records argument set to true. After that op-&gt;end_send() is called to tell QEP operation that it could end internal buffer scan.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not expected to be called when dynamic range scan is used to scan join_tab because join cache is disabled for such scan and range scans aren't used for tmp tables. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setup_join_buffering For caches the function implements the algorithmic schema for both Blocked Nested Loop Join and Batched <a class="el" href="classKey.html">Key</a> Access Join. The difference can be seen only at the level of of the implementation of the put_record and send_records virtual methods for the cache object associated with the join_tab.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>return one of enum_nested_loop_state. </dd></dl>

</div>
</div>
<a id="gabf5c3ba6e3e4cec96f452e9d2ca5bf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf5c3ba6e3e4cec96f452e9d2ca5bf9a">&#9670;&nbsp;</a></span>table_rec_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool table_rec_cmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Compare GROUP BY in from tmp table's record[0] and record[1]</p>
<dl class="section return"><dt>Returns</dt><dd>true records are different false records are the same </dd></dl>

</div>
</div>
<a id="ga161ae3fce537993456b85fe09b4c3d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161ae3fce537993456b85fe09b4c3d89">&#9670;&nbsp;</a></span>unique_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong unique_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>hash_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Generate hash for a field</p>
<dl class="section return"><dt>Returns</dt><dd>generated hash </dd></dl>

</div>
</div>
<a id="ga685838679adf501ece418d4bd969f2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685838679adf501ece418d4bd969f2ea">&#9670;&nbsp;</a></span>use_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QEP_TAB::use_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use ordering provided by chosen index? </p>
<p class="">Check if access to this <a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> has to retrieve rows in sorted order as defined by the ordered index used to access this table. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
