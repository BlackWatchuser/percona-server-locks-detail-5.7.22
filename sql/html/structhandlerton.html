<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: handlerton Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structhandlerton-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">handlerton Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac611b993207fb0a7c383b7f183005205"><td class="memItemLeft" align="right" valign="top"><a id="ac611b993207fb0a7c383b7f183005205"></a>
SHOW_COMP_OPTION&#160;</td><td class="memItemRight" valign="bottom"><b>state</b></td></tr>
<tr class="separator:ac611b993207fb0a7c383b7f183005205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6031b196b90687ecfe92de38dc553d3b"><td class="memItemLeft" align="right" valign="top"><a id="a6031b196b90687ecfe92de38dc553d3b"></a>
enum legacy_db_type&#160;</td><td class="memItemRight" valign="bottom"><b>db_type</b></td></tr>
<tr class="separator:a6031b196b90687ecfe92de38dc553d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715538b1a749546dfeedb2cd41b28e30"><td class="memItemLeft" align="right" valign="top"><a id="a715538b1a749546dfeedb2cd41b28e30"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>slot</b></td></tr>
<tr class="separator:a715538b1a749546dfeedb2cd41b28e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55518ff2a6fdf1ad4c03e3aa9d6eae10"><td class="memItemLeft" align="right" valign="top"><a id="a55518ff2a6fdf1ad4c03e3aa9d6eae10"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>savepoint_offset</b></td></tr>
<tr class="separator:a55518ff2a6fdf1ad4c03e3aa9d6eae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37076439ded72f45adb4c952cca1995f"><td class="memItemLeft" align="right" valign="top"><a id="a37076439ded72f45adb4c952cca1995f"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>close_connection</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd)</td></tr>
<tr class="separator:a37076439ded72f45adb4c952cca1995f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0cdabc3302d06ca48d18aea124b24c"><td class="memItemLeft" align="right" valign="top"><a id="a6d0cdabc3302d06ca48d18aea124b24c"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>kill_connection</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd)</td></tr>
<tr class="separator:a6d0cdabc3302d06ca48d18aea124b24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e85cecbc8d7dea66712c5b03e742a"><td class="memItemLeft" align="right" valign="top"><a id="a134e85cecbc8d7dea66712c5b03e742a"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>savepoint_set</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, void *sv)</td></tr>
<tr class="separator:a134e85cecbc8d7dea66712c5b03e742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf0813d3463600e6f1e05b23e552eb3"><td class="memItemLeft" align="right" valign="top"><a id="aeaf0813d3463600e6f1e05b23e552eb3"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>savepoint_rollback</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, void *sv)</td></tr>
<tr class="separator:aeaf0813d3463600e6f1e05b23e552eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79bf3ab67509d85a67f800c26b814b1"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#ac79bf3ab67509d85a67f800c26b814b1">savepoint_rollback_can_release_mdl</a> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd)</td></tr>
<tr class="separator:ac79bf3ab67509d85a67f800c26b814b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdeb7c0c8f51ec3e39174228827e459a"><td class="memItemLeft" align="right" valign="top"><a id="acdeb7c0c8f51ec3e39174228827e459a"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>savepoint_release</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, void *sv)</td></tr>
<tr class="separator:acdeb7c0c8f51ec3e39174228827e459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4097944c1ada6c128a67fc380b70fc"><td class="memItemLeft" align="right" valign="top"><a id="a4f4097944c1ada6c128a67fc380b70fc"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>commit</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, bool all)</td></tr>
<tr class="separator:a4f4097944c1ada6c128a67fc380b70fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d2cbd5510fdeeb3dea0216adadb0f"><td class="memItemLeft" align="right" valign="top"><a id="a095d2cbd5510fdeeb3dea0216adadb0f"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>rollback</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, bool all)</td></tr>
<tr class="separator:a095d2cbd5510fdeeb3dea0216adadb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713bce9fa6b3f60ab7480c318e1b10be"><td class="memItemLeft" align="right" valign="top"><a id="a713bce9fa6b3f60ab7480c318e1b10be"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>prepare</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, bool all)</td></tr>
<tr class="separator:a713bce9fa6b3f60ab7480c318e1b10be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265a16a5fc3084f06606c34ceae822cc"><td class="memItemLeft" align="right" valign="top"><a id="a265a16a5fc3084f06606c34ceae822cc"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>recover</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structxid__t.html">XID</a> *xid_list, uint len)</td></tr>
<tr class="separator:a265a16a5fc3084f06606c34ceae822cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8fe766012c674ebf6d4815b18ac1c7"><td class="memItemLeft" align="right" valign="top"><a id="a7b8fe766012c674ebf6d4815b18ac1c7"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>commit_by_xid</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structxid__t.html">XID</a> *xid)</td></tr>
<tr class="separator:a7b8fe766012c674ebf6d4815b18ac1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea257f4033e04543dd9f9f3af6942b59"><td class="memItemLeft" align="right" valign="top"><a id="aea257f4033e04543dd9f9f3af6942b59"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>rollback_by_xid</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structxid__t.html">XID</a> *xid)</td></tr>
<tr class="separator:aea257f4033e04543dd9f9f3af6942b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4cd3586ca45f8151614433824e0213"><td class="memItemLeft" align="right" valign="top"><a id="a6b4cd3586ca45f8151614433824e0213"></a>
<a class="el" href="classhandler.html">handler</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *table, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:a6b4cd3586ca45f8151614433824e0213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb62f336f4236512338d3caa444483"><td class="memItemLeft" align="right" valign="top"><a id="aa1eb62f336f4236512338d3caa444483"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>drop_database</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, char *path)</td></tr>
<tr class="separator:aa1eb62f336f4236512338d3caa444483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b43bb854d71d7dc763e4476e7b3d4c"><td class="memItemLeft" align="right" valign="top"><a id="a80b43bb854d71d7dc763e4476e7b3d4c"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>panic</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, enum ha_panic_function flag)</td></tr>
<tr class="separator:a80b43bb854d71d7dc763e4476e7b3d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cac38a7793101cb153dc1a7a641787d"><td class="memItemLeft" align="right" valign="top"><a id="a1cac38a7793101cb153dc1a7a641787d"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>start_consistent_snapshot</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd)</td></tr>
<tr class="separator:a1cac38a7793101cb153dc1a7a641787d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904494eefd1f3d9ce520e7d248eeab7d"><td class="memItemLeft" align="right" valign="top"><a id="a904494eefd1f3d9ce520e7d248eeab7d"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>clone_consistent_snapshot</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, THD *from_thd)</td></tr>
<tr class="separator:a904494eefd1f3d9ce520e7d248eeab7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa0802b5a0dcd67a52ac65678d0ed9d"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#acaa0802b5a0dcd67a52ac65678d0ed9d">flush_logs</a> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, bool binlog_group_flush)</td></tr>
<tr class="separator:acaa0802b5a0dcd67a52ac65678d0ed9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9014fc60ffcd62a0566487ca387b4cd"><td class="memItemLeft" align="right" valign="top"><a id="aa9014fc60ffcd62a0566487ca387b4cd"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>store_binlog_info</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd)</td></tr>
<tr class="separator:aa9014fc60ffcd62a0566487ca387b4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfbc51ae3b674c7a9e9daa6b3d48351"><td class="memItemLeft" align="right" valign="top"><a id="a0dfbc51ae3b674c7a9e9daa6b3d48351"></a>
bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>show_status</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, stat_print_fn *print, enum ha_stat_type stat)</td></tr>
<tr class="separator:a0dfbc51ae3b674c7a9e9daa6b3d48351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6a59ed9d5b2babdb6eb23b05f7c852"><td class="memItemLeft" align="right" valign="top"><a id="a9e6a59ed9d5b2babdb6eb23b05f7c852"></a>
uint(*&#160;</td><td class="memItemRight" valign="bottom"><b>partition_flags</b> )()</td></tr>
<tr class="separator:a9e6a59ed9d5b2babdb6eb23b05f7c852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f3570a20fd93e894a5e56404f5472a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#ad5f3570a20fd93e894a5e56404f5472a">get_tablespace</a> )(THD *thd, LEX_CSTRING db_name, LEX_CSTRING table_name, LEX_CSTRING *tablespace_name)</td></tr>
<tr class="separator:ad5f3570a20fd93e894a5e56404f5472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7f69e1c9cf0329f9e5d59f421068a7"><td class="memItemLeft" align="right" valign="top"><a id="a0d7f69e1c9cf0329f9e5d59f421068a7"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>alter_tablespace</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <a class="el" href="classst__alter__tablespace.html">st_alter_tablespace</a> *ts_info)</td></tr>
<tr class="separator:a0d7f69e1c9cf0329f9e5d59f421068a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2c125c83d92c072229f2bf84ef9717"><td class="memItemLeft" align="right" valign="top"><a id="a2c2c125c83d92c072229f2bf84ef9717"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>fill_is_table</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, class <a class="el" href="classItem.html">Item</a> *cond, enum enum_schema_tables)</td></tr>
<tr class="separator:a2c2c125c83d92c072229f2bf84ef9717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f4551856021c65e677824e918aea2"><td class="memItemLeft" align="right" valign="top"><a id="ab80f4551856021c65e677824e918aea2"></a>
my_bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>flush_changed_page_bitmaps</b> )(void)</td></tr>
<tr class="separator:ab80f4551856021c65e677824e918aea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77430f88536897473268d51a81dcac48"><td class="memItemLeft" align="right" valign="top"><a id="a77430f88536897473268d51a81dcac48"></a>
my_bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>purge_changed_page_bitmaps</b> )(ulonglong lsn)</td></tr>
<tr class="separator:a77430f88536897473268d51a81dcac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5efe2d0a29eb581b591e1d12ea09ff4"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#af5efe2d0a29eb581b591e1d12ea09ff4">get_parent_fk_list</a> )(THD *thd, const char *path, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:af5efe2d0a29eb581b591e1d12ea09ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9d1e2a06f1c38c7804003770f1a051"><td class="memItemLeft" align="right" valign="top"><a id="aca9d1e2a06f1c38c7804003770f1a051"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>flags</b></td></tr>
<tr class="separator:aca9d1e2a06f1c38c7804003770f1a051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e96136362baa8195f9f42f10e020e40"><td class="memItemLeft" align="right" valign="top"><a id="a7e96136362baa8195f9f42f10e020e40"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_func</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, enum_binlog_func fn, void *arg)</td></tr>
<tr class="separator:a7e96136362baa8195f9f42f10e020e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786490c92831158695b854b85af12ecd"><td class="memItemLeft" align="right" valign="top"><a id="a786490c92831158695b854b85af12ecd"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>binlog_log_query</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, enum_binlog_command binlog_command, const char *query, uint query_length, const char *db, const char *table_name)</td></tr>
<tr class="separator:a786490c92831158695b854b85af12ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f8cf79ec942e1b9f2fac1d5b40a7d3"><td class="memItemLeft" align="right" valign="top"><a id="ab4f8cf79ec942e1b9f2fac1d5b40a7d3"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>release_temporary_latches</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd)</td></tr>
<tr class="separator:ab4f8cf79ec942e1b9f2fac1d5b40a7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4214f627f24daae358e4bff0c54c5fad"><td class="memItemLeft" align="right" valign="top"><a id="a4214f627f24daae358e4bff0c54c5fad"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>discover</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, const char *db, const char *name, uchar **frmblob, size_t *frmlen)</td></tr>
<tr class="separator:a4214f627f24daae358e4bff0c54c5fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afa76e2414199e1829b6c8cac2b3a13"><td class="memItemLeft" align="right" valign="top"><a id="a0afa76e2414199e1829b6c8cac2b3a13"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>find_files</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, const char *db, const char *path, const char *wild, bool dir, <a class="el" href="classList.html">List</a>&lt; LEX_STRING &gt; *files)</td></tr>
<tr class="separator:a0afa76e2414199e1829b6c8cac2b3a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cfb4acd4e060c0405a6b1c463e9f7f"><td class="memItemLeft" align="right" valign="top"><a id="ac3cfb4acd4e060c0405a6b1c463e9f7f"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>table_exists_in_engine</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, const char *db, const char *name)</td></tr>
<tr class="separator:ac3cfb4acd4e060c0405a6b1c463e9f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5f1ce0077cb1e2a7aa4fc300ad6532"><td class="memItemLeft" align="right" valign="top"><a id="ade5f1ce0077cb1e2a7aa4fc300ad6532"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>make_pushed_join</b> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, const <a class="el" href="classAQP_1_1Join__plan.html">AQP::Join_plan</a> *plan)</td></tr>
<tr class="separator:ade5f1ce0077cb1e2a7aa4fc300ad6532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d533d8e4139d4385e9d2e2171985447"><td class="memItemLeft" align="right" valign="top">const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#a8d533d8e4139d4385e9d2e2171985447">system_database</a> )()</td></tr>
<tr class="separator:a8d533d8e4139d4385e9d2e2171985447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af292121e11f7e92ab52a11751467e9ad"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#af292121e11f7e92ab52a11751467e9ad">is_supported_system_table</a> )(const char *db, const char *table_name, bool is_sql_layer_system_table)</td></tr>
<tr class="separator:af292121e11f7e92ab52a11751467e9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf8fbe7ed06d09cc1480eda20134e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSE__cost__constants.html">SE_cost_constants</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#a6bf8fbe7ed06d09cc1480eda20134e4a">get_cost_constants</a> )(uint storage_category)</td></tr>
<tr class="separator:a6bf8fbe7ed06d09cc1480eda20134e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20defd9e728cbce0952339a471e46231"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#a20defd9e728cbce0952339a471e46231">replace_native_transaction_in_thd</a> )(THD *thd, void *new_trx_arg, void **ptr_trx_arg)</td></tr>
<tr class="separator:a20defd9e728cbce0952339a471e46231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92da74d6b4dcdadf903d113c69136f4"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#af92da74d6b4dcdadf903d113c69136f4">notify_exclusive_mdl</a> )(THD *thd, const <a class="el" href="structMDL__key.html">MDL_key</a> *mdl_key, ha_notification_type notification_type, bool *victimized)</td></tr>
<tr class="separator:af92da74d6b4dcdadf903d113c69136f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c6461574bf87859428478d916ac1e8"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#a57c6461574bf87859428478d916ac1e8">notify_alter_table</a> )(THD *thd, const <a class="el" href="structMDL__key.html">MDL_key</a> *mdl_key, ha_notification_type notification_type)</td></tr>
<tr class="separator:a57c6461574bf87859428478d916ac1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5908a4c597a3ce673a6086debb6510b1"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#a5908a4c597a3ce673a6086debb6510b1">rotate_encryption_master_key</a> )(void)</td></tr>
<tr class="memdesc:a5908a4c597a3ce673a6086debb6510b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate master key rotation.  <a href="#a5908a4c597a3ce673a6086debb6510b1">More...</a><br /></td></tr>
<tr class="separator:a5908a4c597a3ce673a6086debb6510b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0c34713f57e089a2bb432351dcda1e"><td class="memItemLeft" align="right" valign="top">handler_create_zip_dict_result(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#aca0c34713f57e089a2bb432351dcda1e">create_zip_dict</a> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, const char *name, ulong *name_len, const char *data, ulong *data_len)</td></tr>
<tr class="separator:aca0c34713f57e089a2bb432351dcda1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9675ad9031e11e33c6f1578fa62568eb"><td class="memItemLeft" align="right" valign="top">handler_drop_zip_dict_result(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhandlerton.html#a9675ad9031e11e33c6f1578fa62568eb">drop_zip_dict</a> )(<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, const char *name, ulong *name_len)</td></tr>
<tr class="separator:a9675ad9031e11e33c6f1578fa62568eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cfa7bd726fa941576f0976c5db6407"><td class="memItemLeft" align="right" valign="top"><a id="a49cfa7bd726fa941576f0976c5db6407"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>license</b></td></tr>
<tr class="separator:a49cfa7bd726fa941576f0976c5db6407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4532e92564e95ce6c3be6137387509"><td class="memItemLeft" align="right" valign="top"><a id="a0d4532e92564e95ce6c3be6137387509"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:a0d4532e92564e95ce6c3be6137387509"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aca0c34713f57e089a2bb432351dcda1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0c34713f57e089a2bb432351dcda1e">&#9670;&nbsp;</a></span>create_zip_dict</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">handler_create_zip_dict_result(* handlerton::create_zip_dict) (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, const char *name, ulong *name_len, const char *data, ulong *data_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Creates a new compression dictionary with the specified data for this SE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hton</td><td>handletron object. </td></tr>
    <tr><td class="paramname">thd</td><td>thread descriptor. </td></tr>
    <tr><td class="paramname">name</td><td>compression dictionary name </td></tr>
    <tr><td class="paramname">name_len</td><td>compression dictionary name length </td></tr>
    <tr><td class="paramname">data</td><td>compression dictionary data </td></tr>
    <tr><td class="paramname">data_len</td><td>compression dictionary data length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid #handler_create_zip_dict_result value.</dd></dl>
<p>This interface is optional, so not every SE needs to implement it. </p>

</div>
</div>
<a id="a9675ad9031e11e33c6f1578fa62568eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9675ad9031e11e33c6f1578fa62568eb">&#9670;&nbsp;</a></span>drop_zip_dict</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">handler_drop_zip_dict_result(* handlerton::drop_zip_dict) (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, const char *name, ulong *name_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Deletes a compression dictionary for this SE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hton</td><td>handletron object. </td></tr>
    <tr><td class="paramname">thd</td><td>thread descriptor. </td></tr>
    <tr><td class="paramname">name</td><td>compression dictionary name </td></tr>
    <tr><td class="paramname">name_len</td><td>compression dictionary name length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid #handler_drop_zip_dict_result value.</dd></dl>
<p>This interface is optional, so not every SE needs to implement it. </p>

</div>
</div>
<a id="acaa0802b5a0dcd67a52ac65678d0ed9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa0802b5a0dcd67a52ac65678d0ed9d">&#9670;&nbsp;</a></span>flush_logs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handlerton::flush_logs) (<a class="el" href="structhandlerton.html">handlerton</a> *hton, bool binlog_group_flush)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Flush the log(s) of storage engine(s).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hton</td><td>Handlerton of storage engine. </td></tr>
    <tr><td class="paramname">binlog_group_flush</td><td>true if we got invoked by binlog group commit during flush stage, false in other cases. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Succeed </td></tr>
    <tr><td class="paramname">true</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bf8fbe7ed06d09cc1480eda20134e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf8fbe7ed06d09cc1480eda20134e4a">&#9670;&nbsp;</a></span>get_cost_constants</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSE__cost__constants.html">SE_cost_constants</a>*(* handlerton::get_cost_constants) (uint storage_category)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Retrieve cost constants to be used for this storage engine.</p>
<p class="">A storage engine that wants to provide its own cost constants to be used in the optimizer cost model, should implement this function. The server will call this function to get a cost constant object that will be used for tables stored in this storage engine instead of using the default cost constants.</p>
<p class="">Life cycle for the cost constant object: The storage engine must allocate the cost constant object on the heap. After the function returns, the server takes over the ownership of this object. The server will eventually delete the object by calling delete.</p>
<dl class="section note"><dt>Note</dt><dd>In the initial version the storage_category parameter will not be used. The only valid value this will have is DEFAULT_STORAGE_CLASS (see declartion in <a class="el" href="opt__costconstants_8h_source.html">opt_costconstants.h</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage_category</td><td>the storage type that the cost constants will be used for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the cost constant object, if NULL is returned the default cost constants will be used </dd></dl>

</div>
</div>
<a id="af5efe2d0a29eb581b591e1d12ea09ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5efe2d0a29eb581b591e1d12ea09ff4">&#9670;&nbsp;</a></span>get_parent_fk_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* handlerton::get_parent_fk_list) (THD *thd, const char *path, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Get the list of foreign keys referencing a specified table</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle </td></tr>
    <tr><td class="paramname">path</td><td>Path to the table </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code or zero for success </dd></dl>

</div>
</div>
<a id="ad5f3570a20fd93e894a5e56404f5472a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f3570a20fd93e894a5e56404f5472a">&#9670;&nbsp;</a></span>get_tablespace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* handlerton::get_tablespace) (THD *thd, LEX_CSTRING db_name, LEX_CSTRING table_name, LEX_CSTRING *tablespace_name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Get the tablespace name from the SE for the given schema and table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">db_name</td><td>Name of the relevant schema. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_name</td><td>Name of the relevant table. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tablespace_name</td><td>Name of the tablespace containing the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">==</td><td>0 Success. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (handler error code returned). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af292121e11f7e92ab52a11751467e9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af292121e11f7e92ab52a11751467e9ad">&#9670;&nbsp;</a></span>is_supported_system_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handlerton::is_supported_system_table) (const char *db, const char *table_name, bool is_sql_layer_system_table)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if the given db.tablename is a system table for this SE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>Database name to check. </td></tr>
    <tr><td class="paramname">table_name</td><td>table name to check. </td></tr>
    <tr><td class="paramname">is_sql_layer_system_table</td><td>if the supplied db.table_name is a SQL layer system table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>example_is_supported_system_table in ha_example.cc</dd></dl>
<p>is_sql_layer_system_table is supplied to make more efficient checks possible for SEs that support all SQL layer tables.</p>
<p class="">This interface is optional, so every SE need not implement it. </p>

</div>
</div>
<a id="a57c6461574bf87859428478d916ac1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c6461574bf87859428478d916ac1e8">&#9670;&nbsp;</a></span>notify_alter_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handlerton::notify_alter_table) (THD *thd, const <a class="el" href="structMDL__key.html">MDL_key</a> *mdl_key, ha_notification_type notification_type)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Notify/get permission from storage engine before or after execution of ALTER <a class="el" href="structTABLE.html">TABLE</a> operation on the table identified by the MDL key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">mdl_key</td><td>MDL key identifying table which is going to be or was ALTERed. </td></tr>
    <tr><td class="paramname">notification_type</td><td>Indicates whether this is pre-ALTER <a class="el" href="structTABLE.html">TABLE</a> or post-ALTER <a class="el" href="structTABLE.html">TABLE</a> notification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This hook is necessary because for ALTER <a class="el" href="structTABLE.html">TABLE</a> upgrade to X metadata lock happens fairly late during the execution process, so it can be expensive to abort ALTER <a class="el" href="structTABLE.html">TABLE</a> operation at this stage by returning failure from <a class="el" href="structhandlerton.html#af92da74d6b4dcdadf903d113c69136f4">notify_exclusive_mdl()</a> hook.</dd>
<dd>
This hook follows the same error reporting convention as </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structhandlerton.html#af92da74d6b4dcdadf903d113c69136f4">notify_exclusive_mdl()</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Similarly to <a class="el" href="structhandlerton.html#af92da74d6b4dcdadf903d113c69136f4">notify_exclusive_mdl()</a> in some cases post-ALTER notification might happen even if there were no prior pre-ALTER notification.</dd>
<dd>
Post-ALTER notification can happen before post-release notification for exclusive metadata lock acquired by this ALTER <a class="el" href="structTABLE.html">TABLE</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>False - if notification was successful/ALTER <a class="el" href="structTABLE.html">TABLE</a> can proceed. True - if it has failed/ALTER <a class="el" href="structTABLE.html">TABLE</a> should be aborted. </dd></dl>

</div>
</div>
<a id="af92da74d6b4dcdadf903d113c69136f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92da74d6b4dcdadf903d113c69136f4">&#9670;&nbsp;</a></span>notify_exclusive_mdl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handlerton::notify_exclusive_mdl) (THD *thd, const <a class="el" href="structMDL__key.html">MDL_key</a> *mdl_key, ha_notification_type notification_type, bool *victimized)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Notify/get permission from storage engine before acquisition or after release of exclusive metadata lock on object represented by key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">mdl_key</td><td>MDL key identifying object on which exclusive lock is to be acquired/was released. </td></tr>
    <tr><td class="paramname">notification_type</td><td>Indicates whether this is pre-acquire or post-release notification. </td></tr>
    <tr><td class="paramname">victimized</td><td>'true' if locking failed as we were selected as a victim in order to avoid possible deadlocks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Notification is done only for objects from TABLESPACE, SCHEMA, <a class="el" href="structTABLE.html">TABLE</a>, FUNCTION, PROCEDURE, TRIGGER and EVENT namespaces.</dd>
<dd>
Problems during notification are to be reported as warnings, MDL subsystem will report generic error if pre-acquire notification fails/SE refuses lock acquisition. </dd>
<dd>
Return value is ignored/error is not reported in case of post-release notification.</dd>
<dd>
In some cases post-release notification might happen even if there were no prior pre-acquire notification. For example, when SE was loaded after exclusive lock acquisition, or when we need notify SEs which permitted lock acquisition that it didn't happen because one of SEs didn't allow it (in such case we will do post-release notification for all SEs for simplicity).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>False - if notification was successful/lock can be acquired, True - if it has failed/lock should not be acquired. </dd></dl>

</div>
</div>
<a id="a20defd9e728cbce0952339a471e46231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20defd9e728cbce0952339a471e46231">&#9670;&nbsp;</a></span>replace_native_transaction_in_thd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* handlerton::replace_native_transaction_in_thd) (THD *thd, void *new_trx_arg, void **ptr_trx_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thd</td><td>pointer to THD </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_trx_arg</td><td>pointer to replacement transaction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr_trx_arg</td><td>double pointer to being replaced transaction</td></tr>
  </table>
  </dd>
</dl>
<p>Associated with THD engine's native transaction is replaced with <code>new_trx_arg</code>. The old value is returned through a buffer if non-null pointer is provided with <code>ptr_trx_arg</code>. The method is adapted by XA start and XA prepare handlers to handle XA transaction that is logged as two parts by slave applier.</p>
<p class="">This interface concerns engines that are aware of XA transaction. </p>

</div>
</div>
<a id="a5908a4c597a3ce673a6086debb6510b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5908a4c597a3ce673a6086debb6510b1">&#9670;&nbsp;</a></span>rotate_encryption_master_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handlerton::rotate_encryption_master_key) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate master key rotation. </p>
<dl class="section return"><dt>Returns</dt><dd>false on success, true on failure </dd></dl>

</div>
</div>
<a id="ac79bf3ab67509d85a67f800c26b814b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79bf3ab67509d85a67f800c26b814b1">&#9670;&nbsp;</a></span>savepoint_rollback_can_release_mdl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* handlerton::savepoint_rollback_can_release_mdl) (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if storage engine allows to release metadata locks which were acquired after the savepoint if rollback to savepoint is done. </p><dl class="section return"><dt>Returns</dt><dd>true - If it is safe to release MDL locks. false - If it is not. </dd></dl>

</div>
</div>
<a id="a8d533d8e4139d4385e9d2e2171985447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d533d8e4139d4385e9d2e2171985447">&#9670;&nbsp;</a></span>system_database</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(* handlerton::system_database) ()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class=""><a class="el" href="classList.html">List</a> of all system tables specific to the SE. Array element would look like below, { "&lt;database_name&gt;", "&lt;system table name&gt;" }, The last element MUST be, { (const char*)NULL, (const char*)NULL }</p>
<dl class="section see"><dt>See also</dt><dd>ha_example_system_tables in ha_example.cc</dd></dl>
<p>This interface is optional, so every SE need not implement it. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="handler_8h_source.html">handler.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
