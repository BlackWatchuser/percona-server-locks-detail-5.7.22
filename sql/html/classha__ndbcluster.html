<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ha_ndbcluster Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classha__ndbcluster-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ha_ndbcluster Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for ha_ndbcluster:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classha__ndbcluster.png" usemap="#ha_5Fndbcluster_map" alt=""/>
  <map id="ha_5Fndbcluster_map" name="ha_5Fndbcluster_map">
<area href="classhandler.html" alt="handler" shape="rect" coords="0,56,108,80"/>
<area href="classSql__alloc.html" alt="Sql_alloc" shape="rect" coords="0,0,108,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a743f4c09bc748bd6d1fce84520472614"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a743f4c09bc748bd6d1fce84520472614">ha_ndbcluster</a> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *table)</td></tr>
<tr class="separator:a743f4c09bc748bd6d1fce84520472614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0e969376e3f2d0677cd4094ae04b7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a2a0e969376e3f2d0677cd4094ae04b7e">~ha_ndbcluster</a> ()</td></tr>
<tr class="separator:a2a0e969376e3f2d0677cd4094ae04b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1e0e1c8aa3764c955f46b8845b7a1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a5e1e0e1c8aa3764c955f46b8845b7a1a">open</a> (const char *name, int mode, uint test_if_locked)</td></tr>
<tr class="separator:a5e1e0e1c8aa3764c955f46b8845b7a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65e17ed6b647f78ca2a933546a5c353"><td class="memItemLeft" align="right" valign="top"><a id="ac65e17ed6b647f78ca2a933546a5c353"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> (void)</td></tr>
<tr class="separator:ac65e17ed6b647f78ca2a933546a5c353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5921b0992ea58b7698d649fcc7d50c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ac5921b0992ea58b7698d649fcc7d50c1">local_close</a> (THD *thd, bool release_metadata)</td></tr>
<tr class="separator:ac5921b0992ea58b7698d649fcc7d50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadffcd5f17a0b869bea7260425573df6"><td class="memItemLeft" align="right" valign="top"><a id="aadffcd5f17a0b869bea7260425573df6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:aadffcd5f17a0b869bea7260425573df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1499ebf91623f1a275a7c205cd1fa90f"><td class="memItemLeft" align="right" valign="top"><a id="a1499ebf91623f1a275a7c205cd1fa90f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a1499ebf91623f1a275a7c205cd1fa90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0417e2c67e5734e072ea5f2f015d3dc7"><td class="memItemLeft" align="right" valign="top"><a id="a0417e2c67e5734e072ea5f2f015d3dc7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze_index</b> (THD *thd)</td></tr>
<tr class="separator:a0417e2c67e5734e072ea5f2f015d3dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5407251181eef104fdf5e2014f040ce2"><td class="memItemLeft" align="right" valign="top"><a id="a5407251181eef104fdf5e2014f040ce2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>write_row</b> (uchar *buf)</td></tr>
<tr class="separator:a5407251181eef104fdf5e2014f040ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569a9e0da9ec2f5863b15185f401ed0"><td class="memItemLeft" align="right" valign="top"><a id="a7569a9e0da9ec2f5863b15185f401ed0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr class="separator:a7569a9e0da9ec2f5863b15185f401ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cd9427fba75e9340dc3572b1798901"><td class="memItemLeft" align="right" valign="top"><a id="a47cd9427fba75e9340dc3572b1798901"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>delete_row</b> (const uchar *buf)</td></tr>
<tr class="separator:a47cd9427fba75e9340dc3572b1798901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae705539c642116cf2fb1f4e325d74892"><td class="memItemLeft" align="right" valign="top"><a id="ae705539c642116cf2fb1f4e325d74892"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_init</b> (uint index, bool sorted)</td></tr>
<tr class="separator:ae705539c642116cf2fb1f4e325d74892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2a69f18014dc4e424beefb06bd4155"><td class="memItemLeft" align="right" valign="top"><a id="aaa2a69f18014dc4e424beefb06bd4155"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_end</b> ()</td></tr>
<tr class="separator:aaa2a69f18014dc4e424beefb06bd4155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc1fdfefdf8315fca2ebac5ad296e08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a0fc1fdfefdf8315fca2ebac5ad296e08">index_read</a> (uchar *buf, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a0fc1fdfefdf8315fca2ebac5ad296e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865afdc25ee4ca42fafde872e476e0ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a865afdc25ee4ca42fafde872e476e0ff">index_next</a> (uchar *buf)</td></tr>
<tr class="separator:a865afdc25ee4ca42fafde872e476e0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824559f84d7f256052f0394e9276774f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a824559f84d7f256052f0394e9276774f">index_prev</a> (uchar *buf)</td></tr>
<tr class="separator:a824559f84d7f256052f0394e9276774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3598345c3543f684c566f79a61cedc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a1d3598345c3543f684c566f79a61cedc">index_first</a> (uchar *buf)</td></tr>
<tr class="separator:a1d3598345c3543f684c566f79a61cedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6e9347ec700ee952a998fa88ae68b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a6f6e9347ec700ee952a998fa88ae68b2">index_last</a> (uchar *buf)</td></tr>
<tr class="separator:a6f6e9347ec700ee952a998fa88ae68b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ff7d09fb74bbdde730f809d3f14021"><td class="memItemLeft" align="right" valign="top"><a id="a95ff7d09fb74bbdde730f809d3f14021"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_last</b> (uchar *buf, const uchar *key, uint key_len)</td></tr>
<tr class="separator:a95ff7d09fb74bbdde730f809d3f14021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb923144766720049d59f97cd70286fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#acb923144766720049d59f97cd70286fd">rnd_init</a> (bool scan)</td></tr>
<tr class="separator:acb923144766720049d59f97cd70286fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1248b6b7c4b6515a2dafd930d57bcd4b"><td class="memItemLeft" align="right" valign="top"><a id="a1248b6b7c4b6515a2dafd930d57bcd4b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_end</b> ()</td></tr>
<tr class="separator:a1248b6b7c4b6515a2dafd930d57bcd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc93bae43a800cc5ba5057b306136de1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#adc93bae43a800cc5ba5057b306136de1">rnd_next</a> (uchar *buf)</td></tr>
<tr class="separator:adc93bae43a800cc5ba5057b306136de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8980053ce56e386ced321a1ad88d1cc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a8980053ce56e386ced321a1ad88d1cc2">rnd_pos</a> (uchar *buf, uchar *pos)</td></tr>
<tr class="separator:a8980053ce56e386ced321a1ad88d1cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47b8413b29048108a6ee92af729ea46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ae47b8413b29048108a6ee92af729ea46">position</a> (const uchar *record)</td></tr>
<tr class="separator:ae47b8413b29048108a6ee92af729ea46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe58d670113d290892c21acb52f9aa5"><td class="memItemLeft" align="right" valign="top"><a id="a8fe58d670113d290892c21acb52f9aa5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_ref</b> (const uchar *ref1, const uchar *ref2)</td></tr>
<tr class="separator:a8fe58d670113d290892c21acb52f9aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebf9b2b84870f08b62e5e3f5465aae8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a4ebf9b2b84870f08b62e5e3f5465aae8">read_range_first</a> (const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted)</td></tr>
<tr class="memdesc:a4ebf9b2b84870f08b62e5e3f5465aae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges. Store ranges for future calls to read_range_next.  <a href="#a4ebf9b2b84870f08b62e5e3f5465aae8">More...</a><br /></td></tr>
<tr class="separator:a4ebf9b2b84870f08b62e5e3f5465aae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cfd1df9bc17dc77186affe8fdd0718"><td class="memItemLeft" align="right" valign="top"><a id="a99cfd1df9bc17dc77186affe8fdd0718"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>read_range_first_to_buf</b> (const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted, uchar *buf)</td></tr>
<tr class="separator:a99cfd1df9bc17dc77186affe8fdd0718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ca12e4aa287eaf6a50c43219a1c776"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ac4ca12e4aa287eaf6a50c43219a1c776">read_range_next</a> ()</td></tr>
<tr class="memdesc:ac4ca12e4aa287eaf6a50c43219a1c776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#ac4ca12e4aa287eaf6a50c43219a1c776">More...</a><br /></td></tr>
<tr class="separator:ac4ca12e4aa287eaf6a50c43219a1c776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9c67b0e6bdfc66f40e30b0bccecabf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aba9c67b0e6bdfc66f40e30b0bccecabf">multi_range_read_init</a> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint mode, <a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *buf)</td></tr>
<tr class="separator:aba9c67b0e6bdfc66f40e30b0bccecabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ab7aa4c5bedaae4a2edb452da67fc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a63ab7aa4c5bedaae4a2edb452da67fc8">multi_range_read_next</a> (char **range_info)</td></tr>
<tr class="separator:a63ab7aa4c5bedaae4a2edb452da67fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8e0c56a5a9150ece910a132a05e826"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#abc8e0c56a5a9150ece910a132a05e826">multi_range_read_info_const</a> (uint keyno, <a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint *bufsz, uint *flags, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:abc8e0c56a5a9150ece910a132a05e826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af561f07d996700a18cd0eb636a14f32e"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#af561f07d996700a18cd0eb636a14f32e">multi_range_read_info</a> (uint keyno, uint n_ranges, uint keys, uint *bufsz, uint *flags, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:af561f07d996700a18cd0eb636a14f32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a5f675ffb30d67ba91bb1cb9ec9dc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a31a5f675ffb30d67ba91bb1cb9ec9dc8">get_error_message</a> (int error, String *buf)</td></tr>
<tr class="separator:a31a5f675ffb30d67ba91bb1cb9ec9dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31757e2658abd318909a0d190a3795c0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a31757e2658abd318909a0d190a3795c0">records</a> (ha_rows *num_rows)</td></tr>
<tr class="separator:a31757e2658abd318909a0d190a3795c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59555b02c52fc703e99a41d3ee3a04c3"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a59555b02c52fc703e99a41d3ee3a04c3">estimate_rows_upper_bound</a> ()</td></tr>
<tr class="separator:a59555b02c52fc703e99a41d3ee3a04c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bab52bf2367f3b04d5d71b355d9930"><td class="memItemLeft" align="right" valign="top"><a id="a28bab52bf2367f3b04d5d71b355d9930"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>info</b> (uint)</td></tr>
<tr class="separator:a28bab52bf2367f3b04d5d71b355d9930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760735b18201562efec1aa930e70bc07"><td class="memItemLeft" align="right" valign="top"><a id="a760735b18201562efec1aa930e70bc07"></a>
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_key_hash_value</b> (<a class="el" href="classField.html">Field</a> **field_array)</td></tr>
<tr class="separator:a760735b18201562efec1aa930e70bc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b76e2e6595d838981a54951aa3f002"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a55b76e2e6595d838981a54951aa3f002">start_read_removal</a> (void)</td></tr>
<tr class="separator:a55b76e2e6595d838981a54951aa3f002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e58b0a19c7cc7d857a3f00e039ae37"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a81e58b0a19c7cc7d857a3f00e039ae37">end_read_removal</a> (void)</td></tr>
<tr class="separator:a81e58b0a19c7cc7d857a3f00e039ae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c393d6b4b1359047c5cf21298ab562f"><td class="memItemLeft" align="right" valign="top"><a id="a9c393d6b4b1359047c5cf21298ab562f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>extra</b> (enum ha_extra_function operation)</td></tr>
<tr class="separator:a9c393d6b4b1359047c5cf21298ab562f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce8f87aba5f88e2a7b586b0f392870b"><td class="memItemLeft" align="right" valign="top"><a id="a2ce8f87aba5f88e2a7b586b0f392870b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_opt</b> (enum ha_extra_function operation, ulong cache_size)</td></tr>
<tr class="separator:a2ce8f87aba5f88e2a7b586b0f392870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ae34dfc88079bca1c85bfcd718b118"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a72ae34dfc88079bca1c85bfcd718b118">reset</a> ()</td></tr>
<tr class="separator:a72ae34dfc88079bca1c85bfcd718b118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe3a7ba06ff1e775e3715c7aff104bb"><td class="memItemLeft" align="right" valign="top"><a id="aabe3a7ba06ff1e775e3715c7aff104bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>external_lock</b> (THD *thd, int lock_type)</td></tr>
<tr class="separator:aabe3a7ba06ff1e775e3715c7aff104bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecef434c45b2c6c35a584274c5079e4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aecef434c45b2c6c35a584274c5079e4b">unlock_row</a> ()</td></tr>
<tr class="separator:aecef434c45b2c6c35a584274c5079e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f1c0c15ca6a002403699eec20f24e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aa8f1c0c15ca6a002403699eec20f24e6">start_stmt</a> (THD *thd, thr_lock_type lock_type)</td></tr>
<tr class="separator:aa8f1c0c15ca6a002403699eec20f24e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1da5294f30d3fd5b8d06fa3177b78a3"><td class="memItemLeft" align="right" valign="top"><a id="aa1da5294f30d3fd5b8d06fa3177b78a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_create_info</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:aa1da5294f30d3fd5b8d06fa3177b78a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b4b9ed3726be8a4a0887785a5ed530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ab4b4b9ed3726be8a4a0887785a5ed530">print_error</a> (int error, myf errflag)</td></tr>
<tr class="separator:ab4b4b9ed3726be8a4a0887785a5ed530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d160419836ac20e131570a32e1c4a8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a96d160419836ac20e131570a32e1c4a8">table_type</a> () const</td></tr>
<tr class="separator:a96d160419836ac20e131570a32e1c4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5341ce688c24b5885145f821cdf249"><td class="memItemLeft" align="right" valign="top">const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ade5341ce688c24b5885145f821cdf249">bas_ext</a> () const</td></tr>
<tr class="separator:ade5341ce688c24b5885145f821cdf249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dc30c67efa4a7d6d6f3ded9a67b40b"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a99dc30c67efa4a7d6d6f3ded9a67b40b">table_flags</a> (void) const</td></tr>
<tr class="separator:a99dc30c67efa4a7d6d6f3ded9a67b40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129ea7ed14c99a3437beff5fece3e832"><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a129ea7ed14c99a3437beff5fece3e832">index_flags</a> (uint idx, uint part, bool all_parts) const</td></tr>
<tr class="separator:a129ea7ed14c99a3437beff5fece3e832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe1c99749c9718d4e5b5869b6cf281b"><td class="memItemLeft" align="right" valign="top"><a id="adfe1c99749c9718d4e5b5869b6cf281b"></a>
virtual const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keys_to_use_for_scanning</b> ()</td></tr>
<tr class="separator:adfe1c99749c9718d4e5b5869b6cf281b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1a2f928fcc952bbe31d8c496ef0dce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#abf1a2f928fcc952bbe31d8c496ef0dce">primary_key_is_clustered</a> () const</td></tr>
<tr class="separator:abf1a2f928fcc952bbe31d8c496ef0dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e5a379a50e92037eff906a993a8755"><td class="memItemLeft" align="right" valign="top"><a id="a52e5a379a50e92037eff906a993a8755"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_record_length</b> () const</td></tr>
<tr class="separator:a52e5a379a50e92037eff906a993a8755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfa4181a4c99accd9d90ac9318cbb81"><td class="memItemLeft" align="right" valign="top"><a id="a8cfa4181a4c99accd9d90ac9318cbb81"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_keys</b> () const</td></tr>
<tr class="separator:a8cfa4181a4c99accd9d90ac9318cbb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa7b1e989313d552722d03ffb39691a"><td class="memItemLeft" align="right" valign="top"><a id="aeaa7b1e989313d552722d03ffb39691a"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_parts</b> () const</td></tr>
<tr class="separator:aeaa7b1e989313d552722d03ffb39691a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fa888c6e852148bf8cd65ce2d4212f"><td class="memItemLeft" align="right" valign="top"><a id="ad8fa888c6e852148bf8cd65ce2d4212f"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_length</b> () const</td></tr>
<tr class="separator:ad8fa888c6e852148bf8cd65ce2d4212f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657e1db46ad7d987ec0af310925841c4"><td class="memItemLeft" align="right" valign="top"><a id="a657e1db46ad7d987ec0af310925841c4"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_part_length</b> () const</td></tr>
<tr class="separator:a657e1db46ad7d987ec0af310925841c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adf9b7e7b7357f464a01f9a7ed2a1ee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a6adf9b7e7b7357f464a01f9a7ed2a1ee">is_fk_defined_on_table_or_index</a> (uint index)</td></tr>
<tr class="separator:a6adf9b7e7b7357f464a01f9a7ed2a1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e95888bddd2ac2eb6d44d83a7e3335e"><td class="memItemLeft" align="right" valign="top"><a id="a0e95888bddd2ac2eb6d44d83a7e3335e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_child_or_parent_fk_list</b> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list, bool is_child, bool is_parent)</td></tr>
<tr class="separator:a0e95888bddd2ac2eb6d44d83a7e3335e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b97152a2ce0d7e7622de70daae4171b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a3b97152a2ce0d7e7622de70daae4171b">get_foreign_key_list</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a3b97152a2ce0d7e7622de70daae4171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef2926a38b2b39387ad40c55708faa2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a8ef2926a38b2b39387ad40c55708faa2">get_parent_foreign_key_list</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a8ef2926a38b2b39387ad40c55708faa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7caf6187be6a0273e998a263bea2157"><td class="memItemLeft" align="right" valign="top"><a id="aa7caf6187be6a0273e998a263bea2157"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>referenced_by_foreign_key</b> ()</td></tr>
<tr class="separator:aa7caf6187be6a0273e998a263bea2157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853f476afbc916b4fb563465db0ca0da"><td class="memItemLeft" align="right" valign="top"><a id="a853f476afbc916b4fb563465db0ca0da"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>is_child_or_parent_of_fk</b> ()</td></tr>
<tr class="separator:a853f476afbc916b4fb563465db0ca0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe3719d8dd1d5f41467250d632abd3c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a3fe3719d8dd1d5f41467250d632abd3c">can_switch_engines</a> ()</td></tr>
<tr class="separator:a3fe3719d8dd1d5f41467250d632abd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abae855bbb818c6827294eb17549365"><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a8abae855bbb818c6827294eb17549365">get_foreign_key_create_info</a> ()</td></tr>
<tr class="separator:a8abae855bbb818c6827294eb17549365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c897e358e6b37f7d948286163749dd"><td class="memItemLeft" align="right" valign="top"><a id="ab4c897e358e6b37f7d948286163749dd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>free_foreign_key_create_info</b> (char *str)</td></tr>
<tr class="separator:ab4c897e358e6b37f7d948286163749dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5609bf8b91966dacc3610fc7ceffc314"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a5609bf8b91966dacc3610fc7ceffc314">rename_table</a> (const char *from, const char *to)</td></tr>
<tr class="separator:a5609bf8b91966dacc3610fc7ceffc314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d32721908372dc62c490e14a005e03c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a4d32721908372dc62c490e14a005e03c">delete_table</a> (const char *name)</td></tr>
<tr class="separator:a4d32721908372dc62c490e14a005e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74383fcb359c0f2d06acf101bb4d4b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ac74383fcb359c0f2d06acf101bb4d4b0">create</a> (const char *name, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:ac74383fcb359c0f2d06acf101bb4d4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95efd97175c4d0f4e5548473b6759e31"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a95efd97175c4d0f4e5548473b6759e31">is_ignorable_error</a> (int error)</td></tr>
<tr class="memdesc:a95efd97175c4d0f4e5548473b6759e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an error can be ignored or not.  <a href="#a95efd97175c4d0f4e5548473b6759e31">More...</a><br /></td></tr>
<tr class="separator:a95efd97175c4d0f4e5548473b6759e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc14d2819ddbc2d616e11db49d669de"><td class="memItemLeft" align="right" valign="top">THR_LOCK_DATA **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a5bc14d2819ddbc2d616e11db49d669de">store_lock</a> (THD *thd, THR_LOCK_DATA **to, enum thr_lock_type lock_type)</td></tr>
<tr class="separator:a5bc14d2819ddbc2d616e11db49d669de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da805f38ddb97fed20dfe0dcdad3844"><td class="memItemLeft" align="right" valign="top"><a id="a8da805f38ddb97fed20dfe0dcdad3844"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>low_byte_first</b> () const</td></tr>
<tr class="separator:a8da805f38ddb97fed20dfe0dcdad3844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b986024102ca38a90c49145c252cc0e"><td class="memItemLeft" align="right" valign="top"><a id="a9b986024102ca38a90c49145c252cc0e"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> (uint key_number)</td></tr>
<tr class="separator:a9b986024102ca38a90c49145c252cc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21574780af8b6cdc0bbcf8dc5ccb5164"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a21574780af8b6cdc0bbcf8dc5ccb5164">scan_time</a> ()</td></tr>
<tr class="separator:a21574780af8b6cdc0bbcf8dc5ccb5164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba30a6612e51eb9b5bd9a205d90a505"><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#acba30a6612e51eb9b5bd9a205d90a505">records_in_range</a> (uint inx, key_range *min_key, key_range *max_key)</td></tr>
<tr class="separator:acba30a6612e51eb9b5bd9a205d90a505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0f10c9eef4ca971b4af597c4b93c56"><td class="memItemLeft" align="right" valign="top"><a id="a0e0f10c9eef4ca971b4af597c4b93c56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>start_bulk_insert</b> (ha_rows rows)</td></tr>
<tr class="separator:a0e0f10c9eef4ca971b4af597c4b93c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b1458caf3677f93276073e22669aeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a38b1458caf3677f93276073e22669aeb">end_bulk_insert</a> ()</td></tr>
<tr class="separator:a38b1458caf3677f93276073e22669aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa852a48bce2fe6fbbe70b83022d74ed2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aa852a48bce2fe6fbbe70b83022d74ed2">start_bulk_update</a> ()</td></tr>
<tr class="separator:aa852a48bce2fe6fbbe70b83022d74ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cbc7ca67dcd89d07693186f5de7ca5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a89cbc7ca67dcd89d07693186f5de7ca5">bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:a89cbc7ca67dcd89d07693186f5de7ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9f552924c7168373ab0d1c2ba0e049"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a5c9f552924c7168373ab0d1c2ba0e049">exec_bulk_update</a> (uint *dup_key_found)</td></tr>
<tr class="separator:a5c9f552924c7168373ab0d1c2ba0e049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3b80b72e921059f62aed3eda1db911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a3c3b80b72e921059f62aed3eda1db911">end_bulk_update</a> ()</td></tr>
<tr class="separator:a3c3b80b72e921059f62aed3eda1db911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46052fa7fa300d669f28e0302494c532"><td class="memItemLeft" align="right" valign="top"><a id="a46052fa7fa300d669f28e0302494c532"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndb_update_row</b> (const uchar *old_data, uchar *new_data, int is_bulk_update)</td></tr>
<tr class="separator:a46052fa7fa300d669f28e0302494c532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2285b3af9153f052ef6ba0cfc3bacea1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a2285b3af9153f052ef6ba0cfc3bacea1">cond_push</a> (const <a class="el" href="classItem.html">Item</a> *cond)</td></tr>
<tr class="separator:a2285b3af9153f052ef6ba0cfc3bacea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de805435e8251f27ba3394052f6b1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a0de805435e8251f27ba3394052f6b1c7">cond_pop</a> ()</td></tr>
<tr class="separator:a0de805435e8251f27ba3394052f6b1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a74f871433b2534301b2b9ac6aecbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a90a74f871433b2534301b2b9ac6aecbf">maybe_pushable_join</a> (const char *&amp;reason) const</td></tr>
<tr class="separator:a90a74f871433b2534301b2b9ac6aecbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8392198f6ff1b83f32ee480b257566a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a8392198f6ff1b83f32ee480b257566a9">assign_pushed_join</a> (const <a class="el" href="classndb__pushed__join.html">ndb_pushed_join</a> *pushed_join)</td></tr>
<tr class="separator:a8392198f6ff1b83f32ee480b257566a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaba12f45b013e5dc180f40463e802a"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a6aaba12f45b013e5dc180f40463e802a">number_of_pushed_joins</a> () const</td></tr>
<tr class="separator:a6aaba12f45b013e5dc180f40463e802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2a5948eca40262f5d533d7c57ca414"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#abf2a5948eca40262f5d533d7c57ca414">root_of_pushed_join</a> () const</td></tr>
<tr class="separator:abf2a5948eca40262f5d533d7c57ca414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa32fde75fed4ebafffd11b6c5638e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a9faa32fde75fed4ebafffd11b6c5638e">parent_of_pushed_join</a> () const</td></tr>
<tr class="separator:a9faa32fde75fed4ebafffd11b6c5638e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c34f1ba38d98ac501de119c7933dce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aa7c34f1ba38d98ac501de119c7933dce">index_read_pushed</a> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:aa7c34f1ba38d98ac501de119c7933dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c12adc1c87097562760e06689e7ec38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a8c12adc1c87097562760e06689e7ec38">index_next_pushed</a> (uchar *buf)</td></tr>
<tr class="separator:a8c12adc1c87097562760e06689e7ec38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a23eb89230938663a59fcf8fbe908b"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ac3a23eb89230938663a59fcf8fbe908b">table_cache_type</a> ()</td></tr>
<tr class="separator:ac3a23eb89230938663a59fcf8fbe908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6bfdb3d1fe1c2914c6a661fec8159f"><td class="memItemLeft" align="right" valign="top"><a id="a6e6bfdb3d1fe1c2914c6a661fec8159f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndb_err</b> (NdbTransaction *)</td></tr>
<tr class="separator:a6e6bfdb3d1fe1c2914c6a661fec8159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef3e8ffe1d4b952fc59b356d3d5f142"><td class="memItemLeft" align="right" valign="top">my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#abef3e8ffe1d4b952fc59b356d3d5f142">register_query_cache_table</a> (THD *thd, char *table_key, size_t key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)</td></tr>
<tr class="separator:abef3e8ffe1d4b952fc59b356d3d5f142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178fe8e973508932db3d3d6ca3a625a9"><td class="memItemLeft" align="right" valign="top">enum_alter_inplace_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a178fe8e973508932db3d3d6ca3a625a9">check_if_supported_inplace_alter</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a178fe8e973508932db3d3d6ca3a625a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7235ae7ee13ad3a572af0fd5c15291"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a3d7235ae7ee13ad3a572af0fd5c15291">prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a3d7235ae7ee13ad3a572af0fd5c15291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff1e368997d6822e3285080fade11fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a5ff1e368997d6822e3285080fade11fe">inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a5ff1e368997d6822e3285080fade11fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55db4a0efc9c99947b72b4bfc83b8ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#af55db4a0efc9c99947b72b4bfc83b8ad">commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:af55db4a0efc9c99947b72b4bfc83b8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e656837653854c38ee70a7cb46515c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a2e656837653854c38ee70a7cb46515c6">notify_table_changed</a> ()</td></tr>
<tr class="separator:a2e656837653854c38ee70a7cb46515c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a72cfeaceefd05a2f700c138c194770fc inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a72cfeaceefd05a2f700c138c194770fc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unbind_psi</b> ()</td></tr>
<tr class="separator:a72cfeaceefd05a2f700c138c194770fc inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e335a403d8203854bc5b94111992b79 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1e335a403d8203854bc5b94111992b79"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rebind_psi</b> ()</td></tr>
<tr class="separator:a1e335a403d8203854bc5b94111992b79 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cadefb8724982848541e06a394917e8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6cadefb8724982848541e06a394917e8">start_psi_batch_mode</a> ()</td></tr>
<tr class="separator:a6cadefb8724982848541e06a394917e8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a860cb6d6cb731416080acc8f179e0 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab6a860cb6d6cb731416080acc8f179e0">end_psi_batch_mode</a> ()</td></tr>
<tr class="separator:ab6a860cb6d6cb731416080acc8f179e0 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae8f7f7b4f67773b73906143238dc9f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9ae8f7f7b4f67773b73906143238dc9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b> (<a class="el" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share_arg)</td></tr>
<tr class="separator:a9ae8f7f7b4f67773b73906143238dc9f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc340039f5cf37a26e7c3b53685794 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a97fc340039f5cf37a26e7c3b53685794"></a>
virtual <a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> (const char *name, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:a97fc340039f5cf37a26e7c3b53685794 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a> ()</td></tr>
<tr class="separator:ab1ad6edb66592b200a7c7ac0f947dc66 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6facc9d1d0bda98c814660eaa9bad7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b6facc9d1d0bda98c814660eaa9bad7">init_with_fields</a> ()</td></tr>
<tr class="separator:a6b6facc9d1d0bda98c814660eaa9bad7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5e02829386929734724b143391e0a11">ha_open</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const char *name, int mode, int test_if_locked)</td></tr>
<tr class="memdesc:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open database-handler.  <a href="classhandler.html#ab5e02829386929734724b143391e0a11">More...</a><br /></td></tr>
<tr class="separator:ab5e02829386929734724b143391e0a11 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a> (void)</td></tr>
<tr class="separator:ae28824cdff2c1812e282463c908e84c2 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a> (uint idx, bool sorted)</td></tr>
<tr class="separator:a0af23462b249041a0db03c1c7139d76b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a> ()</td></tr>
<tr class="separator:afa6bd01057c6cdd86d2ea2ee4ea65ca3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a> (bool scan)</td></tr>
<tr class="separator:afb5c99736cb400350e007578889b8375 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a> ()</td></tr>
<tr class="separator:ad4d9bf34ac0a004d8c5c32267f20842f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a> (uchar *buf)</td></tr>
<tr class="separator:ad3743f3a48e7be751dbb2691be4c992a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a> (uchar *buf, uchar *pos)</td></tr>
<tr class="separator:abcd8615219b3e692e7d484d2ba6cfa86 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a729d9c9c011527b81287574294887bf3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9be09b8d0b1c03c96eb95f79dd7c9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3fa9be09b8d0b1c03c96eb95f79dd7c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_read_last_map</b> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a3fa9be09b8d0b1c03c96eb95f79dd7c9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a> (uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:ac831321e8d33958db4fd4968de932acf inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a> (uchar *buf)</td></tr>
<tr class="separator:a4c99e96a8350ff577a94529be9387a30 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a> (uchar *buf)</td></tr>
<tr class="separator:abb977dac0435158be227e45e04c8b798 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a> (uchar *buf)</td></tr>
<tr class="separator:abd574a3025588e9b0cd49e0d6908e3b8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a> (uchar *buf)</td></tr>
<tr class="separator:a2a7415f1744039a51ef15e923ef7da1b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a> (uchar *buf, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a3f79360a45d50c6b558feb1c308c4157 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">ha_reset</a> ()</td></tr>
<tr class="memdesc:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check handler usage and reset state of file to after 'open'.  <a href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">More...</a><br /></td></tr>
<tr class="separator:a53d38f167906d8aaa9e560c71e595a42 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ef9b6ab27156116f91bf50b1ac19f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6e1ef9b6ab27156116f91bf50b1ac19f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_or_rnd_end</b> ()</td></tr>
<tr class="separator:a6e1ef9b6ab27156116f91bf50b1ac19f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">Table_flags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b3015577f49008561db1d34ae750e70">ha_table_flags</a> () const</td></tr>
<tr class="separator:a6b3015577f49008561db1d34ae750e70 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a> (THD *thd, int lock_type)</td></tr>
<tr class="separator:a9a99b5f8ae28bc5c374919396f8dcf08 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e651543ba0dbb2257a50dc1cdb5ea9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ad8e651543ba0dbb2257a50dc1cdb5ea9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_write_row</b> (uchar *buf)</td></tr>
<tr class="separator:ad8e651543ba0dbb2257a50dc1cdb5ea9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1f6bb19636dda0f1537fe780b6aca17a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr class="separator:a1f6bb19636dda0f1537fe780b6aca17a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e3b24f5bb5b2a8fa0c45732db8cdd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3f0e3b24f5bb5b2a8fa0c45732db8cdd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_delete_row</b> (const uchar *buf)</td></tr>
<tr class="separator:a3f0e3b24f5bb5b2a8fa0c45732db8cdd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbcbef5b9b8ed0f76d700a29091ad3f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="abfbcbef5b9b8ed0f76d700a29091ad3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_release_auto_increment</b> ()</td></tr>
<tr class="separator:abfbcbef5b9b8ed0f76d700a29091ad3f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234580f9765751ce185182dd1edc3bdb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">check_collation_compatibility</a> ()</td></tr>
<tr class="separator:a234580f9765751ce185182dd1edc3bdb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a8030a4a3928d216599e1c03e9b28c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a79a8030a4a3928d216599e1c03e9b28c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_check_for_upgrade</b> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a79a8030a4a3928d216599e1c03e9b28c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a56545ec9967544c80d5612f8ac9b8e6e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ad28d70543d9566894b5a81d25eca2e8e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a> (ha_rows rows)</td></tr>
<tr class="separator:a3f09a15d46c019a621b0a65bb1ec89d3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a> ()</td></tr>
<tr class="separator:a30f3cbf4a769155c994ed39f76433106 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:a49c8ce82a564b0cbf6340dc9b74a9c23 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a> ()</td></tr>
<tr class="separator:a1fef228137a11565f7d52a60ad802004 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25394328a49d42bb45b3b263009f02c7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25394328a49d42bb45b3b263009f02c7">ha_truncate</a> ()</td></tr>
<tr class="separator:a25394328a49d42bb45b3b263009f02c7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a980a8a7650a41fd9a05a32521826ccd5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a66cc9e4971b8e768c102398da0656a7f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a> (THD *thd)</td></tr>
<tr class="separator:a169d5287bdf480f8cd20f758bb2d9bd1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a> (uint mode)</td></tr>
<tr class="separator:aeeb079b3dc59160ba828ef89b4463921 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a> (uint mode)</td></tr>
<tr class="separator:a36e9c53758728e07eb37cbb65ea3ab50 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f75cf982985d21907140a17521cd6c5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1f75cf982985d21907140a17521cd6c5">ha_discard_or_import_tablespace</a> (my_bool discard)</td></tr>
<tr class="separator:a1f75cf982985d21907140a17521cd6c5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee228a60527e81efd9a49ddfdd4850d inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ee228a60527e81efd9a49ddfdd4850d">ha_rename_table</a> (const char *from, const char *to)</td></tr>
<tr class="separator:a6ee228a60527e81efd9a49ddfdd4850d inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28700a3bf1af24f9a31ebae51bf877db inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28700a3bf1af24f9a31ebae51bf877db">ha_delete_table</a> (const char *name)</td></tr>
<tr class="separator:a28700a3bf1af24f9a31ebae51bf877db inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a> (const char *name)</td></tr>
<tr class="separator:a6bcc37ec84386f5d6cc86448781666cb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af5825a427ba6baac74b13223637f8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a14af5825a427ba6baac74b13223637f8">ha_create</a> (const char *name, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a14af5825a427ba6baac74b13223637f8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722462d7e71059a8ed1f43d0fb28366b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a722462d7e71059a8ed1f43d0fb28366b">ha_create_handler_files</a> (const char *name, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a722462d7e71059a8ed1f43d0fb28366b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c090210fefb7e95d885688f5717028 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ad4c090210fefb7e95d885688f5717028"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_next_insert_id_after_explicit_value</b> (ulonglong nr)</td></tr>
<tr class="separator:ad4c090210fefb7e95d885688f5717028 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d2f9da11425e388640206b4d22241 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a8a7d2f9da11425e388640206b4d22241"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_auto_increment</b> ()</td></tr>
<tr class="separator:a8a7d2f9da11425e388640206b4d22241 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eede0999f8273864faa40c5e181793 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a> (int error)</td></tr>
<tr class="separator:ad5eede0999f8273864faa40c5e181793 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20878b1fb8d31b91dbf53ac963d90f78 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">get_foreign_dup_key</a> (char *child_table_name, uint child_table_name_len, char *child_key_name, uint child_key_name_len)</td></tr>
<tr class="separator:a20878b1fb8d31b91dbf53ac963d90f78 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b117a976fc9423d2337da59f35d128c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a2b117a976fc9423d2337da59f35d128c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>change_table_ptr</b> (<a class="el" href="structTABLE.html">TABLE</a> *table_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:a2b117a976fc9423d2337da59f35d128c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061b519fb16fbff126b0e21530973c2e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">read_time</a> (uint index, uint ranges, ha_rows rows)</td></tr>
<tr class="separator:a061b519fb16fbff126b0e21530973c2e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a> (uint keynr, double <a class="el" href="classhandler.html#ae5b7b96354fd25da35a940e656d91940">records</a>)</td></tr>
<tr class="separator:a4a2ac6b2908a899c0ce230818bb7a993 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9380355a7eea5386ef061f36479258 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e9380355a7eea5386ef061f36479258">table_scan_cost</a> ()</td></tr>
<tr class="separator:a5e9380355a7eea5386ef061f36479258 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5575d58c0acbb1924f7f3d3eb756612a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5575d58c0acbb1924f7f3d3eb756612a">index_scan_cost</a> (uint index, double ranges, double rows)</td></tr>
<tr class="separator:a5575d58c0acbb1924f7f3d3eb756612a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d85fe55a71cc09c642592e771b662 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a196d85fe55a71cc09c642592e771b662">read_cost</a> (uint index, double ranges, double rows)</td></tr>
<tr class="separator:a196d85fe55a71cc09c642592e771b662 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475f7fbe39f6ff0e9da2ac6c3d6c629e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a475f7fbe39f6ff0e9da2ac6c3d6c629e">get_memory_buffer_size</a> () const</td></tr>
<tr class="separator:a475f7fbe39f6ff0e9da2ac6c3d6c629e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171927b3afde9e800755b834bd8d31bd inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a171927b3afde9e800755b834bd8d31bd">table_in_memory_estimate</a> () const</td></tr>
<tr class="separator:a171927b3afde9e800755b834bd8d31bd inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375fdfc86f021f336777324dd5a98a02 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a375fdfc86f021f336777324dd5a98a02">index_in_memory_estimate</a> (uint keyno) const</td></tr>
<tr class="separator:a375fdfc86f021f336777324dd5a98a02 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08686bccb46c2be2cc92ff2f75ab9540 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a08686bccb46c2be2cc92ff2f75ab9540"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_transactions</b> () const</td></tr>
<tr class="separator:a08686bccb46c2be2cc92ff2f75ab9540 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fd434bc44b88f4e47f44f02c877c91 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a27fd434bc44b88f4e47f44f02c877c91"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>extra_rec_buf_length</b> () const</td></tr>
<tr class="separator:a27fd434bc44b88f4e47f44f02c877c91 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37413b5d60b340ffe26a6713b65bab75 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a37413b5d60b340ffe26a6713b65bab75">is_fatal_error</a> (int error)</td></tr>
<tr class="memdesc:a37413b5d60b340ffe26a6713b65bab75 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an error is fatal or not.  <a href="classhandler.html#a37413b5d60b340ffe26a6713b65bab75">More...</a><br /></td></tr>
<tr class="separator:a37413b5d60b340ffe26a6713b65bab75 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe4a9e78c818aa2823c302f0fe65522 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9fe4a9e78c818aa2823c302f0fe65522">ha_records</a> (ha_rows *num_rows)</td></tr>
<tr class="separator:a9fe4a9e78c818aa2823c302f0fe65522 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163a360c0cd4575ae207553b8d5c918d inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual enum row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a163a360c0cd4575ae207553b8d5c918d">get_row_type</a> () const</td></tr>
<tr class="separator:a163a360c0cd4575ae207553b8d5c918d inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">column_bitmaps_signal</a> ()</td></tr>
<tr class="memdesc:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL signal that it changed the column bitmap.  <a href="classhandler.html#a4de97045e5381007565fd2b0da235c07">More...</a><br /></td></tr>
<tr class="separator:a4de97045e5381007565fd2b0da235c07 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf0aed6539181d465676ebc661f2b5 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aacdf0aed6539181d465676ebc661f2b5"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_index</b> (void) const</td></tr>
<tr class="separator:aacdf0aed6539181d465676ebc661f2b5 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17ab5ed40c1eab55ce74ce2465c9bff inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad17ab5ed40c1eab55ce74ce2465c9bff">prepare_index_scan</a> (void)</td></tr>
<tr class="separator:ad17ab5ed40c1eab55ce74ce2465c9bff inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa111c313513f50300e9740aeb3e4cfc4 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa111c313513f50300e9740aeb3e4cfc4">prepare_range_scan</a> (const key_range *start_key, const key_range *end_key)</td></tr>
<tr class="separator:aa111c313513f50300e9740aeb3e4cfc4 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4906703169a1e43358e2d95f0d90e911 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4906703169a1e43358e2d95f0d90e911">prepare_index_key_scan_map</a> (const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a4906703169a1e43358e2d95f0d90e911 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7605ac9185a544f444604f11d61f6722 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7605ac9185a544f444604f11d61f6722">has_gap_locks</a> () const</td></tr>
<tr class="separator:a7605ac9185a544f444604f11d61f6722 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0be0637dfaf4fc4a2dc89334c350ec7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0be0637dfaf4fc4a2dc89334c350ec7">rpl_can_handle_stm_event</a> () const</td></tr>
<tr class="separator:af0be0637dfaf4fc4a2dc89334c350ec7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a> (const key_range *range, enum_range_scan_direction direction)</td></tr>
<tr class="separator:a4b7dfb95a0da2e828ac018aa2b4abe3a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a> (key_range *range)</td></tr>
<tr class="separator:af0ef38e7407e87ba5d1ccde59c3e94bb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767345668267e3c8881fab6e351e6c8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab767345668267e3c8881fab6e351e6c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compare_key_icp</b> (const key_range *range) const</td></tr>
<tr class="separator:ab767345668267e3c8881fab6e351e6c8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac3d9b9796d3bfb18b96a1989d6f516 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeac3d9b9796d3bfb18b96a1989d6f516">compare_key_in_buffer</a> (const uchar *buf) const</td></tr>
<tr class="separator:aeac3d9b9796d3bfb18b96a1989d6f516 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab734678f90b9e7cc6b000047f7c89bb1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab734678f90b9e7cc6b000047f7c89bb1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init</b> ()</td></tr>
<tr class="separator:ab734678f90b9e7cc6b000047f7c89bb1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72693b6e25765a4290f531f578bcf2eb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a72693b6e25765a4290f531f578bcf2eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ft_end</b> ()</td></tr>
<tr class="separator:a72693b6e25765a4290f531f578bcf2eb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109448e09ee2c456b1471b74bb9eb8e6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a109448e09ee2c456b1471b74bb9eb8e6"></a>
virtual FT_INFO *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init_ext</b> (uint flags, uint inx, String *key)</td></tr>
<tr class="separator:a109448e09ee2c456b1471b74bb9eb8e6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceb6075e1b3ad667596b30eea85feb6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9ceb6075e1b3ad667596b30eea85feb6"></a>
virtual FT_INFO *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init_ext_with_hints</b> (uint inx, String *key, <a class="el" href="classFt__hints.html">Ft_hints</a> *hints)</td></tr>
<tr class="separator:a9ceb6075e1b3ad667596b30eea85feb6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c965ae56bcceee3cf63ce0320a5d31b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a0c965ae56bcceee3cf63ce0320a5d31b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_read</b> (uchar *buf)</td></tr>
<tr class="separator:a0c965ae56bcceee3cf63ce0320a5d31b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be2fa5d347252f8a28dce931654b76 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">rnd_pos_by_record</a> (uchar *record)</td></tr>
<tr class="separator:ac2be2fa5d347252f8a28dce931654b76 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50b704d53d715d6b0fd3534c6107d8 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">read_first_row</a> (uchar *buf, uint primary_key)</td></tr>
<tr class="separator:aff50b704d53d715d6b0fd3534c6107d8 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d92f647a4ca5a3b7867fa5538242a6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">was_semi_consistent_read</a> ()</td></tr>
<tr class="separator:a54d92f647a4ca5a3b7867fa5538242a6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e767094bff139a26743e9314df8476 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">try_semi_consistent_read</a> (bool)</td></tr>
<tr class="separator:ab3e767094bff139a26743e9314df8476 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f9bf8ee63f3b8312fdc31be3819ede inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab6f9bf8ee63f3b8312fdc31be3819ede"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_next_insert_id</b> (ulonglong id)</td></tr>
<tr class="separator:ab6f9bf8ee63f3b8312fdc31be3819ede inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b51670b2497f01f19f587a4a969386 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a15b51670b2497f01f19f587a4a969386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>restore_auto_increment</b> (ulonglong <a class="el" href="handler_8cc.html#ae9f796d8fbc7dc812557a17547b8e69e">prev_insert_id</a>)</td></tr>
<tr class="separator:a15b51670b2497f01f19f587a4a969386 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15661ad009adb5b5b616928ba57c1a3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae15661ad009adb5b5b616928ba57c1a3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_create_info_for_frm</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:ae15661ad009adb5b5b616928ba57c1a3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc92ca74cd6aca9a6070a186ced4cb inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1abc92ca74cd6aca9a6070a186ced4cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_old_types</b> ()</td></tr>
<tr class="separator:a1abc92ca74cd6aca9a6070a186ced4cb inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b5fa7360fc536082f495ee7e09bcba inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab1b5fa7360fc536082f495ee7e09bcba"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>assign_to_keycache</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ab1b5fa7360fc536082f495ee7e09bcba inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061ab331631179647ccdbd71960ba37 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a0061ab331631179647ccdbd71960ba37"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>preload_keys</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a0061ab331631179647ccdbd71960ba37 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc45e93a1b669fa750f73a617c46bac inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a8bc45e93a1b669fa750f73a617c46bac"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>indexes_are_disabled</b> (void)</td></tr>
<tr class="separator:a8bc45e93a1b669fa750f73a617c46bac inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441afeebcb5b56e598fb7f860c9247d1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a441afeebcb5b56e598fb7f860c9247d1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>append_create_info</b> (String *packet)</td></tr>
<tr class="separator:a441afeebcb5b56e598fb7f860c9247d1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683eef70b4481c3bc0b10336e179de27 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a683eef70b4481c3bc0b10336e179de27">get_cascade_foreign_key_table_list</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__handler__tablename.html">st_handler_tablename</a> &gt; *fk_table_list)</td></tr>
<tr class="separator:a683eef70b4481c3bc0b10336e179de27 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dfb73f9401996a25b9cf925db74149 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a28dfb73f9401996a25b9cf925db74149"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init_table_handle_for_HANDLER</b> ()</td></tr>
<tr class="separator:a28dfb73f9401996a25b9cf925db74149 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9c5a03956913d75de1fca3af7833a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a7ee9c5a03956913d75de1fca3af7833a"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_record_length</b> () const</td></tr>
<tr class="separator:a7ee9c5a03956913d75de1fca3af7833a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c1ac62569e6cc89cbfde66fea47f3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a493c1ac62569e6cc89cbfde66fea47f3"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_keys</b> () const</td></tr>
<tr class="separator:a493c1ac62569e6cc89cbfde66fea47f3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adabba96b635533f31d5e38e6d2a74c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1adabba96b635533f31d5e38e6d2a74c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_parts</b> () const</td></tr>
<tr class="separator:a1adabba96b635533f31d5e38e6d2a74c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b1d6fe7e717fe234c18915cb26e87 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9e1b1d6fe7e717fe234c18915cb26e87"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_length</b> () const</td></tr>
<tr class="separator:a9e1b1d6fe7e717fe234c18915cb26e87 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa0c2a89e52a27667973c1d5074dca7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a4fa0c2a89e52a27667973c1d5074dca7"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_part_length</b> () const</td></tr>
<tr class="separator:a4fa0c2a89e52a27667973c1d5074dca7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082d2a49764e8548b8104dc514877b3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab082d2a49764e8548b8104dc514877b3"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_record_length</b> (uint options) const</td></tr>
<tr class="separator:ab082d2a49764e8548b8104dc514877b3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00ca688822b5d3c9db5ce5d6a982b44 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ad00ca688822b5d3c9db5ce5d6a982b44"></a>
virtual ha_checksum&#160;</td><td class="memItemRight" valign="bottom"><b>checksum</b> () const</td></tr>
<tr class="separator:ad00ca688822b5d3c9db5ce5d6a982b44 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea4b726707284210cc365ad454add03 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6ea4b726707284210cc365ad454add03"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_crashed</b> () const</td></tr>
<tr class="separator:a6ea4b726707284210cc365ad454add03 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08387779d587f8d3ea84b965ddc391 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aca08387779d587f8d3ea84b965ddc391"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>auto_repair</b> () const</td></tr>
<tr class="separator:aca08387779d587f8d3ea84b965ddc391 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272b467ea09dc8f1f10389d7238628c1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a272b467ea09dc8f1f10389d7238628c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_global_table_stats</b> ()</td></tr>
<tr class="separator:a272b467ea09dc8f1f10389d7238628c1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44b5d08ef9b62044cf44f0e6674806a inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ad44b5d08ef9b62044cf44f0e6674806a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_global_index_stats</b> ()</td></tr>
<tr class="separator:ad44b5d08ef9b62044cf44f0e6674806a inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c19b28238d94f029351ecaee0aba007 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1c19b28238d94f029351ecaee0aba007"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_index_stats</b> (uint current_index)</td></tr>
<tr class="separator:a1c19b28238d94f029351ecaee0aba007 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2447668275a831bcf73b5c00818254a6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count</a> (void) const</td></tr>
<tr class="separator:a2447668275a831bcf73b5c00818254a6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb554282443af443fc8aae4533e1407 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">idx_cond_push</a> (uint keyno, <a class="el" href="classItem.html">Item</a> *idx_cond)</td></tr>
<tr class="separator:a0bb554282443af443fc8aae4533e1407 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a> ()</td></tr>
<tr class="separator:a41cc6ba204aa4d1bacc35d9d1d75ab15 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d800c8dafbc9efde9af932305529e4 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">check_if_incompatible_data</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, uint table_changes)</td></tr>
<tr class="separator:a36d800c8dafbc9efde9af932305529e4 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecf7f9bf265e6801b625768f0f2bbe inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad0ecf7f9bf265e6801b625768f0f2bbe">ha_prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:ad0ecf7f9bf265e6801b625768f0f2bbe inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b182710a133be9561afc149cb6aa8f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">ha_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a96b182710a133be9561afc149cb6aa8f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec170a4aa71186f9dc17358b55587c7 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ec170a4aa71186f9dc17358b55587c7">ha_commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:a6ec170a4aa71186f9dc17358b55587c7 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81b74b0b7b87de4f99ebe20c49dc44 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">ha_notify_table_changed</a> ()</td></tr>
<tr class="separator:a5b81b74b0b7b87de4f99ebe20c49dc44 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd590a8a08e54f45fbbc250825764d1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="acfd590a8a08e54f45fbbc250825764d1"></a>
MY_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acfd590a8a08e54f45fbbc250825764d1">ha_fast_update</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;update_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;update_values, <a class="el" href="classItem.html">Item</a> *conds)</td></tr>
<tr class="memdesc:acfd590a8a08e54f45fbbc250825764d1 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offload an update to the storage engine. See handler::fast_update() for details. <br /></td></tr>
<tr class="separator:acfd590a8a08e54f45fbbc250825764d1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c0b213c30476cce68a11c0f00bb9c3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a84c0b213c30476cce68a11c0f00bb9c3"></a>
MY_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a84c0b213c30476cce68a11c0f00bb9c3">ha_upsert</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;update_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;update_values)</td></tr>
<tr class="memdesc:a84c0b213c30476cce68a11c0f00bb9c3 inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offload an upsert to the storage engine. See handler::upsert() for details. <br /></td></tr>
<tr class="separator:a84c0b213c30476cce68a11c0f00bb9c3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a> ()</td></tr>
<tr class="memdesc:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key  <a href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">More...</a><br /></td></tr>
<tr class="separator:adac21f2d10c4463fb1d7e14882c6314f inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24fcaab09a75e81702c2e2c34fa0b62 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">delete_all_rows</a> ()</td></tr>
<tr class="separator:ac24fcaab09a75e81702c2e2c34fa0b62 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fdf15d81c256d3e6a9643532ff2126 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">truncate</a> ()</td></tr>
<tr class="separator:a13fdf15d81c256d3e6a9643532ff2126 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1378edb4813d141f666ce2b9382a4 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ac9c1378edb4813d141f666ce2b9382a4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_and_repair</b> (THD *thd)</td></tr>
<tr class="separator:ac9c1378edb4813d141f666ce2b9382a4 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272e3a0622ad461a5a86c74ddb9289c6 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a272e3a0622ad461a5a86c74ddb9289c6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>disable_indexes</b> (uint mode)</td></tr>
<tr class="separator:a272e3a0622ad461a5a86c74ddb9289c6 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22328b49eac2417561360bd00bbe8299 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a22328b49eac2417561360bd00bbe8299"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>enable_indexes</b> (uint mode)</td></tr>
<tr class="separator:a22328b49eac2417561360bd00bbe8299 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561768da16278d66deec08261111dbef inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a561768da16278d66deec08261111dbef"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>discard_or_import_tablespace</b> (my_bool discard)</td></tr>
<tr class="separator:a561768da16278d66deec08261111dbef inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d474cf912188a562e9f419872031e inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ac61d474cf912188a562e9f419872031e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>drop_table</b> (const char *name)</td></tr>
<tr class="separator:ac61d474cf912188a562e9f419872031e inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fe1bf5cf87a258787ca67a2add8bd1 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a75fe1bf5cf87a258787ca67a2add8bd1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create_handler_files</b> (const char *name, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a75fe1bf5cf87a258787ca67a2add8bd1 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370a0f787c1b936e475a5762b91350c inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae370a0f787c1b936e475a5762b91350c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_ha_share_ref</b> (<a class="el" href="classHandler__share.html">Handler_share</a> **arg_ha_share)</td></tr>
<tr class="separator:ae370a0f787c1b936e475a5762b91350c inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a271a4a135d110cf6f22ae8ce664664 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6a271a4a135d110cf6f22ae8ce664664"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_lock_type</b> () const</td></tr>
<tr class="separator:a6a271a4a135d110cf6f22ae8ce664664 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d741fb837dacdddc29c1d7e912204 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af07d741fb837dacdddc29c1d7e912204">update_field_defs_with_zip_dict_info</a> (THD *thd, const char *part_name)</td></tr>
<tr class="separator:af07d741fb837dacdddc29c1d7e912204 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f01ea7ce530c3a234e5d17363204f13 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5f01ea7ce530c3a234e5d17363204f13">rpl_lookup_rows</a> ()</td></tr>
<tr class="separator:a5f01ea7ce530c3a234e5d17363204f13 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade620586d26510ba599c3e7975e8cf39 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ade620586d26510ba599c3e7975e8cf39"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_before_write_rows</b> ()</td></tr>
<tr class="separator:ade620586d26510ba599c3e7975e8cf39 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7bc641b76ed6ba8db016baea0d9f00 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a5b7bc641b76ed6ba8db016baea0d9f00"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_after_write_rows</b> ()</td></tr>
<tr class="separator:a5b7bc641b76ed6ba8db016baea0d9f00 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06882513fd3b53eee1d20bd0a90d46 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6f06882513fd3b53eee1d20bd0a90d46"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_before_delete_rows</b> ()</td></tr>
<tr class="separator:a6f06882513fd3b53eee1d20bd0a90d46 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa3ebfc3bd1ffa26915db17c452837b inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a6fa3ebfc3bd1ffa26915db17c452837b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_after_delete_rows</b> ()</td></tr>
<tr class="separator:a6fa3ebfc3bd1ffa26915db17c452837b inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f22d5f23dfc16185c7e8f8776fc7fc3 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a7f22d5f23dfc16185c7e8f8776fc7fc3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_before_update_rows</b> ()</td></tr>
<tr class="separator:a7f22d5f23dfc16185c7e8f8776fc7fc3 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a966e76173a3c1eb0d8afa8a9acce9 inherit pub_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a44a966e76173a3c1eb0d8afa8a9acce9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_after_update_rows</b> ()</td></tr>
<tr class="separator:a44a966e76173a3c1eb0d8afa8a9acce9 inherit pub_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1a9f8c543b010643808df803f7db9e1b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a1a9f8c543b010643808df803f7db9e1b">set_dbname</a> (const char *pathname, char *dbname)</td></tr>
<tr class="separator:a1a9f8c543b010643808df803f7db9e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3432f398baec4d4ebc0b02af534bd860"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a3432f398baec4d4ebc0b02af534bd860">set_tabname</a> (const char *pathname, char *tabname)</td></tr>
<tr class="separator:a3432f398baec4d4ebc0b02af534bd860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58176e049237d75781412ad1e75e4d0f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a58176e049237d75781412ad1e75e4d0f">release_completed_operations</a> (NdbTransaction *)</td></tr>
<tr class="separator:a58176e049237d75781412ad1e75e4d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:aa6c449e2194c590eb53b6a6b5dbb362c inherit pub_static_methods_classhandler"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa6c449e2194c590eb53b6a6b5dbb362c">my_prepare_gcolumn_template</a> (THD *thd, const char *db_name, const char *table_name, <a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a> myc, void *ib_table)</td></tr>
<tr class="separator:aa6c449e2194c590eb53b6a6b5dbb362c inherit pub_static_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dd6a07c4f58be3273576d0cc813933 inherit pub_static_methods_classhandler"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a32dd6a07c4f58be3273576d0cc813933">my_eval_gcolumn_expr_with_open</a> (THD *thd, const char *db_name, const char *table_name, const MY_BITMAP *const fields, uchar *record)</td></tr>
<tr class="separator:a32dd6a07c4f58be3273576d0cc813933 inherit pub_static_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b30a208b304f519e8d74070a41ac19 inherit pub_static_methods_classhandler"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a39b30a208b304f519e8d74070a41ac19">my_eval_gcolumn_expr</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const MY_BITMAP *const fields, uchar *record)</td></tr>
<tr class="separator:a39b30a208b304f519e8d74070a41ac19 inherit pub_static_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSql__alloc"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSql__alloc')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSql__alloc.html">Sql_alloc</a></td></tr>
<tr class="memitem:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a193100cab44074df6f4f1507b333dcda"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t size)  throw ()</td></tr>
<tr class="separator:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a14b17bd7ec22fc7a7e5b56702e5630a6"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t size)  throw ()</td></tr>
<tr class="separator:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a13f2eacbb6adcee5c9ac94629e2863b3"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t size, MEM_ROOT *mem_root)  throw ()</td></tr>
<tr class="separator:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a06adbd3404f702994fd10619c41267f0"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t size, MEM_ROOT *mem_root)  throw ()</td></tr>
<tr class="separator:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a1e428ed5b826482a49b1d8a1d246a579"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t size)</td></tr>
<tr class="separator:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a7c08622003a34134a56eccaf2d95c0b9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="ab0c7ed4b5a1eb798f3af463eb84b1e3b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a6dd86b56cecc3919504cf5e1452f2511"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, size_t size)</td></tr>
<tr class="separator:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a83f7116a2471d8f8ea1c29ef9f66d01f"><td class="memItemLeft" align="right" valign="top"><a id="a83f7116a2471d8f8ea1c29ef9f66d01f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ndb_pushed_builder_ctx</b></td></tr>
<tr class="separator:a83f7116a2471d8f8ea1c29ef9f66d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d2867500d8a5c574e4e22d1b407d80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a81d2867500d8a5c574e4e22d1b407d80">ndbcluster_drop_database_impl</a> (THD *thd, const char *path)</td></tr>
<tr class="separator:a81d2867500d8a5c574e4e22d1b407d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacd62dc79483d9590e2250286e714e4"><td class="memItemLeft" align="right" valign="top"><a id="abacd62dc79483d9590e2250286e714e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>g_get_ndb_blobs_value</b> (NdbBlob *ndb_blob, void *arg)</td></tr>
<tr class="separator:abacd62dc79483d9590e2250286e714e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eb7dd1da4f4878ea3f774df43fcb20"><td class="memItemLeft" align="right" valign="top"><a id="a98eb7dd1da4f4878ea3f774df43fcb20"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_completed_operations_pre_commit</b> (<a class="el" href="classThd__ndb.html">Thd_ndb</a> *, NdbTransaction *, const NdbOperation *, uint *ignore_count)</td></tr>
<tr class="separator:a98eb7dd1da4f4878ea3f774df43fcb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bd9470fe7beb5dc3481654718f39b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ae2bd9470fe7beb5dc3481654718f39b7">ndbcluster_commit</a> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, bool all)</td></tr>
<tr class="separator:ae2bd9470fe7beb5dc3481654718f39b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:ab5b14b11876fb5ac53a4cc7aceea6a2d inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab5b14b11876fb5ac53a4cc7aceea6a2d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>enum_range_scan_direction</b> { <b>RANGE_SCAN_ASC</b>, 
<b>RANGE_SCAN_DESC</b>
 }</td></tr>
<tr class="separator:ab5b14b11876fb5ac53a4cc7aceea6a2d inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68580c3751fc08427f5ac48ef4b2d69 inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ab68580c3751fc08427f5ac48ef4b2d69"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NONE</b> =0, 
<b>INDEX</b>, 
<b>RND</b>
 }</td></tr>
<tr class="separator:ab68580c3751fc08427f5ac48ef4b2d69 inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67af5473a36655c922682399d4c5b6ec inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a67af5473a36655c922682399d4c5b6ec"></a>
typedef ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>Table_flags</b></td></tr>
<tr class="separator:a67af5473a36655c922682399d4c5b6ec inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c241e50948859d98ceae6e39066838 inherit pub_types_classhandler"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a>) (const <a class="el" href="structTABLE.html">TABLE</a> *, void *)</td></tr>
<tr class="separator:ad4c241e50948859d98ceae6e39066838 inherit pub_types_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classhandler')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a395bae75af9e51a116097a788b2cf57f inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a395bae75af9e51a116097a788b2cf57f"></a>
<a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ht</b></td></tr>
<tr class="separator:a395bae75af9e51a116097a788b2cf57f inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a53c7037216007ba6140e6cff5162024d"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b></td></tr>
<tr class="separator:a53c7037216007ba6140e6cff5162024d inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a7501dc41ecb010069e8bc9d035aae6aa"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>dup_ref</b></td></tr>
<tr class="separator:a7501dc41ecb010069e8bc9d035aae6aa inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df561df4b2b6552a7b42189feb0400a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1df561df4b2b6552a7b42189feb0400a"></a>
<a class="el" href="classha__statistics.html">ha_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b></td></tr>
<tr class="separator:a1df561df4b2b6552a7b42189feb0400a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec520eba79eb9f182c534e82c60ebc6 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9ec520eba79eb9f182c534e82c60ebc6"></a>
range_seq_t&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_iter</b></td></tr>
<tr class="separator:a9ec520eba79eb9f182c534e82c60ebc6 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51e423645829d3e540c109556931fa inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a2a51e423645829d3e540c109556931fa"></a>
<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_funcs</b></td></tr>
<tr class="separator:a2a51e423645829d3e540c109556931fa inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52372127bd238a7f622190316ba8124f inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a52372127bd238a7f622190316ba8124f"></a>
<a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>multi_range_buffer</b></td></tr>
<tr class="separator:a52372127bd238a7f622190316ba8124f inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a476dfe8526807dfc820c4b09f7a6d1 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1a476dfe8526807dfc820c4b09f7a6d1"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>ranges_in_seq</b></td></tr>
<tr class="separator:a1a476dfe8526807dfc820c4b09f7a6d1 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4dfb21c4583b55afc4fe5aba50389 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="adff4dfb21c4583b55afc4fe5aba50389"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_is_output_sorted</b></td></tr>
<tr class="separator:adff4dfb21c4583b55afc4fe5aba50389 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2632d137c3a17fa583f08db5681e80a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="af2632d137c3a17fa583f08db5681e80a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_have_range</b></td></tr>
<tr class="separator:af2632d137c3a17fa583f08db5681e80a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2347edc229832e533d1fb73b236e32b inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="af2347edc229832e533d1fb73b236e32b"></a>
KEY_MULTI_RANGE&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_cur_range</b></td></tr>
<tr class="separator:af2347edc229832e533d1fb73b236e32b inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a28d698fe9901f0f487c9618ddbb0f1be"></a>
key_range *&#160;</td><td class="memItemRight" valign="bottom"><b>end_range</b></td></tr>
<tr class="separator:a28d698fe9901f0f487c9618ddbb0f1be inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186b7c7a70634a8e9758ed51708359c inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3186b7c7a70634a8e9758ed51708359c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>errkey</b></td></tr>
<tr class="separator:a3186b7c7a70634a8e9758ed51708359c inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5efc62f32ef66b55667fd8370ef33 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a5ad5efc62f32ef66b55667fd8370ef33"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>key_used_on_scan</b></td></tr>
<tr class="separator:a5ad5efc62f32ef66b55667fd8370ef33 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2838eebffef46663c19f85d2ad2cc inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a29f2838eebffef46663c19f85d2ad2cc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>active_index</b></td></tr>
<tr class="separator:a29f2838eebffef46663c19f85d2ad2cc inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a></td></tr>
<tr class="separator:a64def328ff0ca7e391b217c2d3a758ec inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943005f89e7a6d5cee246e1c5b46e9ab inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a943005f89e7a6d5cee246e1c5b46e9ab"></a>
FT_INFO *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_handler</b></td></tr>
<tr class="separator:a943005f89e7a6d5cee246e1c5b46e9ab inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae346e9156bcf1dd515eef535c40ca601 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae346e9156bcf1dd515eef535c40ca601"></a>
enum handler:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>inited</b></td></tr>
<tr class="separator:ae346e9156bcf1dd515eef535c40ca601 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47d68a7b406d8777396a657095d5e8 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="afd47d68a7b406d8777396a657095d5e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>implicit_emptied</b></td></tr>
<tr class="separator:afd47d68a7b406d8777396a657095d5e8 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2f8d7155cb44162bb4181cb09f2f3 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a0ed2f8d7155cb44162bb4181cb09f2f3"></a>
const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_cond</b></td></tr>
<tr class="separator:a0ed2f8d7155cb44162bb4181cb09f2f3 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3d956f73649657bad389acfad5f0b inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae9b3d956f73649657bad389acfad5f0b"></a>
<a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond</b></td></tr>
<tr class="separator:ae9b3d956f73649657bad389acfad5f0b inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc8d81143d1c9c10b976711fe44cf37 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a4dc8d81143d1c9c10b976711fe44cf37"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond_keyno</b></td></tr>
<tr class="separator:a4dc8d81143d1c9c10b976711fe44cf37 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02710c45cf96dacef1109b49de048ee inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae02710c45cf96dacef1109b49de048ee"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>rows_read</b></td></tr>
<tr class="separator:ae02710c45cf96dacef1109b49de048ee inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d78935307f2f6fc1d918ddc30ef8d7 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a77d78935307f2f6fc1d918ddc30ef8d7"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>rows_changed</b></td></tr>
<tr class="separator:a77d78935307f2f6fc1d918ddc30ef8d7 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73622d661f0eb2a305f8bff3a9b99c18 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a73622d661f0eb2a305f8bff3a9b99c18"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>index_rows_read</b> [MAX_KEY]</td></tr>
<tr class="separator:a73622d661f0eb2a305f8bff3a9b99c18 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a></td></tr>
<tr class="separator:a62ab295e407d8a5c50087fed0f4fcd18 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a></td></tr>
<tr class="separator:a05dd2cafd83ae60562649bf9688aebf1 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDiscrete__interval.html">Discrete_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a></td></tr>
<tr class="separator:a1540a47a05c03724f1102aaaa623131e inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a></td></tr>
<tr class="separator:acdfcef0738a89138c8f41ded8da17c0a inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="memItemLeft" align="right" valign="top">PSI_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a></td></tr>
<tr class="separator:a881e7cba3fe3bf9731a91be82983cc35 inherit pub_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">index_read_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">More...</a><br /></td></tr>
<tr class="separator:af8c2b258691e5baac8dd22d19c084b37 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">index_read_idx_map</a> (uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="classhandler.html#acba0c549a00023dd44682cd9452cf830">More...</a><br /></td></tr>
<tr class="separator:acba0c549a00023dd44682cd9452cf830 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5459b92420f74e6f88dec137e1941d22 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">index_next_same</a> (uchar *buf, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a5459b92420f74e6f88dec137e1941d22 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">index_read_last_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="memdesc:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">More...</a><br /></td></tr>
<tr class="separator:ae069d5991214e1fdf14cc44fd865a180 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b748cb37f18c1db0a6dfc016a32b86 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a76b748cb37f18c1db0a6dfc016a32b86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_using_full_unique_key</b> (uint active_index, key_part_map keypart_map, enum ha_rkey_function find_flag) const</td></tr>
<tr class="separator:a76b748cb37f18c1db0a6dfc016a32b86 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe486748715adbe6f7d6b9a9228cdf4 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a5fe486748715adbe6f7d6b9a9228cdf4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_using_prohibited_gap_locks</b> (<a class="el" href="structTABLE.html">TABLE</a> *table, bool using_full_primary_key) const</td></tr>
<tr class="separator:a5fe486748715adbe6f7d6b9a9228cdf4 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03831da80c8a99422edd4b4ab84fa55a inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a03831da80c8a99422edd4b4ab84fa55a">prepare_index_key_scan</a> (const uchar *key, uint key_len)</td></tr>
<tr class="separator:a03831da80c8a99422edd4b4ab84fa55a inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25b44b50ac64192d6cfef591252ed7 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="aad25b44b50ac64192d6cfef591252ed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_statistic_increment</b> (ulonglong SSV::*offset) const</td></tr>
<tr class="separator:aad25b44b50ac64192d6cfef591252ed7 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df65ee64bcedb5a4b34bf752b2fab08 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a9df65ee64bcedb5a4b34bf752b2fab08"></a>
THD *&#160;</td><td class="memItemRight" valign="bottom"><b>ha_thd</b> (void) const</td></tr>
<tr class="separator:a9df65ee64bcedb5a4b34bf752b2fab08 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">PSI_table_share *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a69803cd29d92bfecd97212354212c516">ha_table_share_psi</a> (const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share) const</td></tr>
<tr class="separator:a69803cd29d92bfecd97212354212c516 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHandler__share.html">Handler_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a> ()</td></tr>
<tr class="separator:a13bf21a8ad4be872bbfe94f5cb40abca inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a> (<a class="el" href="classHandler__share.html">Handler_share</a> *arg_ha_share)</td></tr>
<tr class="separator:ab24470ac1d4ac336cedbe7c245d321c9 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a> ()</td></tr>
<tr class="separator:aa3a39db9dc1cca31f4a3ec0e0e1d7300 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a> ()</td></tr>
<tr class="separator:a8059bbed3de416b3bea51c69dc064e79 inherit pro_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classhandler')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:ae2613bd83c495f55fe2ce05a9df2d86f inherit pro_static_methods_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="ae2613bd83c495f55fe2ce05a9df2d86f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_using_full_key</b> (key_part_map keypart_map, uint <a class="el" href="group__Query__Optimizer.html#ga6609ac0420a8a415d5a57cc6659f460d">actual_key_parts</a>)</td></tr>
<tr class="separator:ae2613bd83c495f55fe2ce05a9df2d86f inherit pro_static_methods_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classhandler"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classhandler')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classhandler.html">handler</a></td></tr>
<tr class="memitem:a3b094cfe680aa06a7d8b70194415aa3b inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a3b094cfe680aa06a7d8b70194415aa3b"></a>
<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table_share</b></td></tr>
<tr class="separator:a3b094cfe680aa06a7d8b70194415aa3b inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0d051d1ef534891b27612cc4ff56f7 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="abb0d051d1ef534891b27612cc4ff56f7"></a>
<a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table</b></td></tr>
<tr class="separator:abb0d051d1ef534891b27612cc4ff56f7 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98743b18a24c8baef7e22a11df74d6c9 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a98743b18a24c8baef7e22a11df74d6c9"></a>
Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_flags</b></td></tr>
<tr class="separator:a98743b18a24c8baef7e22a11df74d6c9 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44b6a4c101f982cd13a344dce5a870 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="adf44b6a4c101f982cd13a344dce5a870"></a>
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>estimation_rows_to_insert</b></td></tr>
<tr class="separator:adf44b6a4c101f982cd13a344dce5a870 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011df14ecc738037499572c304d8ee90 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a011df14ecc738037499572c304d8ee90"></a>
<a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>range_key_part</b></td></tr>
<tr class="separator:a011df14ecc738037499572c304d8ee90 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272c3d9b40a9e7c5de20ed390d23a636 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a272c3d9b40a9e7c5de20ed390d23a636"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>eq_range</b></td></tr>
<tr class="separator:a272c3d9b40a9e7c5de20ed390d23a636 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a159ca294d8dafe32405e6ad546e6a4 inherit pro_attribs_classhandler"><td class="memItemLeft" align="right" valign="top"><a id="a1a159ca294d8dafe32405e6ad546e6a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>in_range_check_pushed_down</b></td></tr>
<tr class="separator:a1a159ca294d8dafe32405e6ad546e6a4 inherit pro_attribs_classhandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a743f4c09bc748bd6d1fce84520472614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743f4c09bc748bd6d1fce84520472614">&#9670;&nbsp;</a></span>ha_ndbcluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_ndbcluster::ha_ndbcluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>hton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Constructor for the NDB Cluster table handler . </p>

</div>
</div>
<a id="a2a0e969376e3f2d0677cd4094ae04b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0e969376e3f2d0677cd4094ae04b7e">&#9670;&nbsp;</a></span>~ha_ndbcluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_ndbcluster::~ha_ndbcluster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Destructor for NDB Cluster table handler. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8392198f6ff1b83f32ee480b257566a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8392198f6ff1b83f32ee480b257566a9">&#9670;&nbsp;</a></span>assign_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::assign_pushed_join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classndb__pushed__join.html">ndb_pushed_join</a> *&#160;</td>
          <td class="paramname"><em>pushed_join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">In case a pushed join having the table for this handler as its root has been produced. ::assign_pushed_join() is responsible for setting up this <a class="el" href="classha__ndbcluster.html">ha_ndbcluster</a> instance such that the prepared NdbQuery might be instantiated at execution time. </p>

</div>
</div>
<a id="ade5341ce688c24b5885145f821cdf249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5341ce688c24b5885145f821cdf249">&#9670;&nbsp;</a></span>bas_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char ** ha_ndbcluster::bas_ext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If frm_error() is called then we will use this to find out what file extentions exist for the storage engine. This is also used by the default rename_table and delete_table method in <a class="el" href="handler_8cc.html" title="Handler-calling-functions.">handler.cc</a>.</p>
<p class="">For engines that have two file name extentions (separate meta/index file and data file), the order of elements is relevant. First element of engine file name extentions array should be meta/index file extention. Second element - data file extention. This order is assumed by prepare_for_repair() when REPAIR <a class="el" href="structTABLE.html">TABLE</a> ... USE_FRM is issued. </p>

<p>Implements <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">handler</a>.</p>

</div>
</div>
<a id="a89cbc7ca67dcd89d07693186f5de7ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cbc7ca67dcd89d07693186f5de7ca5">&#9670;&nbsp;</a></span>bulk_update_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::bulk_update_row </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">This method is similar to update_row, however the handler doesn't need to execute the updates at this point in time. The handler can be certain that another call to bulk_update_row will occur OR a call to exec_bulk_update before the set of updates in this query is concluded.</p>
<p class="">Note: If HA_ERR_FOUND_DUPP_KEY is returned, the handler must read all columns of the row so MySQL can create an error message. If the columns required for the error message are not read, the error message will contain garbage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_data</td><td>Old record </td></tr>
    <tr><td class="paramname">new_data</td><td>New record </td></tr>
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">handler</a>.</p>

</div>
</div>
<a id="a3fe3719d8dd1d5f41467250d632abd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe3719d8dd1d5f41467250d632abd3c">&#9670;&nbsp;</a></span>can_switch_engines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::can_switch_engines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Used in ALTER <a class="el" href="structTABLE.html">TABLE</a> to check if changing storage engine is allowed.</p>
<dl class="section note"><dt>Note</dt><dd>Called without holding thr_lock.c lock.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Changing storage engine is allowed. </td></tr>
    <tr><td class="paramname">false</td><td>Changing storage engine not allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">handler</a>.</p>

</div>
</div>
<a id="a178fe8e973508932db3d3d6ca3a625a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178fe8e973508932db3d3d6ca3a625a9">&#9670;&nbsp;</a></span>check_if_supported_inplace_alter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_alter_inplace_result ha_ndbcluster::check_if_supported_inplace_alter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Check if a storage engine supports a particular alter table in-place</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ALTER_ERROR</td><td>Unexpected error. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NOT_SUPPORTED</td><td>Not supported, must use copy. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_EXCLUSIVE_LOCK</td><td>Supported, but requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</td><td>Supported, but requires SNW lock during main phase. Prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK</td><td>Supported, but requires SNW lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE</td><td>Supported, concurrent reads/writes allowed. However, prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK</td><td>Supported, concurrent reads/writes allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation uses the old in-place ALTER API to determine if the storage engine supports in-place ALTER or not.</dd>
<dd>
Called without holding thr_lock.c lock. </dd></dl>
<p class="">Check all indexes to determine if column has index instead of checking field-&gt;flags (PRI_KEY_FLAG | UNIQUE_KEY_FLAG | MULTIPLE_KEY_FLAG since field-&gt;flags appears to only be set on first column in multi-part index</p>
<p class="">This is a "copy" of code in ::create() that "auto-converts" columns with keys into memory (unless storage disk is explicitly added) This is needed to check if getStorageType() == getStorageType() further down</p>
<p class="">If user didn't specify any column format, keep old to make as many alter's as possible online</p>

<p>Reimplemented from <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">handler</a>.</p>

</div>
</div>
<a id="af55db4a0efc9c99947b72b4bfc83b8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55db4a0efc9c99947b72b4bfc83b8ad">&#9670;&nbsp;</a></span>commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Commit or rollback the changes made during <a class="el" href="classha__ndbcluster.html#a3d7235ae7ee13ad3a572af0fd5c15291">prepare_inplace_alter_table()</a> and <a class="el" href="classha__ndbcluster.html#a5ff1e368997d6822e3285080fade11fe">inplace_alter_table()</a> inside the storage engine. Note that in case of rollback the allowed level of concurrency during this operation will be the same as for <a class="el" href="classha__ndbcluster.html#a5ff1e368997d6822e3285080fade11fe">inplace_alter_table()</a> and thus might be higher than during <a class="el" href="classha__ndbcluster.html#a3d7235ae7ee13ad3a572af0fd5c15291">prepare_inplace_alter_table()</a>. (For example, concurrent writes were blocked during prepare, but might not be during rollback).</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function with commit= true reports error, it will be called again with commit= false.</dd>
<dd>
In case of partitioning, this function might be called for rollback without <a class="el" href="classha__ndbcluster.html#a3d7235ae7ee13ad3a572af0fd5c15291">prepare_inplace_alter_table()</a> having been called first. Also partitioned tables sets ha_alter_info-&gt;group_commit_ctx to a NULL terminated array of the partitions handlers and if all of them are committed as one, then group_commit_ctx should be set to NULL to indicate to the partitioning handler that all partitions handlers are committed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classha__ndbcluster.html#a3d7235ae7ee13ad3a572af0fd5c15291">prepare_inplace_alter_table()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">commit</td><td>True =&gt; Commit, False =&gt; Rollback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">handler</a>.</p>

</div>
</div>
<a id="a0de805435e8251f27ba3394052f6b1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de805435e8251f27ba3394052f6b1c7">&#9670;&nbsp;</a></span>cond_pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::cond_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Pop the top condition from the condition stack of the handler instance. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">handler</a>.</p>

</div>
</div>
<a id="a2285b3af9153f052ef6ba0cfc3bacea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2285b3af9153f052ef6ba0cfc3bacea1">&#9670;&nbsp;</a></span>cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classItem.html">Item</a> * ha_ndbcluster::cond_push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Push a condition to ndbcluster storage engine for evaluation during table and index scans. The conditions will be stored on a stack for possibly storing several conditions. The stack can be popped by calling cond_pop, handler::extra(HA_EXTRA_RESET) (handler::reset()) will clear the stack. The current implementation supports arbitrary AND/OR nested conditions with comparisons between columns and constants (including constant expressions and function calls) and the following comparison operators: =, !=, &gt;, &gt;=, &lt;, &lt;=, "is null", and "is not null".</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>The condition was supported and will be evaluated for each row found during the scan </td></tr>
    <tr><td class="paramname">cond</td><td>The condition was not supported and all rows will be returned from the scan for evaluation (and thus not saved on stack) </td></tr>
  </table>
  </dd>
</dl>
<p class="">'cond' refers fields from other tables, or other instances of this table, -&gt; reject it. (Optimizer need to have a better understanding of what is pushable by each handler.)</p>

<p>Reimplemented from <a class="el" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">handler</a>.</p>

</div>
</div>
<a id="ac74383fcb359c0f2d06acf101bb4d4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74383fcb359c0f2d06acf101bb4d4b0">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Create a table in NDB Cluster </p>
<p class="">The extra +7 concists 2 - words from pk in blob table 5 - from extra words added by tup/dict??</p>
<p class="">If size &gt; NDB_MAX and pk_length+7 &gt;= NDB_MAX then the table can't be created anyway, so skip changing part size, and have error later</p>
<p class="">mysql doesnt know/care about FK (buhhh) so we need to copy the old ones ourselves</p>
<p class="">createTable/index schema transaction OK</p>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a4d32721908372dc62c490e14a005e03c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d32721908372dc62c490e14a005e03c">&#9670;&nbsp;</a></span>delete_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Delete a table in the engine. Called for base as well as temporary tables.</p>
<p class="">Delete all files with extension from <a class="el" href="classha__ndbcluster.html#ade5341ce688c24b5885145f821cdf249">bas_ext()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Base name of table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We assume that the handler may return more extensions than was actually used for the file.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If we successfully deleted at least one file from base_ext and didn't get any other errors than ENOENT </td></tr>
    <tr><td class="paramname">!0</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler</a>.</p>

</div>
</div>
<a id="a38b1458caf3677f93276073e22669aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b1458caf3677f93276073e22669aeb">&#9670;&nbsp;</a></span>end_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::end_bulk_insert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">End of an insert. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a3c3b80b72e921059f62aed3eda1db911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3b80b72e921059f62aed3eda1db911">&#9670;&nbsp;</a></span>end_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::end_bulk_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Perform any needed clean-up, no outstanding updates are there at the moment. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">handler</a>.</p>

</div>
</div>
<a id="a81e58b0a19c7cc7d857a3f00e039ae37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e58b0a19c7cc7d857a3f00e039ae37">&#9670;&nbsp;</a></span>end_read_removal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows ha_ndbcluster::end_read_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">End read (before write) removal and return the number of rows really written </p><dl class="section see"><dt>See also</dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">handler</a>.</p>

</div>
</div>
<a id="a59555b02c52fc703e99a41d3ee3a04c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59555b02c52fc703e99a41d3ee3a04c3">&#9670;&nbsp;</a></span>estimate_rows_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows ha_ndbcluster::estimate_rows_upper_bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Return upper bound of current number of records in the table (max. of how many records one will retrieve when doing a full table scan) If upper bound is not known, HA_POS_ERROR should be returned as a max possible upper bound. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">handler</a>.</p>

</div>
</div>
<a id="a5c9f552924c7168373ab0d1c2ba0e049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9f552924c7168373ab0d1c2ba0e049">&#9670;&nbsp;</a></span>exec_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::exec_bulk_update </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">After this call all outstanding updates must be performed. The number of duplicate key errors are reported in the duplicate key parameter. It is allowed to continue to the batched update after this call, the handler has to wait until end_bulk_update with changing state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">handler</a>.</p>

</div>
</div>
<a id="a31a5f675ffb30d67ba91bb1cb9ec9dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a5f675ffb30d67ba91bb1cb9ec9dc8">&#9670;&nbsp;</a></span>get_error_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::get_error_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Override the default get_error_message in order to add the error message of NDB . </p>

<p>Reimplemented from <a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">handler</a>.</p>

</div>
</div>
<a id="a8abae855bbb818c6827294eb17549365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abae855bbb818c6827294eb17549365">&#9670;&nbsp;</a></span>get_foreign_key_create_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * ha_ndbcluster::get_foreign_key_create_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class=""><a class="el" href="classList.html">List</a> foreigns for this table</p>
<p class="">listDependentObjects will return FK's in order that they are stored in hash-table in Dbdict (i.e random)</p>
<p class="">sort them to make MTR and similar happy</p>
<p class="">this was on parent table (fk are shown on child table in SQL)</p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a3b97152a2ce0d7e7622de70daae4171b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b97152a2ce0d7e7622de70daae4171b">&#9670;&nbsp;</a></span>get_foreign_key_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::get_foreign_key_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the list of foreign keys in this table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the set of foreign keys where this table is the dependent or child table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handler error code or zero for success. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">handler</a>.</p>

</div>
</div>
<a id="a8ef2926a38b2b39387ad40c55708faa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef2926a38b2b39387ad40c55708faa2">&#9670;&nbsp;</a></span>get_parent_foreign_key_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::get_parent_foreign_key_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the list of foreign keys referencing this table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the set of foreign keys where this table is the referenced or parent table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handler error code or zero for success. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">handler</a>.</p>

</div>
</div>
<a id="a1d3598345c3543f684c566f79a61cedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3598345c3543f684c566f79a61cedc">&#9670;&nbsp;</a></span>index_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::index_first </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">handler</a>.</p>

</div>
</div>
<a id="a129ea7ed14c99a3437beff5fece3e832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129ea7ed14c99a3437beff5fece3e832">&#9670;&nbsp;</a></span>index_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulong ha_ndbcluster::index_flags </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the flags for an index.</p>
<dl class="section return"><dt>Returns</dt><dd>flags depending on the type of the index. </dd></dl>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a6f6e9347ec700ee952a998fa88ae68b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6e9347ec700ee952a998fa88ae68b2">&#9670;&nbsp;</a></span>index_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::index_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">handler</a>.</p>

</div>
</div>
<a id="a865afdc25ee4ca42fafde872e476e0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865afdc25ee4ca42fafde872e476e0ff">&#9670;&nbsp;</a></span>index_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::index_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">handler</a>.</p>

</div>
</div>
<a id="a8c12adc1c87097562760e06689e7ec38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c12adc1c87097562760e06689e7ec38">&#9670;&nbsp;</a></span>index_next_pushed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::index_next_pushed </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the next record from an indexes table access being a child operation in a pushed join. Fetch will be from prefetched cached records which are materialized into the bound buffer areas as result of this call. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a824559f84d7f256052f0394e9276774f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824559f84d7f256052f0394e9276774f">&#9670;&nbsp;</a></span>index_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::index_prev </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">handler</a>.</p>

</div>
</div>
<a id="a0fc1fdfefdf8315fca2ebac5ad296e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc1fdfefdf8315fca2ebac5ad296e08">&#9670;&nbsp;</a></span>index_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::index_read </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Specify as a closed EQ_RANGE. Setting HA_READ_AFTER_KEY seems odd, but this is according to MySQL convention, see opt_range.cc.</p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="aa7c34f1ba38d98ac501de119c7933dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c34f1ba38d98ac501de119c7933dce">&#9670;&nbsp;</a></span>index_read_pushed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::index_read_pushed </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the first record from an indexed table access being a child operation in a pushed join. Fetch will be from prefetched cached records which are materialized into the bound buffer areas as result of this call. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a5ff1e368997d6822e3285080fade11fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff1e368997d6822e3285080fade11fe">&#9670;&nbsp;</a></span>inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a>. The level of concurrency allowed during this operation depends on the return value from <a class="el" href="classha__ndbcluster.html#a178fe8e973508932db3d3d6ca3a625a9">check_if_supported_inplace_alter()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classha__ndbcluster.html#af55db4a0efc9c99947b72b4bfc83b8ad">commit_inplace_alter_table()</a> will be called with commit= false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">handler</a>.</p>

</div>
</div>
<a id="a6adf9b7e7b7357f464a01f9a7ed2a1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6adf9b7e7b7357f464a01f9a7ed2a1ee">&#9670;&nbsp;</a></span>is_fk_defined_on_table_or_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::is_fk_defined_on_table_or_index </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If index == MAX_KEY then a check for table is made and if index &lt; MAX_KEY then a check is made if the table has foreign keys and if a foreign key uses this index (and thus the index cannot be dropped).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to check if foreign key uses it</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Foreign key defined on table or index </td></tr>
    <tr><td class="paramname">FALSE</td><td>No foreign key defined </td></tr>
  </table>
  </dd>
</dl>
<p class="">This doesnt seem implemented in Innodb either...</p>

<p>Reimplemented from <a class="el" href="classhandler.html#adda33331aacc500b1b974033cb64a869">handler</a>.</p>

</div>
</div>
<a id="a95efd97175c4d0f4e5548473b6759e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95efd97175c4d0f4e5548473b6759e31">&#9670;&nbsp;</a></span>is_ignorable_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ha_ndbcluster::is_ignorable_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an error can be ignored or not. </p>
<p class="">This method is used to analyze the error to see whether the error is ignorable or not. Such errors will be reported as warnings instead of errors for IGNORE statements. This means that the statement will not abort, but instead continue to the next row.</p>
<p class="">HA_ERR_FOUND_DUP_UNIQUE is a special case in MyISAM that means the same thing as HA_ERR_FOUND_DUP_KEY, but can in some cases lead to a slightly different error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code received from the handler interface (HA_ERR_...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the error is ignorablel or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the error is ignorable </td></tr>
    <tr><td class="paramname">false</td><td>the error is not ignorable</td></tr>
  </table>
  </dd>
</dl>
<p>This method is used to analyse the error to see whether the error is ignorable or not. Further comments in header file. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a39c5919d6a3f3098353f4517e2c81037">handler</a>.</p>

</div>
</div>
<a id="ac5921b0992ea58b7698d649fcc7d50c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5921b0992ea58b7698d649fcc7d50c1">&#9670;&nbsp;</a></span>local_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::local_close </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>release_metadata_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close the table</p><ul>
<li>release resources setup by <a class="el" href="classha__ndbcluster.html#a5e1e0e1c8aa3764c955f46b8845b7a1a">open()</a> </li>
</ul>

</div>
</div>
<a id="a90a74f871433b2534301b2b9ac6aecbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a74f871433b2534301b2b9ac6aecbf">&#9670;&nbsp;</a></span>maybe_pushable_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::maybe_pushable_join </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&#160;</td>
          <td class="paramname"><em>reason</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">First level of filtering tables which <em>maybe</em> may be part of a pushed query: Returning 'false' will eliminate this table from being a part of a pushed join. A 'reason' for rejecting this table is required if 'false' is returned. </p>

</div>
</div>
<a id="af561f07d996700a18cd0eb636a14f32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af561f07d996700a18cd0eb636a14f32e">&#9670;&nbsp;</a></span>multi_range_read_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows ha_ndbcluster::multi_range_read_info </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get cost and other information about MRR scan over some sequence of ranges</p>
<p class="">Calculate estimated cost and other information about an MRR scan for some sequence of ranges.</p>
<p class="">The ranges themselves will be known only at execution phase. When this function is called we only know number of ranges and a (rough) E(<a class="el" href="classha__ndbcluster.html#a31757e2658abd318909a0d190a3795c0">records</a>) within those ranges.</p>
<p class="">Currently this function is only called for "n-keypart singlepoint" ranges, i.e. each range is "keypart1=someconst1 AND ... AND keypartN=someconstN"</p>
<p class="">The flags parameter is a combination of those flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION, HA_MRR_LIMITS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramname">n_ranges</td><td>Estimated number of ranges (i.e. intervals) in the range sequence. </td></tr>
    <tr><td class="paramname">n_rows</td><td>Estimated total number of records contained within all of the ranges </td></tr>
    <tr><td class="paramname">bufsz[in,out]</td><td>IN: Size of the buffer available for use OUT: Size of the buffer that will be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramname">flags[in,out]</td><td>A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramname">cost[out]</td><td>Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
    <tr><td class="paramname">other</td><td>Error or can't perform the requested scan </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">handler</a>.</p>

</div>
</div>
<a id="abc8e0c56a5a9150ece910a132a05e826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8e0c56a5a9150ece910a132a05e826">&#9670;&nbsp;</a></span>multi_range_read_info_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows ha_ndbcluster::multi_range_read_info_const </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get cost and other information about MRR scan over a known list of ranges</p>
<p class="">Calculate estimated cost and other information about an MRR scan for given sequence of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramname">seq</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;<a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init()</a> </td></tr>
    <tr><td class="paramname">n_ranges_arg</td><td>Number of ranges in the sequence, or 0 if the caller can't efficiently determine it </td></tr>
    <tr><td class="paramname">bufsz[in,out]</td><td>IN: Size of the buffer available for use OUT: Size of the buffer that is expected to be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramname">flags[in,out]</td><td>A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramname">cost[out]</td><td>Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method (or an overriding one in a derived class) must check for thd-&gt;killed and return HA_POS_ERROR if it is not zero. This is required for a user to be able to interrupt the calculation by killing the connection/query.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_POS_ERROR</td><td>Error or the engine is unable to perform the requested scan. Values of OUT parameters are undefined. </td></tr>
    <tr><td class="paramname">other</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">handler</a>.</p>

</div>
</div>
<a id="aba9c67b0e6bdfc66f40e30b0bccecabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9c67b0e6bdfc66f40e30b0bccecabf">&#9670;&nbsp;</a></span>multi_range_read_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::multi_range_read_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Multi Range Read interface </p>
<p class="">There may still be an open m_multi_cursor from the previous mrr access on this handler. Close it now to free up resources for this NdbScanOperation.</p>

<p>Reimplemented from <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">handler</a>.</p>

</div>
</div>
<a id="a63ab7aa4c5bedaae4a2edb452da67fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ab7aa4c5bedaae4a2edb452da67fc8">&#9670;&nbsp;</a></span>multi_range_read_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::multi_range_read_next </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get next record in MRR scan</p>
<p class="">Default MRR implementation: read the next record</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_info</td><td>OUT Undefined if HA_MRR_NO_ASSOCIATION flag is in effect Otherwise, the opaque value associated with the range that contains the returned record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">handler</a>.</p>

</div>
</div>
<a id="a2e656837653854c38ee70a7cb46515c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e656837653854c38ee70a7cb46515c6">&#9670;&nbsp;</a></span>notify_table_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::notify_table_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Notify the storage engine that the table structure (.FRM) has been updated.</p>
<dl class="section note"><dt>Note</dt><dd>No errors are allowed during <a class="el" href="classha__ndbcluster.html#a2e656837653854c38ee70a7cb46515c6">notify_table_changed()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">handler</a>.</p>

</div>
</div>
<a id="a6aaba12f45b013e5dc180f40463e802a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aaba12f45b013e5dc180f40463e802a">&#9670;&nbsp;</a></span>number_of_pushed_joins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint ha_ndbcluster::number_of_pushed_joins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Reports #tables included in pushed join which this handler instance is part of. ==0 -&gt; Not pushed </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a86930bf10b20ad19b3df07e07d28116e">handler</a>.</p>

</div>
</div>
<a id="a5e1e0e1c8aa3764c955f46b8845b7a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1e0e1c8aa3764c955f46b8845b7a1a">&#9670;&nbsp;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>test_if_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Open a table for further use</p><ul>
<li>fetch metadata for this table from NDB</li>
<li>check that table exists</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;</td><td>0 Table has changed </td></tr>
  </table>
  </dd>
</dl>
<p class="">No share present...we must create one</p>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a9faa32fde75fed4ebafffd11b6c5638e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faa32fde75fed4ebafffd11b6c5638e">&#9670;&nbsp;</a></span>parent_of_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTABLE.html">TABLE</a> * ha_ndbcluster::parent_of_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If this handler instance is a child in a pushed join sequence returned <a class="el" href="structTABLE.html">TABLE</a> instance being my parent? </p>

<p>Reimplemented from <a class="el" href="classhandler.html#aaef865015edc575d0a50d1a6f5b13e4a">handler</a>.</p>

</div>
</div>
<a id="ae47b8413b29048108a6ee92af729ea46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47b8413b29048108a6ee92af729ea46">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::position </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Store the primary key of this record in ref variable, so that the row can be retrieved again later using "reference" in rnd_pos. </p>
<p class="">Keys always use 2 bytes length</p>
<p class="">We have to zero-pad any unused VARCHAR buffer so that MySQL is able to use simple memcmp to compare two instances of the same unique key value to determine if they are equal. MySQL does this to compare contents of two 'ref' values. (Duplicate weedout algorithm is one such case.)</p>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a3d7235ae7ee13ad3a572af0fd5c15291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7235ae7ee13ad3a572af0fd5c15291">&#9670;&nbsp;</a></span>prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Allows the storage engine to update internal structures with concurrent writes blocked. If <a class="el" href="classha__ndbcluster.html#a178fe8e973508932db3d3d6ca3a625a9">check_if_supported_inplace_alter()</a> returns HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE or HA_ALTER_INPLACE_SHARED_AFTER_PREPARE, this function is called with exclusive lock otherwise the same level of locking as for <a class="el" href="classha__ndbcluster.html#a5ff1e368997d6822e3285080fade11fe">inplace_alter_table()</a> will be used.</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classha__ndbcluster.html#af55db4a0efc9c99947b72b4bfc83b8ad">commit_inplace_alter_table()</a> will be called with commit= false.</dd>
<dd>
For partitioning, failing to prepare one partition, means that <a class="el" href="classha__ndbcluster.html#af55db4a0efc9c99947b72b4bfc83b8ad">commit_inplace_alter_table()</a> will be called to roll back changes for all partitions. This means that <a class="el" href="classha__ndbcluster.html#af55db4a0efc9c99947b72b4bfc83b8ad">commit_inplace_alter_table()</a> might be called without <a class="el" href="classha__ndbcluster.html#a3d7235ae7ee13ad3a572af0fd5c15291">prepare_inplace_alter_table()</a> having been called first for a given partition.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">handler</a>.</p>

</div>
</div>
<a id="abf1a2f928fcc952bbe31d8c496ef0dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1a2f928fcc952bbe31d8c496ef0dce">&#9670;&nbsp;</a></span>primary_key_is_clustered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::primary_key_is_clustered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Check if the primary key is clustered or not.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Primary key (if there is one) is a clustered key covering all fields </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1c885f4b3b5bf6d2878225a188b5599f">handler</a>.</p>

</div>
</div>
<a id="ab4b4b9ed3726be8a4a0887785a5ed530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b4b9ed3726be8a4a0887785a5ed530">&#9670;&nbsp;</a></span>print_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::print_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">myf&#160;</td>
          <td class="paramname"><em>errflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Print error that we got from handler function.</p>
<dl class="section note"><dt>Note</dt><dd>In case of delete table it's only safe to use the following parts of the 'table' structure:<ul>
<li>table-&gt;s-&gt;path</li>
<li>table-&gt;alias </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">handler</a>.</p>

</div>
</div>
<a id="a4ebf9b2b84870f08b62e5e3f5465aae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebf9b2b84870f08b62e5e3f5465aae8">&#9670;&nbsp;</a></span>read_range_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::read_range_first </td>
          <td>(</td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read first row between two ranges. Store ranges for future calls to read_range_next. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">handler</a>.</p>

</div>
</div>
<a id="ac4ca12e4aa287eaf6a50c43219a1c776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ca12e4aa287eaf6a50c43219a1c776">&#9670;&nbsp;</a></span>read_range_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::read_range_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">handler</a>.</p>

</div>
</div>
<a id="a31757e2658abd318909a0d190a3795c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31757e2658abd318909a0d190a3795c0">&#9670;&nbsp;</a></span>records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::records </td>
          <td>(</td>
          <td class="paramtype">ha_rows *&#160;</td>
          <td class="paramname"><em>num_rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Number of rows in table. It will only be called if (<a class="el" href="classha__ndbcluster.html#a99dc30c67efa4a7d6d6f3ded9a67b40b">table_flags()</a> &amp; (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT)) != 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_rows</td><td>number of rows in table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae5b7b96354fd25da35a940e656d91940">handler</a>.</p>

</div>
</div>
<a id="acba30a6612e51eb9b5bd9a205d90a505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba30a6612e51eb9b5bd9a205d90a505">&#9670;&nbsp;</a></span>records_in_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows ha_ndbcluster::records_in_range </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>inx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_range *&#160;</td>
          <td class="paramname"><em>min_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_range *&#160;</td>
          <td class="paramname"><em>max_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">optmizer thinks that all values &lt; 2 are exact...but but we don't provide exact statistics</p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="abef3e8ffe1d4b952fc59b356d3d5f142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef3e8ffe1d4b952fc59b356d3d5f142">&#9670;&nbsp;</a></span>register_query_cache_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">my_bool ha_ndbcluster::register_query_cache_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>full_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>full_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qc_engine_callback *&#160;</td>
          <td class="paramname"><em>engine_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>engine_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Register a table for use in the query cache.</p>
<p class="">Fetch the commit_count for the table and return it in engine_data, this will later be used to check if the table has changed, before the cached query is reused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">full_name</td><td>normalized path to the table in the canonical format. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">full_name_len</td><td>length of the normalized path to the table. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">engine_callback</td><td>function to be called before using cache on this table </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_data</td><td>commit_count for this table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Yes, it's ok to cahce this query </td></tr>
    <tr><td class="paramname">FALSE</td><td>No, don't cach the query </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af42324038f030519d7476bf915780341">handler</a>.</p>

</div>
</div>
<a id="a58176e049237d75781412ad1e75e4d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58176e049237d75781412ad1e75e4d0f">&#9670;&nbsp;</a></span>release_completed_operations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::release_completed_operations </td>
          <td>(</td>
          <td class="paramtype">NdbTransaction *&#160;</td>
          <td class="paramname"><em>trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">mysqld reads/write blobs fully, which means that it does not keep blobs open/active over execute, which means that it should be safe to release anything completed here</p>
<p class="">i.e don't check for blobs, but just go ahead and release</p>

</div>
</div>
<a id="a5609bf8b91966dacc3610fc7ceffc314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5609bf8b91966dacc3610fc7ceffc314">&#9670;&nbsp;</a></span>rename_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Rename a table in NDB and on the participating mysqld(s) </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler</a>.</p>

</div>
</div>
<a id="a72ae34dfc88079bca1c85bfcd718b118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ae34dfc88079bca1c85bfcd718b118">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Reset state of file to after 'open'. This function is called after every statement for all tables used by that statement. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="acb923144766720049d59f97cd70286fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb923144766720049d59f97cd70286fd">&#9670;&nbsp;</a></span>rnd_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::rnd_init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class=""><a class="el" href="classha__ndbcluster.html#acb923144766720049d59f97cd70286fd">rnd_init()</a> can be called two times without rnd_end() in between (it only makes sense if scan=1). then the second call should prepare for the new table scan (e.g if rnd_init allocates the cursor, second call should position it to the start of the table, no need to deallocate and allocate it again </p>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="adc93bae43a800cc5ba5057b306136de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc93bae43a800cc5ba5057b306136de1">&#9670;&nbsp;</a></span>rnd_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::rnd_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">handler</a>.</p>

</div>
</div>
<a id="a8980053ce56e386ced321a1ad88d1cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8980053ce56e386ced321a1ad88d1cc2">&#9670;&nbsp;</a></span>rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::rnd_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">An "interesting" record has been found and it's pk retrieved by calling position. Now it's time to read the record from db once again. </p>
<p class="">When using rnd_pos server first retrives a set of records (typically scans them) and store a unique identifier (for ndb this is the primary key) and later retreives the record again using rnd_pos and the saved primary key. For ndb, since we only support committed read the record could have been deleted in between the "save" and the rnd_pos. Therefor we return HA_ERR_RECORD_DELETED in this case rather than HA_ERR_KEY_NOT_FOUND (which will cause statment to be aborted)</p>
<p class=""><br />
 </p>

<p>Implements <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">handler</a>.</p>

</div>
</div>
<a id="abf2a5948eca40262f5d533d7c57ca414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2a5948eca40262f5d533d7c57ca414">&#9670;&nbsp;</a></span>root_of_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTABLE.html">TABLE</a> * ha_ndbcluster::root_of_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If this handler instance is part of a pushed join sequence returned <a class="el" href="structTABLE.html">TABLE</a> instance being root of the pushed query? </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a624f6946109f48559e92a9e7c1b86517">handler</a>.</p>

</div>
</div>
<a id="a21574780af8b6cdc0bbcf8dc5ccb5164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21574780af8b6cdc0bbcf8dc5ccb5164">&#9670;&nbsp;</a></span>scan_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ha_ndbcluster::scan_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">How many seeks it will take to read through the table.</p>
<p class="">This is to be comparable to the number returned by records_in_range so that we can decide if we should scan the table or use keys. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a65f8e5188e2bd9636a564bbc0c3fef86">handler</a>.</p>

</div>
</div>
<a id="a1a9f8c543b010643808df803f7db9e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9f8c543b010643808df803f7db9e1b">&#9670;&nbsp;</a></span>set_dbname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::set_dbname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dbname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Set a given location from full pathname to database name. </p>

</div>
</div>
<a id="a3432f398baec4d4ebc0b02af534bd860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3432f398baec4d4ebc0b02af534bd860">&#9670;&nbsp;</a></span>set_tabname()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::set_tabname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Set a given location from full pathname to table file. </p>

</div>
</div>
<a id="aa852a48bce2fe6fbbe70b83022d74ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa852a48bce2fe6fbbe70b83022d74ed2">&#9670;&nbsp;</a></span>start_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::start_bulk_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Update one record in NDB using primary key. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">handler</a>.</p>

</div>
</div>
<a id="a55b76e2e6595d838981a54951aa3f002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b76e2e6595d838981a54951aa3f002">&#9670;&nbsp;</a></span>start_read_removal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ha_ndbcluster::start_read_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Start read (before write) removal on the current table. </p><dl class="section see"><dt>See also</dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">handler</a>.</p>

</div>
</div>
<a id="aa8f1c0c15ca6a002403699eec20f24e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f1c0c15ca6a002403699eec20f24e6">&#9670;&nbsp;</a></span>start_stmt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ha_ndbcluster::start_stmt </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Start statement, used when one of the tables are locked and also when a stored function is executed.</p>
<p class=""><a class="el" href="classha__ndbcluster.html#aa8f1c0c15ca6a002403699eec20f24e6">start_stmt()</a> thd Thd object lock_type Lock type on table</p>
<p class="">RETURN VALUE 0 Success &gt;0 Error code</p>
<p class="">DESCRIPTION This call indicates the start of a statement when one of the tables in the statement are locked. In this case we cannot call external_lock. It also implies that external_lock is not called at end of statement. Rather the handlerton call commit (ndbcluster_commit) is called to indicate end of transaction. There are cases thus when the commit call actually doesn't refer to a commit but only to and end of statement.</p>
<p class="">In the case of stored functions, one stored function is treated as one statement and the call to commit comes at the end of the stored function. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a5bc14d2819ddbc2d616e11db49d669de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc14d2819ddbc2d616e11db49d669de">&#9670;&nbsp;</a></span>store_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">THR_LOCK_DATA ** ha_ndbcluster::store_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THR_LOCK_DATA **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Is not invoked for non-transactional temporary tables.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classha__ndbcluster.html#a5bc14d2819ddbc2d616e11db49d669de">store_lock()</a> can return more than one lock if the table is MERGE or partitioned.</dd>
<dd>
that one can NOT rely on table-&gt;in_use in <a class="el" href="classha__ndbcluster.html#a5bc14d2819ddbc2d616e11db49d669de">store_lock()</a>. It may refer to a different thread if called from <a class="el" href="group__Locking.html#gad2320fa808c9d6523790e796d57e2331">mysql_lock_abort_for_thread()</a>.</dd>
<dd>
If the table is MERGE, <a class="el" href="classha__ndbcluster.html#a5bc14d2819ddbc2d616e11db49d669de">store_lock()</a> can return less locks than <a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count()</a> claimed. This can happen when the MERGE children are not attached when this is called from another thread. </dd></dl>
<p class="">We need locks on source table when doing offline alter... In 5.1 this worked due to TL_WRITE_ALLOW_READ... but that has been removed in 5.5 I simply add this to get it...</p>

<p>Implements <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">handler</a>.</p>

</div>
</div>
<a id="ac3a23eb89230938663a59fcf8fbe908b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a23eb89230938663a59fcf8fbe908b">&#9670;&nbsp;</a></span>table_cache_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8 ha_ndbcluster::table_cache_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Type of table for caching query </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">handler</a>.</p>

</div>
</div>
<a id="a99dc30c67efa4a7d6d6f3ded9a67b40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dc30c67efa4a7d6d6f3ded9a67b40b">&#9670;&nbsp;</a></span>table_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong ha_ndbcluster::table_flags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">To maximize join pushability we want const-table optimization blocked if 'ndb_join_pushdown= on'</p>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a id="a96d160419836ac20e131570a32e1c4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d160419836ac20e131570a32e1c4a8">&#9670;&nbsp;</a></span>table_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ha_ndbcluster::table_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">The following can be called without an open handler </p>

<p>Implements <a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">handler</a>.</p>

</div>
</div>
<a id="aecef434c45b2c6c35a584274c5079e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecef434c45b2c6c35a584274c5079e4b">&#9670;&nbsp;</a></span>unlock_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ha_ndbcluster::unlock_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Unlock the last row read in an open scan. Rows are unlocked by default in ndb, but for SELECT FOR UPDATE and SELECT LOCK WIT SHARE MODE locks are kept if <a class="el" href="classha__ndbcluster.html#aecef434c45b2c6c35a584274c5079e4b">unlock_row()</a> is not called. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae2bd9470fe7beb5dc3481654718f39b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bd9470fe7beb5dc3481654718f39b7">&#9670;&nbsp;</a></span>ndbcluster_commit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ndbcluster_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>hton</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Commit a transaction started in NDB. </p>

</div>
</div>
<a id="a81d2867500d8a5c574e4e22d1b407d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d2867500d8a5c574e4e22d1b407d80">&#9670;&nbsp;</a></span>ndbcluster_drop_database_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ndbcluster_drop_database_impl </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Drop a database in NDB Cluster</p>
<dl class="section note"><dt>Note</dt><dd>add a dummy void function, since stupid handlerton is returning void instead of int... </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ha__ndbcluster_8h_source.html">ha_ndbcluster.h</a></li>
<li>ha_ndb_ddl_fk.cc</li>
<li>ha_ndb_index_stat.cc</li>
<li><a class="el" href="ha__ndbcluster_8cc.html">ha_ndbcluster.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
