<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: st_position Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structst__position-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">st_position Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sql__select_8h_source.html">sql_select.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for st_position:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structst__position.png" usemap="#st_5Fposition_map" alt=""/>
  <map id="st_5Fposition_map" name="st_5Fposition_map">
<area href="classSql__alloc.html" alt="Sql_alloc" shape="rect" coords="0,0,71,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ebb88c3230d471f89bda02de12f62e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#a2ebb88c3230d471f89bda02de12f62e6">no_semijoin</a> ()</td></tr>
<tr class="separator:a2ebb88c3230d471f89bda02de12f62e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa317ac2b3fa373e6c8f9a1a02c2e2754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#aa317ac2b3fa373e6c8f9a1a02c2e2754">set_prefix_cost</a> (double cost, double rowcount)</td></tr>
<tr class="separator:aa317ac2b3fa373e6c8f9a1a02c2e2754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3077a39535d27d819e8e027e22905840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#a3077a39535d27d819e8e027e22905840">set_prefix_join_cost</a> (uint idx, const <a class="el" href="classCost__model__server.html">Cost_model_server</a> *cm)</td></tr>
<tr class="separator:a3077a39535d27d819e8e027e22905840"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa38b3dcf630fb252f9eae43cb1d8a847"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#aa38b3dcf630fb252f9eae43cb1d8a847">rows_fetched</a></td></tr>
<tr class="separator:aa38b3dcf630fb252f9eae43cb1d8a847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455bdd05662b3e0e7670501bf0788cdd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#a455bdd05662b3e0e7670501bf0788cdd">read_cost</a></td></tr>
<tr class="separator:a455bdd05662b3e0e7670501bf0788cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d5d5e5b65710d3a1a1ae38b14f44de"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#af2d5d5e5b65710d3a1a1ae38b14f44de">filter_effect</a></td></tr>
<tr class="separator:af2d5d5e5b65710d3a1a1ae38b14f44de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29ae7911f9cc07153c57c5bc9ff9617"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#aa29ae7911f9cc07153c57c5bc9ff9617">prefix_rowcount</a></td></tr>
<tr class="separator:aa29ae7911f9cc07153c57c5bc9ff9617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c9d2de2a7041516158ed42a97ce35b"><td class="memItemLeft" align="right" valign="top"><a id="af0c9d2de2a7041516158ed42a97ce35b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>prefix_cost</b></td></tr>
<tr class="separator:af0c9d2de2a7041516158ed42a97ce35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b8a06d0137c8109d4798f9f4ecdc78"><td class="memItemLeft" align="right" valign="top"><a id="a47b8a06d0137c8109d4798f9f4ecdc78"></a>
<a class="el" href="classJOIN__TAB.html">JOIN_TAB</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table</b></td></tr>
<tr class="separator:a47b8a06d0137c8109d4798f9f4ecdc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8ce81ce1aaae66efabc4bef2f53f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#a5d8ce81ce1aaae66efabc4bef2f53f4e">key</a></td></tr>
<tr class="separator:a5d8ce81ce1aaae66efabc4bef2f53f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adedeafc969f1754149c722665d64c0"><td class="memItemLeft" align="right" valign="top">table_map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#a0adedeafc969f1754149c722665d64c0">ref_depend_map</a></td></tr>
<tr class="separator:a0adedeafc969f1754149c722665d64c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f00683cab5fe2cfd4aaa45a2a5a7710"><td class="memItemLeft" align="right" valign="top"><a id="a6f00683cab5fe2cfd4aaa45a2a5a7710"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_join_buffer</b></td></tr>
<tr class="separator:a6f00683cab5fe2cfd4aaa45a2a5a7710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27ba77e3972eeb713a371d38657ce1f"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#ab27ba77e3972eeb713a371d38657ce1f">sj_strategy</a></td></tr>
<tr class="separator:ab27ba77e3972eeb713a371d38657ce1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9fd7ef4d5fb77a167a68bd46f7b159"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#afa9fd7ef4d5fb77a167a68bd46f7b159">n_sj_tables</a></td></tr>
<tr class="separator:afa9fd7ef4d5fb77a167a68bd46f7b159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd4650de7dfd57c330261f9a0b583fe"><td class="memItemLeft" align="right" valign="top">table_map&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structst__position.html#a1dd4650de7dfd57c330261f9a0b583fe">dups_producing_tables</a></td></tr>
<tr class="separator:a1dd4650de7dfd57c330261f9a0b583fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75bf24712a71313fdf9e130b8bce644"><td class="memItemLeft" align="right" valign="top"><a id="ad75bf24712a71313fdf9e130b8bce644"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>first_loosescan_table</b></td></tr>
<tr class="separator:ad75bf24712a71313fdf9e130b8bce644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd3ebf9fc563bfac1983f97a97bc81f"><td class="memItemLeft" align="right" valign="top"><a id="a8cd3ebf9fc563bfac1983f97a97bc81f"></a>
table_map&#160;</td><td class="memItemRight" valign="bottom"><b>loosescan_need_tables</b></td></tr>
<tr class="separator:a8cd3ebf9fc563bfac1983f97a97bc81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7959094b0551189f17496b4318dfad"><td class="memItemLeft" align="right" valign="top"><a id="a0f7959094b0551189f17496b4318dfad"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>loosescan_key</b></td></tr>
<tr class="separator:a0f7959094b0551189f17496b4318dfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53c4c03bf2a7962e65bcfd0c1d549db"><td class="memItemLeft" align="right" valign="top"><a id="ac53c4c03bf2a7962e65bcfd0c1d549db"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>loosescan_parts</b></td></tr>
<tr class="separator:ac53c4c03bf2a7962e65bcfd0c1d549db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2143e25acde96767b338afe1b71f665"><td class="memItemLeft" align="right" valign="top"><a id="aa2143e25acde96767b338afe1b71f665"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>first_firstmatch_table</b></td></tr>
<tr class="separator:aa2143e25acde96767b338afe1b71f665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2250a6e56fb9822a536464bca7120009"><td class="memItemLeft" align="right" valign="top"><a id="a2250a6e56fb9822a536464bca7120009"></a>
table_map&#160;</td><td class="memItemRight" valign="bottom"><b>first_firstmatch_rtbl</b></td></tr>
<tr class="separator:a2250a6e56fb9822a536464bca7120009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e6ad52f286351f2d69b0d1fbe617a9"><td class="memItemLeft" align="right" valign="top"><a id="aa2e6ad52f286351f2d69b0d1fbe617a9"></a>
table_map&#160;</td><td class="memItemRight" valign="bottom"><b>firstmatch_need_tables</b></td></tr>
<tr class="separator:aa2e6ad52f286351f2d69b0d1fbe617a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b28c9f1b98b4338553fcb9fa9edffd3"><td class="memItemLeft" align="right" valign="top"><a id="a6b28c9f1b98b4338553fcb9fa9edffd3"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>first_dupsweedout_table</b></td></tr>
<tr class="separator:a6b28c9f1b98b4338553fcb9fa9edffd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a23435c5b2e6092c2a76d9b1f663746"><td class="memItemLeft" align="right" valign="top"><a id="a8a23435c5b2e6092c2a76d9b1f663746"></a>
table_map&#160;</td><td class="memItemRight" valign="bottom"><b>dupsweedout_tables</b></td></tr>
<tr class="separator:a8a23435c5b2e6092c2a76d9b1f663746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49de59eed736027891007e7ff05dea00"><td class="memItemLeft" align="right" valign="top"><a id="a49de59eed736027891007e7ff05dea00"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>sjm_scan_last_inner</b></td></tr>
<tr class="separator:a49de59eed736027891007e7ff05dea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ccfdf00818485fa9230b73c827a6d6"><td class="memItemLeft" align="right" valign="top"><a id="a10ccfdf00818485fa9230b73c827a6d6"></a>
table_map&#160;</td><td class="memItemRight" valign="bottom"><b>sjm_scan_need_tables</b></td></tr>
<tr class="separator:a10ccfdf00818485fa9230b73c827a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classSql__alloc"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSql__alloc')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSql__alloc.html">Sql_alloc</a></td></tr>
<tr class="memitem:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a193100cab44074df6f4f1507b333dcda"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t size)  throw ()</td></tr>
<tr class="separator:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a14b17bd7ec22fc7a7e5b56702e5630a6"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t size)  throw ()</td></tr>
<tr class="separator:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a13f2eacbb6adcee5c9ac94629e2863b3"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t size, MEM_ROOT *mem_root)  throw ()</td></tr>
<tr class="separator:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a06adbd3404f702994fd10619c41267f0"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t size, MEM_ROOT *mem_root)  throw ()</td></tr>
<tr class="separator:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a1e428ed5b826482a49b1d8a1d246a579"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t size)</td></tr>
<tr class="separator:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a7c08622003a34134a56eccaf2d95c0b9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="ab0c7ed4b5a1eb798f3af463eb84b1e3b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a6dd86b56cecc3919504cf5e1452f2511"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, size_t size)</td></tr>
<tr class="separator:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">A position of table within a join order. This structure is primarily used as a part of join-&gt;positions and join-&gt;best_positions arrays.</p>
<p class="">One POSITION element contains information about:</p><ul>
<li>Which table is accessed</li>
<li>Which access method was chosen = Its cost and #of output records</li>
<li>Semi-join strategy choice. Note that there are two different representation formats:<ol type="1">
<li>The one used during join optimization</li>
<li>The one used at plan refinement/code generation stage. We call fix_semijoin_strategies_for_picked_join_order() to switch between #1 and #2. See that function's comment for more details.</li>
</ol>
</li>
<li>Semi-join optimization state. When we're running join optimization, we main a state for every semi-join strategy which are various variables that tell us if/at which point we could consider applying the strategy. <br />
 The variables are really a function of join prefix but they are too expensive to re-caclulate for every join prefix we consider, so we maintain current state in join-&gt;positions[#tables_in_prefix]. See advance_sj_state() for details.</li>
</ul>
<p class="">This class has to stay a POD, because it is memcpy'd in many places. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ebb88c3230d471f89bda02de12f62e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebb88c3230d471f89bda02de12f62e6">&#9670;&nbsp;</a></span>no_semijoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void st_position::no_semijoin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Even if the query has no semijoin, two sj-related members are read and must thus have been set, by this function. </p>

</div>
</div>
<a id="aa317ac2b3fa373e6c8f9a1a02c2e2754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa317ac2b3fa373e6c8f9a1a02c2e2754">&#9670;&nbsp;</a></span>set_prefix_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void st_position::set_prefix_cost </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rowcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Set complete estimated cost and produced rowcount for the prefix of tables up to and including this table, in the join plan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cost</td><td>Estimated cost </td></tr>
    <tr><td class="paramname">rowcount</td><td>Estimated row count </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3077a39535d27d819e8e027e22905840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3077a39535d27d819e8e027e22905840">&#9670;&nbsp;</a></span>set_prefix_join_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void st_position::set_prefix_join_cost </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCost__model__server.html">Cost_model_server</a> *&#160;</td>
          <td class="paramname"><em>cm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Set complete estimated cost and produced rowcount for the prefix of tables up to and including this table, calculated from the cost of the previous stage, the fanout of the current stage and the cost to process a row at the current stage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index of position object within array, if zero there is no "previous" stage that can be added. </td></tr>
    <tr><td class="paramname">cm</td><td>Cost model that provides the actual calculation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1dd4650de7dfd57c330261f9a0b583fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd4650de7dfd57c330261f9a0b583fe">&#9670;&nbsp;</a></span>dups_producing_tables</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">table_map st_position::dups_producing_tables</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class=""><a class="el" href="classBitmap.html">Bitmap</a> of semi-join inner tables that are in the join prefix and for which there's no provision yet for how to eliminate semi-join duplicates which they produce. </p>

</div>
</div>
<a id="af2d5d5e5b65710d3a1a1ae38b14f44de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d5d5e5b65710d3a1a1ae38b14f44de">&#9670;&nbsp;</a></span>filter_effect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float st_position::filter_effect</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The fraction of the 'rows_fetched' rows that will pass the table conditions that were NOT used by the access method. If, e.g.,</p>
<p class="">"SELECT ... WHERE t1.colx = 4 and t1.coly &gt; 5"</p>
<p class="">is resolved by ref access on t1.colx, filter_effect will be the fraction of rows that will pass the "t1.coly &gt; 5" predicate. The valid range is 0..1, where 0.0 means that no rows will pass the table conditions and 1.0 means that all rows will pass.</p>
<p class="">It is used to calculate how many row combinations will be joined with the next table, </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structst__position.html#aa29ae7911f9cc07153c57c5bc9ff9617">prefix_rowcount</a> below.</dd></dl>
<p>that with condition filtering enabled, it is possible to get a fanout = rows_fetched * filter_effect that is less than 1.0. Consider, e.g., a join between t1 and t2:</p>
<p class="">"SELECT ... WHERE t1.col1=t2.colx and t2.coly OP &lt;something&gt;"</p>
<p class="">where t1 is a prefix table and the optimizer currently calculates the cost of adding t2 to the join. Assume that the chosen access method on t2 is a 'ref' access on 'colx' that is estimated to produce 2 rows per row from t1 (i.e., rows_fetched = 2). It will in this case be perfectly fine to calculate a filtering effect &lt;0.5 (resulting in "rows_fetched * filter_effect &lt; 1.0") from the predicate "t2.coly OP &lt;something&gt;". If so, the number of row combinations from (t1,t2) is lower than the prefix_rowcount of t1.</p>
<p class="">The above is just an example of how the fanout of a table can become less than one. It can happen for any access method. </p>

</div>
</div>
<a id="a5d8ce81ce1aaae66efabc4bef2f53f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8ce81ce1aaae66efabc4bef2f53f4e">&#9670;&nbsp;</a></span>key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKey__use.html">Key_use</a>* st_position::key</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">NULL - 'index' or 'range' or 'index_merge' or 'ALL' access is used. Other - [eq_]ref[_or_null] access is used. Pointer to {t.keypart1 = expr} </p>

</div>
</div>
<a id="afa9fd7ef4d5fb77a167a68bd46f7b159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9fd7ef4d5fb77a167a68bd46f7b159">&#9670;&nbsp;</a></span>n_sj_tables</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint st_position::n_sj_tables</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Valid only after fix_semijoin_strategies_for_picked_join_order() call: if sj_strategy!=SJ_OPT_NONE, this is the number of subsequent tables that are covered by the specified semi-join strategy </p>

</div>
</div>
<a id="aa29ae7911f9cc07153c57c5bc9ff9617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29ae7911f9cc07153c57c5bc9ff9617">&#9670;&nbsp;</a></span>prefix_rowcount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double st_position::prefix_rowcount</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">prefix_rowcount and prefix_cost form a stack of partial join order costs and output sizes</p>
<p class="">prefix_rowcount: The number of row combinations that will be joined to the next table in the join sequence.</p>
<p class="">For a joined table it is calculated as prefix_rowcount = last_table.prefix_rowcount * rows_fetched * filter_effect</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structst__position.html#af2d5d5e5b65710d3a1a1ae38b14f44de">filter_effect</a></dd></dl>
<p>For a semijoined table it may be less than this formula due to duplicate elimination. </p>

</div>
</div>
<a id="a455bdd05662b3e0e7670501bf0788cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455bdd05662b3e0e7670501bf0788cdd">&#9670;&nbsp;</a></span>read_cost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double st_position::read_cost</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Cost of accessing the table in course of the entire complete join execution, i.e. cost of one access method use (e.g. 'range' or 'ref' scan ) multiplied by estimated number of rows from tables earlier in the join sequence.</p>
<p class="">read_cost does NOT include cost of processing rows within the executor (row_evaluate_cost). </p>

</div>
</div>
<a id="a0adedeafc969f1754149c722665d64c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0adedeafc969f1754149c722665d64c0">&#9670;&nbsp;</a></span>ref_depend_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">table_map st_position::ref_depend_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">If ref-based access is used: bitmap of tables this table depends on </p>

</div>
</div>
<a id="aa38b3dcf630fb252f9eae43cb1d8a847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38b3dcf630fb252f9eae43cb1d8a847">&#9670;&nbsp;</a></span>rows_fetched</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double st_position::rows_fetched</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">The number of rows that will be fetched by the chosen access method per each row combination of previous tables. That is:</p>
<p class="">rows_fetched = selectivity(access_condition) * cardinality(table)</p>
<p class="">where 'access_condition' is whatever condition was chosen for index access, depending on the access method ('ref', 'range', etc.)</p>
<p class="">that for index/table scans, rows_fetched may be less than the number of rows in the table because the cost of evaluating constant conditions is included in the scan cost, and the number of rows produced by these scans is the estimated number of rows that pass the constant conditions. </p><dl class="section see"><dt>See also</dt><dd>Optimize_table_order::calculate_scan_cost() . But this is only during planning; <a class="el" href="group__Query__Optimizer.html#ga27b74179b9a9207753aa3f93a9df4225">make_join_readinfo()</a> simplifies it for EXPLAIN. </dd></dl>

</div>
</div>
<a id="ab27ba77e3972eeb713a371d38657ce1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27ba77e3972eeb713a371d38657ce1f">&#9670;&nbsp;</a></span>sj_strategy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint st_position::sj_strategy</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Current optimization state: Semi-join strategy to be used for this and preceding join tables.</p>
<p class="">Join optimizer sets this for the <em>last</em> join_tab in the duplicate-generating range. That is, in order to interpret this field, one needs to traverse join-&gt;[best_]positions array from right to left. When you see a join table with sj_strategy!= SJ_OPT_NONE, some other field (depending on the strategy) tells how many preceding positions this applies to. The values of covered_preceding_positions-&gt;sj_strategy must be ignored. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="sql__select_8h_source.html">sql_select.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
