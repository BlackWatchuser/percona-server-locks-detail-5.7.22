<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Inplace_vector&lt; objtype, array_size &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classInplace__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Inplace_vector&lt; objtype, array_size &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="inplace__vector_8h_source.html">inplace_vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6b7fedc5f8da2eca1e16ba8b22a2edae"><td class="memItemLeft" align="right" valign="top"><a id="a6b7fedc5f8da2eca1e16ba8b22a2edae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Inplace_vector</b> (PSI_memory_key psi_key)</td></tr>
<tr class="separator:a6b7fedc5f8da2eca1e16ba8b22a2edae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82912dffa04001608197c02d330e7cd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a82912dffa04001608197c02d330e7cd1">~Inplace_vector</a> ()</td></tr>
<tr class="separator:a82912dffa04001608197c02d330e7cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798bedb62927bc1f6817fe32ad12c990"><td class="memItemLeft" align="right" valign="top">objtype *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a798bedb62927bc1f6817fe32ad12c990">get_object</a> (size_t index)</td></tr>
<tr class="separator:a798bedb62927bc1f6817fe32ad12c990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b6fa9a44962ce82429772108446eb7"><td class="memItemLeft" align="right" valign="top">objtype *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#af9b6fa9a44962ce82429772108446eb7">append_object</a> ()</td></tr>
<tr class="separator:af9b6fa9a44962ce82429772108446eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5dd81d586f94279698ee31c496bcc2"><td class="memItemLeft" align="right" valign="top">objtype *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a4f5dd81d586f94279698ee31c496bcc2">push_back</a> (const objtype &amp;obj)</td></tr>
<tr class="separator:a4f5dd81d586f94279698ee31c496bcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2785143f15f621c9d9ddf53e2b5e136c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a2785143f15f621c9d9ddf53e2b5e136c">resize</a> (size_t new_size, const objtype &amp;val=objtype())</td></tr>
<tr class="separator:a2785143f15f621c9d9ddf53e2b5e136c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24e13ea5106489e799fe97512227da0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#aa24e13ea5106489e799fe97512227da0">size</a> () const</td></tr>
<tr class="separator:aa24e13ea5106489e799fe97512227da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7413b782c30385c34355aa8845c2d00f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a7413b782c30385c34355aa8845c2d00f">capacity</a> () const</td></tr>
<tr class="separator:a7413b782c30385c34355aa8845c2d00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611ca3f3274eab27b302cb0e0b06e83c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a611ca3f3274eab27b302cb0e0b06e83c">empty</a> () const</td></tr>
<tr class="separator:a611ca3f3274eab27b302cb0e0b06e83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cc6a796c6d07205f2436c357bc1a0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a64cc6a796c6d07205f2436c357bc1a0d">clear</a> ()</td></tr>
<tr class="separator:a64cc6a796c6d07205f2436c357bc1a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8cb3ab1ea491f3466c90be7db6cd25"><td class="memItemLeft" align="right" valign="top">const objtype &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#acf8cb3ab1ea491f3466c90be7db6cd25">back</a> () const</td></tr>
<tr class="separator:acf8cb3ab1ea491f3466c90be7db6cd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1181edc4a42cd2200af2c30c8295a200"><td class="memItemLeft" align="right" valign="top">objtype &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a1181edc4a42cd2200af2c30c8295a200">back</a> ()</td></tr>
<tr class="separator:a1181edc4a42cd2200af2c30c8295a200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ba1102132980fa0ddbf93a08c7ba03"><td class="memItemLeft" align="right" valign="top">const objtype &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a00ba1102132980fa0ddbf93a08c7ba03">operator[]</a> (size_t i) const</td></tr>
<tr class="separator:a00ba1102132980fa0ddbf93a08c7ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a67f2bea4e841845b5fbea271ecf03d"><td class="memItemLeft" align="right" valign="top">objtype &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a8a67f2bea4e841845b5fbea271ecf03d">operator[]</a> (size_t i)</td></tr>
<tr class="separator:a8a67f2bea4e841845b5fbea271ecf03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b8bdc0d5103bda8b03c5e9062be118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInplace__vector.html#a27b8bdc0d5103bda8b03c5e9062be118">delete_all_objects</a> ()</td></tr>
<tr class="separator:a27b8bdc0d5103bda8b03c5e9062be118"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename objtype, size_t array_size = 16&gt;<br />
class Inplace_vector&lt; objtype, array_size &gt;</h3>

<p class="">Utility container class to store elements stably and scalably. The address of an element stored in the container is stable as long as the object is alive, no object is copy-constructed/reassigned by push_back operations once it's stored into this container. And users of such containers can* assign to elements stored in the container just like using std::vector.</p>
<p class="">It is similar to STL vector but it is uniquely suitable in below situation: whenever stable element address, or element copy construction/assignement behaviors are forbidden. It only has a limited subset of the std::vector interface, and especially it doesn't have an iterator interface or element elimination interface, we don't need them for now. And this container is not multi-threading safe. It uses my_malloc/my_free to allocate/free memory arrays and caller can pass PSI key.</p>
<p class="">The container keeps a collection of arrays, each of which has a fixed NO. of slots to store elements. When one array is full, another is appended. When the vector shrinks at tail, useless arrays are removed and its memory space released.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">objtype</td><td>The type of the elements to store. </td></tr>
    <tr><td class="paramname">array_size</td><td>The NO. of element slots in each array. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a82912dffa04001608197c02d330e7cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82912dffa04001608197c02d330e7cd1">&#9670;&nbsp;</a></span>~Inplace_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::~<a class="el" href="classInplace__vector.html">Inplace_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Release memory space and destroy all contained objects. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af9b6fa9a44962ce82429772108446eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b6fa9a44962ce82429772108446eb7">&#9670;&nbsp;</a></span>append_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objtype* <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::append_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Allocate space for an object, and construct it using its default constructor, and return its address. </p><dl class="section return"><dt>Returns</dt><dd>the appended object's address; NULL if out of memory. </dd></dl>

</div>
</div>
<a id="acf8cb3ab1ea491f3466c90be7db6cd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8cb3ab1ea491f3466c90be7db6cd25">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const objtype&amp; <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::back interface. </p><dl class="section return"><dt>Returns</dt><dd>the reference of the last object stored in the vector. </dd></dl>

</div>
</div>
<a id="a1181edc4a42cd2200af2c30c8295a200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1181edc4a42cd2200af2c30c8295a200">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objtype&amp; <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::back interface. </p><dl class="section return"><dt>Returns</dt><dd>the reference of the last object stored in the vector. </dd></dl>

</div>
</div>
<a id="a7413b782c30385c34355aa8845c2d00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7413b782c30385c34355aa8845c2d00f">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::capacity interface. </p><dl class="section return"><dt>Returns</dt><dd>the max number of element that can be stored into this vector without growing its size. </dd></dl>

</div>
</div>
<a id="a64cc6a796c6d07205f2436c357bc1a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cc6a796c6d07205f2436c357bc1a0d">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::clear interface. Destroy all elements (by calling each element's destructor) stored in the vector, and then release all memory held by it. </p>

</div>
</div>
<a id="a27b8bdc0d5103bda8b03c5e9062be118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b8bdc0d5103bda8b03c5e9062be118">&#9670;&nbsp;</a></span>delete_all_objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::delete_all_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Destroy all elements (by calling each element's destructor) stored in the vector, and then release all memory held by it. </p>

</div>
</div>
<a id="a611ca3f3274eab27b302cb0e0b06e83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611ca3f3274eab27b302cb0e0b06e83c">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::empty interface. </p><dl class="section return"><dt>Returns</dt><dd>whether <a class="el" href="classInplace__vector.html#aa24e13ea5106489e799fe97512227da0">size()</a> == 0. </dd></dl>

</div>
</div>
<a id="a798bedb62927bc1f6817fe32ad12c990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798bedb62927bc1f6817fe32ad12c990">&#9670;&nbsp;</a></span>get_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objtype* <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::get_object </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get an existing element's pointer, index must be in [0, m_obj_count). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the element to return. It must be within valid in-use range of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element address specified by index; NULL if out of memory. </dd></dl>

</div>
</div>
<a id="a00ba1102132980fa0ddbf93a08c7ba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ba1102132980fa0ddbf93a08c7ba03">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const objtype&amp; <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::operator[] interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element to return. It must be within valid in-use range of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element reference specified by index. </dd></dl>

</div>
</div>
<a id="a8a67f2bea4e841845b5fbea271ecf03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a67f2bea4e841845b5fbea271ecf03d">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objtype&amp; <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::operator[] interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element to return. It must be within valid in-use range of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element reference specified by index. </dd></dl>

</div>
</div>
<a id="a4f5dd81d586f94279698ee31c496bcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5dd81d586f94279698ee31c496bcc2">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">objtype* <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const objtype &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::push_back interface. It's guaranteed that existing elements stored in the vector is never copy constructed/reassigned by this operation. When the last element array is full, a new one is allocated and tracked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The element to store into the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The appended object stored in the container; NULL if out of memory. </dd></dl>

</div>
</div>
<a id="a2785143f15f621c9d9ddf53e2b5e136c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2785143f15f621c9d9ddf53e2b5e136c">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const objtype &amp;&#160;</td>
          <td class="paramname"><em>val</em> = <code>objtype()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::resize interface. Has identical behavior as STL std::vector::resize except that no element copy construction or reassignment is ever caused by this operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>default value assigned to extended slots in the vector. Unused if the vector is shrinked. We have to define a const reference instead of passing by value because MSVC on 32bit Windows doesn't allow formal parameter to have alignment specification (error C2719) as defined in my_aligned_storage but in <a class="el" href="structGeometry__buffer.html">Geometry_buffer</a> and potentially more classes in future, we do use alignement specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if out of memory; false if successful. </dd></dl>

</div>
</div>
<a id="aa24e13ea5106489e799fe97512227da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e13ea5106489e799fe97512227da0">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename objtype, size_t array_size = 16&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classInplace__vector.html">Inplace_vector</a>&lt; objtype, array_size &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">STL std::vector::size interface. </p><dl class="section return"><dt>Returns</dt><dd>the number of elements effectively stored in the vector. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="inplace__vector_8h_source.html">inplace_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
