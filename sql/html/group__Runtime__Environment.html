<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Runtime Environment</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Runtime Environment</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__Event__Scheduler"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event__Scheduler.html">Event Scheduler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__Stored__Routines"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Stored__Routines.html">Stored Routines</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKill__non__super__conn.html">Kill_non_super_conn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser__oom__handler.html">Parser_oom_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaad46f86d310fd4da9b8b2fa93068c4a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SP_COM_STRING</b>(LP)</td></tr>
<tr class="separator:gaad46f86d310fd4da9b8b2fa93068c4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a8b65ae940ccbcd0665dae441270e7"><td class="memItemLeft" align="right" valign="top"><a id="gab5a8b65ae940ccbcd0665dae441270e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>used_stack</b>(A,  B)&#160;&#160;&#160;(long) (B - A)</td></tr>
<tr class="separator:gab5a8b65ae940ccbcd0665dae441270e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d1ba6753fe093a35ab0c87ab118b8a"><td class="memItemLeft" align="right" valign="top"><a id="ga08d1ba6753fe093a35ab0c87ab118b8a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MY_YACC_INIT</b>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:ga08d1ba6753fe093a35ab0c87ab118b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ed848262f0f56a57d1e07c0d4878c3"><td class="memItemLeft" align="right" valign="top"><a id="ga42ed848262f0f56a57d1e07c0d4878c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MY_YACC_MAX</b>&#160;&#160;&#160;32000</td></tr>
<tr class="separator:ga42ed848262f0f56a57d1e07c0d4878c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga28dd9a1a616e1e1855b482ab1346f18e"><td class="memItemLeft" align="right" valign="top"><a id="ga28dd9a1a616e1e1855b482ab1346f18e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>some_non_temp_table_to_be_updated</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr class="separator:ga28dd9a1a616e1e1855b482ab1346f18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2f693556d7e6b0d1cf38ad801ae51c"><td class="memItemLeft" align="right" valign="top"><a id="ga4c2f693556d7e6b0d1cf38ad801ae51c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>stmt_causes_implicit_commit</b> (const THD *thd, uint mask)</td></tr>
<tr class="separator:ga4c2f693556d7e6b0d1cf38ad801ae51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e3f222a46f347db65d19bd17941286"><td class="memItemLeft" align="right" valign="top"><a id="ga50e3f222a46f347db65d19bd17941286"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_update_queries</b> (void)</td></tr>
<tr class="separator:ga50e3f222a46f347db65d19bd17941286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5544094e643119252380d39ac8cd2efa"><td class="memItemLeft" align="right" valign="top"><a id="ga5544094e643119252380d39ac8cd2efa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sqlcom_can_generate_row_events</b> (enum enum_sql_command command)</td></tr>
<tr class="separator:ga5544094e643119252380d39ac8cd2efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd6cd553a8c7199f9ab84c0f72871177"><td class="memItemLeft" align="right" valign="top"><a id="gacd6cd553a8c7199f9ab84c0f72871177"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_update_query</b> (enum enum_sql_command command)</td></tr>
<tr class="separator:gacd6cd553a8c7199f9ab84c0f72871177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b1b314a012674325f76ce371614df4d"><td class="memItemLeft" align="right" valign="top"><a id="ga4b1b314a012674325f76ce371614df4d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_explainable_query</b> (enum enum_sql_command command)</td></tr>
<tr class="separator:ga4b1b314a012674325f76ce371614df4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eaa146f67e2bd9604ec2ec0645ba81c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga1eaa146f67e2bd9604ec2ec0645ba81c">is_log_table_write_query</a> (enum enum_sql_command command)</td></tr>
<tr class="separator:ga1eaa146f67e2bd9604ec2ec0645ba81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e39fc20b643c491433d588e0cc1c0e"><td class="memItemLeft" align="right" valign="top"><a id="ga10e39fc20b643c491433d588e0cc1c0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>execute_init_command</b> (THD *thd, LEX_STRING *init_command, mysql_rwlock_t *var_lock)</td></tr>
<tr class="separator:ga10e39fc20b643c491433d588e0cc1c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ca455b4e3e525a662ef572d60f9290"><td class="memItemLeft" align="right" valign="top"><a id="gaf3ca455b4e3e525a662ef572d60f9290"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_items</b> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:gaf3ca455b4e3e525a662ef572d60f9290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7bccb54271a0546d92f2bc732abf3d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaf7bccb54271a0546d92f2bc732abf3d1">cleanup_items</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:gaf7bccb54271a0546d92f2bc732abf3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331df424a7892fbbad536f0f3a7b18f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga331df424a7892fbbad536f0f3a7b18f6">do_command</a> (THD *thd)</td></tr>
<tr class="separator:ga331df424a7892fbbad536f0f3a7b18f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3632047b55b1b225c609f0f9ff46250a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga3632047b55b1b225c609f0f9ff46250a">reset_statement_timer</a> (THD *thd)</td></tr>
<tr class="separator:ga3632047b55b1b225c609f0f9ff46250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf07206792036bfb47e5bb8eb0f20bc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gabf07206792036bfb47e5bb8eb0f20bc4">dispatch_command</a> (THD *thd, const COM_DATA *com_data, enum enum_server_command command)</td></tr>
<tr class="separator:gabf07206792036bfb47e5bb8eb0f20bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e1f9234a9969980b924de2e3fe487d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga12e1f9234a9969980b924de2e3fe487d">shutdown</a> (THD *thd, enum mysql_enum_shutdown_level level, enum enum_server_command command)</td></tr>
<tr class="separator:ga12e1f9234a9969980b924de2e3fe487d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5de0e97014b9b2e757a145f30eb7efb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaa5de0e97014b9b2e757a145f30eb7efb">prepare_schema_table</a> (THD *thd, LEX *lex, Table_ident *table_ident, enum enum_schema_tables schema_table_idx)</td></tr>
<tr class="separator:gaa5de0e97014b9b2e757a145f30eb7efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3573b4adc788a4eeddbf6d1cb12582"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga8b3573b4adc788a4eeddbf6d1cb12582">alloc_query</a> (THD *thd, const char *packet, size_t packet_length)</td></tr>
<tr class="separator:ga8b3573b4adc788a4eeddbf6d1cb12582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd6de1ff28f3b8c16300a74d412b3b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gabbd6de1ff28f3b8c16300a74d412b3b3">lock_binlog_for_backup</a> (THD *thd)</td></tr>
<tr class="separator:gabbd6de1ff28f3b8c16300a74d412b3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7751d9816645a7a68e879596ee7e558"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gac7751d9816645a7a68e879596ee7e558">mysql_execute_command</a> (THD *thd, bool first_level)</td></tr>
<tr class="separator:gac7751d9816645a7a68e879596ee7e558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a660aa2196395412bc0c5c8e7baa33a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga9a660aa2196395412bc0c5c8e7baa33a">check_stack_overrun</a> (THD *thd, long margin, uchar *buf MY_ATTRIBUTE((unused)))</td></tr>
<tr class="separator:ga9a660aa2196395412bc0c5c8e7baa33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga575f30fef70f57d45123b418f7a14efa"><td class="memItemLeft" align="right" valign="top"><a id="ga575f30fef70f57d45123b418f7a14efa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>my_yyoverflow</b> (short **yyss, YYSTYPE **yyvs, <a class="el" href="structYYLTYPE.html">YYLTYPE</a> **yyls, ulong *yystacksize)</td></tr>
<tr class="separator:ga575f30fef70f57d45123b418f7a14efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37db6950d3b6bc16bbbb2ae0484ae55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gab37db6950d3b6bc16bbbb2ae0484ae55">mysql_reset_thd_for_next_command</a> (THD *thd)</td></tr>
<tr class="separator:gab37db6950d3b6bc16bbbb2ae0484ae55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69775e9e669f55cbedb293c4498717b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gae69775e9e669f55cbedb293c4498717b">create_select_for_variable</a> (<a class="el" href="structParse__context.html">Parse_context</a> *pc, const char *var_name)</td></tr>
<tr class="separator:gae69775e9e669f55cbedb293c4498717b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga891266e258a6034e8f09a410bb4abe62"><td class="memItemLeft" align="right" valign="top"><a id="ga891266e258a6034e8f09a410bb4abe62"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mysql_init_multi_delete</b> (LEX *lex)</td></tr>
<tr class="separator:ga891266e258a6034e8f09a410bb4abe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81611063376e9fd7612c3ca78d16f70d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga81611063376e9fd7612c3ca78d16f70d">mysql_parse</a> (THD *thd, Parser_state *parser_state)</td></tr>
<tr class="separator:ga81611063376e9fd7612c3ca78d16f70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20dc4d55537ca52787813134e3639148"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga20dc4d55537ca52787813134e3639148">add_field_to_list</a> (THD *thd, LEX_STRING *field_name, enum_field_types type, char *length, char *decimals, uint type_modifier, <a class="el" href="classItem.html">Item</a> *default_value, <a class="el" href="classItem.html">Item</a> *on_update_value, LEX_STRING *comment, char *change, <a class="el" href="classList.html">List</a>&lt; String &gt; *interval_list, const CHARSET_INFO *cs, uint uint_geom_type, const LEX_CSTRING *zip_dict, <a class="el" href="classGenerated__column.html">Generated_column</a> *gcol_info)</td></tr>
<tr class="separator:ga20dc4d55537ca52787813134e3639148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22aec956c23a6f1e16aef7d9db67bc79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga22aec956c23a6f1e16aef7d9db67bc79">store_position_for_column</a> (const char *name)</td></tr>
<tr class="separator:ga22aec956c23a6f1e16aef7d9db67bc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8a136c5775459ea3a35a0c27fc6c06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga1d8a136c5775459ea3a35a0c27fc6c06">add_to_list</a> (<a class="el" href="classSQL__I__List.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; &amp;list, <a class="el" href="structst__order.html">ORDER</a> *order)</td></tr>
<tr class="separator:ga1d8a136c5775459ea3a35a0c27fc6c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa70b34c69515f56b1d43caa55824d5d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaa70b34c69515f56b1d43caa55824d5d5">add_join_natural</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *a, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *b, <a class="el" href="classList.html">List</a>&lt; String &gt; *using_fields, SELECT_LEX *lex)</td></tr>
<tr class="separator:gaa70b34c69515f56b1d43caa55824d5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba2822d159fb63e7b05d3e58a5cf7ad7"><td class="memItemLeft" align="right" valign="top"><a id="gaba2822d159fb63e7b05d3e58a5cf7ad7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>killall_non_super_threads</b> (THD *thd)</td></tr>
<tr class="separator:gaba2822d159fb63e7b05d3e58a5cf7ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09d8997f1551aefa58a28606ff68c6f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga09d8997f1551aefa58a28606ff68c6f5">append_file_to_dir</a> (THD *thd, const char **filename_ptr, const char *table_name)</td></tr>
<tr class="separator:ga09d8997f1551aefa58a28606ff68c6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4fc9496f4801d17398eed353847b8b9"><td class="memItemLeft" align="right" valign="top"><a id="gaf4fc9496f4801d17398eed353847b8b9"></a>
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_eq_creator</b> (bool invert)</td></tr>
<tr class="separator:gaf4fc9496f4801d17398eed353847b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97a387bf8e37aebe6cf8b7efb31b0db8"><td class="memItemLeft" align="right" valign="top"><a id="ga97a387bf8e37aebe6cf8b7efb31b0db8"></a>
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_equal_creator</b> (bool invert)</td></tr>
<tr class="separator:ga97a387bf8e37aebe6cf8b7efb31b0db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20931601222cda32e69fd3945f6626cc"><td class="memItemLeft" align="right" valign="top"><a id="ga20931601222cda32e69fd3945f6626cc"></a>
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_ge_creator</b> (bool invert)</td></tr>
<tr class="separator:ga20931601222cda32e69fd3945f6626cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f9fb67350b86979e8075ebf10ec3b2"><td class="memItemLeft" align="right" valign="top"><a id="ga39f9fb67350b86979e8075ebf10ec3b2"></a>
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_gt_creator</b> (bool invert)</td></tr>
<tr class="separator:ga39f9fb67350b86979e8075ebf10ec3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad219be929fb149f9ffa69224e8214834"><td class="memItemLeft" align="right" valign="top"><a id="gad219be929fb149f9ffa69224e8214834"></a>
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_le_creator</b> (bool invert)</td></tr>
<tr class="separator:gad219be929fb149f9ffa69224e8214834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5581721018ae2b9b655cefa8bacfb255"><td class="memItemLeft" align="right" valign="top"><a id="ga5581721018ae2b9b655cefa8bacfb255"></a>
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_lt_creator</b> (bool invert)</td></tr>
<tr class="separator:ga5581721018ae2b9b655cefa8bacfb255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83bec074d98c59c94c8b0f8631df6e5b"><td class="memItemLeft" align="right" valign="top"><a id="ga83bec074d98c59c94c8b0f8631df6e5b"></a>
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_ne_creator</b> (bool invert)</td></tr>
<tr class="separator:ga83bec074d98c59c94c8b0f8631df6e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac994ea735fa021334a4e3c9370af1bd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gac994ea735fa021334a4e3c9370af1bd3">all_any_subquery_creator</a> (<a class="el" href="classItem.html">Item</a> *left_expr, chooser_compare_func_creator cmp, bool all, SELECT_LEX *select_lex)</td></tr>
<tr class="separator:gac994ea735fa021334a4e3c9370af1bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95cca4e86f6c748bc34a5879ae0d36f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga95cca4e86f6c748bc34a5879ae0d36f4">create_table_set_open_action_and_adjust_tables</a> (LEX *lex)</td></tr>
<tr class="separator:ga95cca4e86f6c748bc34a5879ae0d36f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370cd1baacb8f9761d1f6caba0f01954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga370cd1baacb8f9761d1f6caba0f01954">negate_expression</a> (<a class="el" href="structParse__context.html">Parse_context</a> *pc, <a class="el" href="classItem.html">Item</a> *expr)</td></tr>
<tr class="separator:ga370cd1baacb8f9761d1f6caba0f01954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6109e9d93731678e792405018a30a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gae6109e9d93731678e792405018a30a24">get_default_definer</a> (THD *thd, <a class="el" href="structst__lex__user.html">LEX_USER</a> *definer)</td></tr>
<tr class="separator:gae6109e9d93731678e792405018a30a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba3e531f8d364506ca098138bd4b459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga8ba3e531f8d364506ca098138bd4b459">create_default_definer</a> (THD *thd)</td></tr>
<tr class="separator:ga8ba3e531f8d364506ca098138bd4b459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3317cfcf3ee5abca5accb1e77461ca56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga3317cfcf3ee5abca5accb1e77461ca56">get_current_user</a> (THD *thd, <a class="el" href="structst__lex__user.html">LEX_USER</a> *user)</td></tr>
<tr class="separator:ga3317cfcf3ee5abca5accb1e77461ca56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd668a5d759810bb2234bdab39aa840"><td class="memItemLeft" align="right" valign="top"><a id="gaffd668a5d759810bb2234bdab39aa840"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_string_char_length</b> (const LEX_CSTRING &amp;str, const char *err_msg, size_t max_char_length, const CHARSET_INFO *cs, bool no_error)</td></tr>
<tr class="separator:gaffd668a5d759810bb2234bdab39aa840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35590aeb74bdebbccac86b889a2cb7d1"><td class="memItemLeft" align="right" valign="top"><a id="ga35590aeb74bdebbccac86b889a2cb7d1"></a>
C_MODE_START int&#160;</td><td class="memItemRight" valign="bottom"><b>test_if_data_home_dir</b> (const char *dir)</td></tr>
<tr class="separator:ga35590aeb74bdebbccac86b889a2cb7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83c28ce3e415fe976a0d40cc4b4eef81"><td class="memItemLeft" align="right" valign="top">C_MODE_END bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga83c28ce3e415fe976a0d40cc4b4eef81">check_host_name</a> (const LEX_CSTRING &amp;str)</td></tr>
<tr class="separator:ga83c28ce3e415fe976a0d40cc4b4eef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064577e9942acfdd4ec6383b30792475"><td class="memItemLeft" align="right" valign="top"><a id="ga064577e9942acfdd4ec6383b30792475"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQLparse</b> (class THD *thd)</td></tr>
<tr class="separator:ga064577e9942acfdd4ec6383b30792475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb1400ab6d81b2c3eb496d66df4d7674"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gabb1400ab6d81b2c3eb496d66df4d7674">parse_sql</a> (THD *thd, Parser_state *parser_state, <a class="el" href="classObject__creation__ctx.html">Object_creation_ctx</a> *creation_ctx)</td></tr>
<tr class="separator:gabb1400ab6d81b2c3eb496d66df4d7674"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0fff36dbb3be1083486e5226dbe8267e"><td class="memItemLeft" align="right" valign="top"><a id="ga0fff36dbb3be1083486e5226dbe8267e"></a>
const LEX_STRING&#160;</td><td class="memItemRight" valign="bottom"><b>command_name</b> []</td></tr>
<tr class="separator:ga0fff36dbb3be1083486e5226dbe8267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b520658dfe2259770e9037c640d5399"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga2b520658dfe2259770e9037c640d5399">sql_command_flags</a> [SQLCOM_END+1]</td></tr>
<tr class="separator:ga2b520658dfe2259770e9037c640d5399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2a8fda5bafb784dd61891fb58c9274"><td class="memItemLeft" align="right" valign="top"><a id="gabb2a8fda5bafb784dd61891fb58c9274"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>server_command_flags</b> [COM_END+1]</td></tr>
<tr class="separator:gabb2a8fda5bafb784dd61891fb58c9274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga909f1c5c4bc6d72a01f18503b25d2e07"><td class="memItemLeft" align="right" valign="top"><a id="ga909f1c5c4bc6d72a01f18503b25d2e07"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>max_stack_used</b></td></tr>
<tr class="separator:ga909f1c5c4bc6d72a01f18503b25d2e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaad46f86d310fd4da9b8b2fa93068c4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad46f86d310fd4da9b8b2fa93068c4a0">&#9670;&nbsp;</a></span>SP_COM_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SP_COM_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LP</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((LP)-&gt;sql_command == SQLCOM_CREATE_SPFUNCTION || \</div><div class="line">   (LP)-&gt;sql_command == SQLCOM_ALTER_FUNCTION || \</div><div class="line">   (LP)-&gt;sql_command == SQLCOM_SHOW_CREATE_FUNC || \</div><div class="line">   (LP)-&gt;sql_command == SQLCOM_DROP_FUNCTION ? \</div><div class="line">   <span class="stringliteral">&quot;FUNCTION&quot;</span> : <span class="stringliteral">&quot;PROCEDURE&quot;</span>)</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga20dc4d55537ca52787813134e3639148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20dc4d55537ca52787813134e3639148">&#9670;&nbsp;</a></span>add_field_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool add_field_to_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_field_types&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>decimals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>type_modifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>on_update_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>change</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; String &gt; *&#160;</td>
          <td class="paramname"><em>interval_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHARSET_INFO *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>uint_geom_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LEX_CSTRING *&#160;</td>
          <td class="paramname"><em>zip_dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGenerated__column.html">Generated_column</a> *&#160;</td>
          <td class="paramname"><em>gcol_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Store field definition for create.</p>
<dl class="section return"><dt>Returns</dt><dd>Return 0 if ok </dd></dl>

</div>
</div>
<a id="gaa70b34c69515f56b1d43caa55824d5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa70b34c69515f56b1d43caa55824d5d5">&#9670;&nbsp;</a></span>add_join_natural()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_join_natural </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; String &gt; *&#160;</td>
          <td class="paramname"><em>using_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create a fake SELECT_LEX for a unit.</p>
<p class="">The method create a fake SELECT_LEX object for a unit. This object is created for any union construct containing a union operation and also for any single select union construct of the form </p><pre class="fragment">    (SELECT ... ORDER BY order_list [LIMIT n]) ORDER BY ... 
    @endvarbatim
    or of the form
    @varbatim
    (SELECT ... ORDER BY LIMIT n) ORDER BY ...
    @endvarbatim
  
  @param thd_arg       thread handle

  @note
    The object is used to retrieve rows from the temporary table
    where the result on the union is obtained.

  @retval
    1     on failure to create the object
  @retval
    0     on success
*/

bool st_select_lex_unit::add_fake_select_lex(THD *thd_arg)
{
  SELECT_LEX *first_sl= first_select();
  DBUG_ENTER("add_fake_select_lex");
  DBUG_ASSERT(!fake_select_lex);
  DBUG_ASSERT(thd_arg == thd);

  if (!(fake_select_lex= thd_arg-&gt;lex-&gt;new_empty_query_block()))
    DBUG_RETURN(true);       /* purecov: inspected */
  fake_select_lex-&gt;include_standalone(this, &amp;fake_select_lex);
  fake_select_lex-&gt;select_number= INT_MAX;
  fake_select_lex-&gt;linkage= GLOBAL_OPTIONS_TYPE;
  fake_select_lex-&gt;select_limit= 0;

  fake_select_lex-&gt;set_context(first_sl-&gt;context.outer_context);

  /* allow item list resolving in fake select for ORDER BY */
  fake_select_lex-&gt;context.resolve_in_select_list= TRUE;

  if (!is_union())
  {
    /* 
      This works only for 
      (SELECT ... ORDER BY list [LIMIT n]) ORDER BY order_list [LIMIT m],
      (SELECT ... LIMIT n) ORDER BY order_list [LIMIT m]
      just before the parser starts processing order_list
    */ 
    fake_select_lex-&gt;no_table_names_allowed= 1;
  }
  thd-&gt;lex-&gt;pop_context();
  DBUG_RETURN(false);
}


/**
  Push a new name resolution context for a JOIN ... ON clause to the
  context stack of a query block.

    Create a new name resolution context for a JOIN ... ON clause,
    set the first and last leaves of the list of table references
    to be used for name resolution, and push the newly created
    context to the stack of contexts of the query.

  @param pc        current parse context
  @param left_op   left  operand of the JOIN
  @param right_op  rigth operand of the JOIN

  @todo Research if we should set the "outer_context" member of the new ON
  context.

  @retval
    FALSE  if all is OK
  @retval
    TRUE   if a memory allocation error occured
*/

bool
push_new_name_resolution_context(Parse_context *pc,
                                 TABLE_LIST *left_op, TABLE_LIST *right_op)
{
  THD *thd= pc-&gt;thd;
  Name_resolution_context *on_context;
  if (!(on_context= new (thd-&gt;mem_root) Name_resolution_context))
    return TRUE;
  on_context-&gt;init();
  on_context-&gt;first_name_resolution_table=
    left_op-&gt;first_leaf_for_name_resolution();
  on_context-&gt;last_name_resolution_table=
    right_op-&gt;last_leaf_for_name_resolution();
  on_context-&gt;select_lex= pc-&gt;select;
  on_context-&gt;next_context= pc-&gt;select-&gt;first_context;
  pc-&gt;select-&gt;first_context= on_context;

  return thd-&gt;lex-&gt;push_context(on_context);
}


/**
  Add an ON condition to the second operand of a JOIN ... ON.

    Add an ON condition to the right operand of a JOIN ... ON clause.

  @param b     the second operand of a JOIN ... ON
  @param expr  the condition to be added to the ON clause
*/

void add_join_on(TABLE_LIST *b, Item *expr)
{
  if (expr)
  {
    b-&gt;set_join_cond_optim((Item*)1); // m_join_cond_optim is not ready
    if (!b-&gt;join_cond())
      b-&gt;set_join_cond(expr);
    else
    {
      /*
        If called from the parser, this happens if you have both a
        right and left join. If called later, it happens if we add more
        than one condition to the ON clause.
      */
      b-&gt;set_join_cond(new Item_cond_and(b-&gt;join_cond(), expr));
    }
    b-&gt;join_cond()-&gt;top_level_item();
  }
}


/**
  Mark that there is a NATURAL JOIN or JOIN ... USING between two
  tables.

    This function marks that table b should be joined with a either via
    a NATURAL JOIN or via JOIN ... USING. Both join types are special
    cases of each other, so we treat them together. The function
    setup_conds() creates a list of equal condition between all fields
    of the same name for NATURAL JOIN or the fields in 'using_fields'
    for JOIN ... USING. The list of equality conditions is stored
    either in b-&gt;join_cond(), or in JOIN::conds, depending on whether there
    was an outer join.

  EXAMPLE
  @verbatim
    SELECT * FROM t1 NATURAL LEFT JOIN t2
     &lt;=&gt;
    SELECT * FROM t1 LEFT JOIN t2 ON (t1.i=t2.i and t1.j=t2.j ... )

    SELECT * FROM t1 NATURAL JOIN t2 WHERE &lt;some_cond&gt;
     &lt;=&gt;
    SELECT * FROM t1, t2 WHERE (t1.i=t2.i and t1.j=t2.j and &lt;some_cond&gt;)

    SELECT * FROM t1 JOIN t2 USING(j) WHERE &lt;some_cond&gt;
     &lt;=&gt;
    SELECT * FROM t1, t2 WHERE (t1.j=t2.j and &lt;some_cond&gt;)</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Left join argument </td></tr>
    <tr><td class="paramname">b</td><td>Right join argument </td></tr>
    <tr><td class="paramname">using_fields</td><td><a class="el" href="classField.html">Field</a> names from USING clause </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d8a136c5775459ea3a35a0c27fc6c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8a136c5775459ea3a35a0c27fc6c06">&#9670;&nbsp;</a></span>add_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_to_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSQL__I__List.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">save order by and tables in own lists. </p>

</div>
</div>
<a id="gac994ea735fa021334a4e3c9370af1bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac994ea735fa021334a4e3c9370af1bd3">&#9670;&nbsp;</a></span>all_any_subquery_creator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* all_any_subquery_creator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>left_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">chooser_compare_func_creator&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Construct ALL/ANY/SOME subquery <a class="el" href="classItem.html">Item</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_expr</td><td>pointer to left expression </td></tr>
    <tr><td class="paramname">cmp</td><td>compare function creator </td></tr>
    <tr><td class="paramname">all</td><td>true if we create ALL subquery </td></tr>
    <tr><td class="paramname">select_lex</td><td>pointer on parsed subquery structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constructed <a class="el" href="classItem.html">Item</a> (or 0 if out of memory) </dd></dl>

</div>
</div>
<a id="ga8b3573b4adc788a4eeddbf6d1cb12582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b3573b4adc788a4eeddbf6d1cb12582">&#9670;&nbsp;</a></span>alloc_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alloc_query </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>packet_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Read query from packet and store in thd-&gt;query. Used in COM_QUERY and COM_STMT_PREPARE.</p>
<p class="">Sets the following THD variables:</p><ul>
<li>query</li>
<li>query_length</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>ok </td></tr>
    <tr><td class="paramname">TRUE</td><td>error; In this case thd-&gt;fatal_error is set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09d8997f1551aefa58a28606ff68c6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09d8997f1551aefa58a28606ff68c6f5">&#9670;&nbsp;</a></span>append_file_to_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool append_file_to_dir </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>filename_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">If pointer is not a null pointer, append filename to it. </p>

</div>
</div>
<a id="ga83c28ce3e415fe976a0d40cc4b4eef81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83c28ce3e415fe976a0d40cc4b4eef81">&#9670;&nbsp;</a></span>check_host_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C_MODE_END bool check_host_name </td>
          <td>(</td>
          <td class="paramtype">const LEX_CSTRING &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check that host name string is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to be checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>host name is ok </td></tr>
    <tr><td class="paramname">TRUE</td><td>host name string is longer than max_length or has invalid symbols </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a660aa2196395412bc0c5c8e7baa33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a660aa2196395412bc0c5c8e7baa33a">&#9670;&nbsp;</a></span>check_stack_overrun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_stack_overrun </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *buf &#160;</td>
          <td class="paramname"><em>MY_ATTRIBUTE</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Note: The 'buf' parameter is necessary, even if it is unused here.<ul>
<li>fix_fields functions has a "dummy" buffer large enough for the corresponding exec. (Thus we only have to check in fix_fields.)</li>
<li>Passing to <a class="el" href="group__Runtime__Environment.html#ga9a660aa2196395412bc0c5c8e7baa33a">check_stack_overrun()</a> prevents the compiler from removing it. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf7bccb54271a0546d92f2bc732abf3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7bccb54271a0546d92f2bc732abf3d1">&#9670;&nbsp;</a></span>cleanup_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cleanup_items </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This works because items are allocated with sql_alloc(). </p><dl class="section note"><dt>Note</dt><dd>The function also handles null pointers (empty list). </dd></dl>

</div>
</div>
<a id="ga8ba3e531f8d364506ca098138bd4b459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ba3e531f8d364506ca098138bd4b459">&#9670;&nbsp;</a></span>create_default_definer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__lex__user.html">LEX_USER</a>* create_default_definer </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create default definer for the specified THD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return a valid pointer to the created and initialized LEX_USER, which contains definer information.</li>
<li>On error, return 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae69775e9e669f55cbedb293c4498717b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae69775e9e669f55cbedb293c4498717b">&#9670;&nbsp;</a></span>create_select_for_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_select_for_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParse__context.html">Parse_context</a> *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create a select to return the same output as 'SELECT @var_name'.</p>
<p class="">Used for SHOW COUNT(*) [ WARNINGS | ERROR].</p>
<p class="">This will crash with a core dump if the variable doesn't exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pc</td><td>Current parse context </td></tr>
    <tr><td class="paramname">var_name</td><td>Variable name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95cca4e86f6c748bc34a5879ae0d36f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95cca4e86f6c748bc34a5879ae0d36f4">&#9670;&nbsp;</a></span>create_table_set_open_action_and_adjust_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_table_set_open_action_and_adjust_tables </td>
          <td>(</td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Set proper open mode and table type for element representing target table of CREATE <a class="el" href="structTABLE.html">TABLE</a> statement, also adjust statement table list if necessary. </p>

</div>
</div>
<a id="gabf07206792036bfb47e5bb8eb0f20bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf07206792036bfb47e5bb8eb0f20bc4">&#9670;&nbsp;</a></span>dispatch_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dispatch_command </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COM_DATA *&#160;</td>
          <td class="paramname"><em>com_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum enum_server_command&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Perform one connection-level (COM_XXXX) command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>connection handle </td></tr>
    <tr><td class="paramname">command</td><td>type of command to perform  com_data union to store the generated command</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000100">Todo:</a></b></dt><dd><p class="startdd">set thd-&gt;lex-&gt;sql_command to SQLCOM_END here. </p>
<p class="enddd">The following has to be changed to an 8 byte integer</p>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>request of thread shutdown, i. e. if command is COM_QUIT/COM_SHUTDOWN </td></tr>
  </table>
  </dd>
</dl>
<p class="">Clear the set of flags that are expected to be cleared at the beginning of each command.</p>
<p class="">Enforce password expiration for all RPC commands, except the following:</p>
<p class="">COM_QUERY does a more fine-grained check later. COM_STMT_CLOSE and COM_STMT_SEND_LONG_DATA don't return anything. COM_PING only discloses information that the server is running, and that's available through other means. COM_QUIT should work even for expired statements.</p>

</div>
</div>
<a id="ga331df424a7892fbbad536f0f3a7b18f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga331df424a7892fbbad536f0f3a7b18f6">&#9670;&nbsp;</a></span>do_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool do_command </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Read one command from connection and execute it (query or simple command). This function is called in loop from thread function.</p>
<p class="">For profiling to work, it must never be called recursively.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>request of thread shutdown (see <a class="el" href="group__Runtime__Environment.html#gabf07206792036bfb47e5bb8eb0f20bc4">dispatch_command()</a> description) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3317cfcf3ee5abca5accb1e77461ca56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3317cfcf3ee5abca5accb1e77461ca56">&#9670;&nbsp;</a></span>get_current_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__lex__user.html">LEX_USER</a>* get_current_user </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Retuns information about user or current user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>user</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, return a valid pointer to initialized LEX_USER, which contains user information.</li>
<li>On error, return 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae6109e9d93731678e792405018a30a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6109e9d93731678e792405018a30a24">&#9670;&nbsp;</a></span>get_default_definer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_default_definer </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td>
          <td class="paramname"><em>definer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Set the specified definer to the default value, which is the current user in the thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">definer</td><td>definer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1eaa146f67e2bd9604ec2ec0645ba81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1eaa146f67e2bd9604ec2ec0645ba81c">&#9670;&nbsp;</a></span>is_log_table_write_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_log_table_write_query </td>
          <td>(</td>
          <td class="paramtype">enum enum_sql_command&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if a sql command is allowed to write to log tables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The SQL command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if writing is allowed </dd></dl>

</div>
</div>
<a id="gabbd6de1ff28f3b8c16300a74d412b3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbd6de1ff28f3b8c16300a74d412b3b3">&#9670;&nbsp;</a></span>lock_binlog_for_backup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lock_binlog_for_backup </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Acquire a global binlog lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE in case of success, TRUE in case of error. </dd></dl>

</div>
</div>
<a id="gac7751d9816645a7a68e879596ee7e558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7751d9816645a7a68e879596ee7e558">&#9670;&nbsp;</a></span>mysql_execute_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mysql_execute_command </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Execute command saved in thd and lex-&gt;sql_command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000101">Todo:</a></b></dt><dd><ul>
<li>Invalidate the table in the query cache if something changed after unlocking when changes become visible. </li>
</ul>
<p class="enddd">: this is workaround. right way will be move invalidating in the unlock procedure.</p><ul>
<li>TODO: use check_change_password()</li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error </td></tr>
  </table>
  </dd>
</dl>
<p class="">NO_EMBEDDED_ACCESS_CHECKS </p>

</div>
</div>
<a id="ga81611063376e9fd7612c3ca78d16f70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81611063376e9fd7612c3ca78d16f70d">&#9670;&nbsp;</a></span>mysql_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysql_parse </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parser_state *&#160;</td>
          <td class="paramname"><em>parser_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Parse a query.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Current thread </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rawbuf</td><td>Begining of the query text </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the query text </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found_semicolon</td><td>For multi queries, position of the character of the next query in the query text. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab37db6950d3b6bc16bbbb2ae0484ae55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab37db6950d3b6bc16bbbb2ae0484ae55">&#9670;&nbsp;</a></span>mysql_reset_thd_for_next_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mysql_reset_thd_for_next_command </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reset the part of THD responsible for the state of command processing.</p>
<p class="">This needs to be called before execution of every statement (prepared or conventional). It is not called by substatements of routines.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000102">Todo:</a></b></dt><dd>Remove mysql_reset_thd_for_next_command and only use the member function.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000103">Todo:</a></b></dt><dd>Call it after we use THD for queries, not before. </dd></dl>

</div>
</div>
<a id="ga370cd1baacb8f9761d1f6caba0f01954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370cd1baacb8f9761d1f6caba0f01954">&#9670;&nbsp;</a></span>negate_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* negate_expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParse__context.html">Parse_context</a> *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">negate given expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pc</td><td>current parse context </td></tr>
    <tr><td class="paramname">expr</td><td>expression for negation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negated expression </dd></dl>

</div>
</div>
<a id="gabb1400ab6d81b2c3eb496d66df4d7674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb1400ab6d81b2c3eb496d66df4d7674">&#9670;&nbsp;</a></span>parse_sql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parse_sql </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parser_state *&#160;</td>
          <td class="paramname"><em>parser_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classObject__creation__ctx.html">Object_creation_ctx</a> *&#160;</td>
          <td class="paramname"><em>creation_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This is a wrapper of MYSQLparse(). All the code should call <a class="el" href="group__Runtime__Environment.html#gabb1400ab6d81b2c3eb496d66df4d7674">parse_sql()</a> instead of MYSQLparse().</p>
<p class="">As a by product of parsing, the parser can also generate a query digest. To compute a digest, invoke this function as follows.</p>
<pre class="fragment">  THD *thd = ...;
  const char *query_text = ...;
  uint query_length = ...;
  Object_creation_ctx *ctx = ...;
  bool rc;

  Parser_state parser_state;
  if (parser_state.init(thd, query_text, query_length)
  {
    ... handle error
  }

  parser_state.m_input.m_compute_digest= true;
  
  rc= parse_sql(the, &amp;parser_state, ctx);
  if (! rc)
  {
    unsigned char md5[MD5_HASH_SIZE];
    char digest_text[1024];
    bool truncated;
    const sql_digest_storage *digest= &amp; thd-&gt;m_digest-&gt;m_digest_storage;

    compute_digest_md5(digest, &amp; md5[0]);
    compute_digest_text(digest, &amp; digest_text[0], sizeof(digest_text), &amp; truncated);
  }
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">parser_state</td><td>Parser state. </td></tr>
    <tr><td class="paramname">creation_ctx</td><td>Object creation context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>on success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>on parsing error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5de0e97014b9b2e757a145f30eb7efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5de0e97014b9b2e757a145f30eb7efb">&#9670;&nbsp;</a></span>prepare_schema_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int prepare_schema_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Table_ident *&#160;</td>
          <td class="paramname"><em>table_ident</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum enum_schema_tables&#160;</td>
          <td class="paramname"><em>schema_table_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create a <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> object for an INFORMATION_SCHEMA table.</p>
<p class="">This function is used in the parser to convert a SHOW or DESCRIBE table_name command to a SELECT from INFORMATION_SCHEMA. It prepares a SELECT_LEX and a <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> object to represent the given command as a SELECT parse tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">lex</td><td>current lex </td></tr>
    <tr><td class="paramname">table_ident</td><td>table alias if it's used </td></tr>
    <tr><td class="paramname">schema_table_idx</td><td>the type of the INFORMATION_SCHEMA table to be created</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Due to the way this function works with memory and LEX it cannot be used outside the parser (parse tree transformations outside the parser break PS and SP).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>out of memory or SHOW commands are not allowed in this version of the server. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3632047b55b1b225c609f0f9ff46250a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3632047b55b1b225c609f0f9ff46250a">&#9670;&nbsp;</a></span>reset_statement_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_statement_timer </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Deactivate the timer associated with the statement that was executed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread (session) context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12e1f9234a9969980b924de2e3fe487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e1f9234a9969980b924de2e3fe487d">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool shutdown </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum mysql_enum_shutdown_level&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum enum_server_command&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Shutdown the mysqld server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread (session) context. </td></tr>
    <tr><td class="paramname">level</td><td>Shutdown level. </td></tr>
    <tr><td class="paramname">command</td><td>type of command to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>success </td></tr>
    <tr><td class="paramname">false</td><td>When user has insufficient privilege or unsupported shutdown level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22aec956c23a6f1e16aef7d9db67bc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22aec956c23a6f1e16aef7d9db67bc79">&#9670;&nbsp;</a></span>store_position_for_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void store_position_for_column </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Store position for column in ALTER <a class="el" href="structTABLE.html">TABLE</a> .. ADD column. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga2b520658dfe2259770e9037c640d5399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b520658dfe2259770e9037c640d5399">&#9670;&nbsp;</a></span>sql_command_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint sql_command_flags[SQLCOM_END+1]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Mark all commands that somehow changes a table.</p>
<p class="">This is used to check number of updates / hour.</p>
<p class="">sql_command is actually set to SQLCOM_END sometimes so we need the +1 to include it in the array.</p>
<p class="">See COMMAND_FLAG_xxx for different type of commands 2 - query that returns meaningful ROW_COUNT() - a number of modified rows </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
