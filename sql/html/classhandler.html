<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: handler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">handler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="handler_8h_source.html">handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for handler:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhandler.png" usemap="#handler_map" alt=""/>
  <map id="handler_map" name="handler_map">
<area href="classSql__alloc.html" alt="Sql_alloc" shape="rect" coords="51,0,143,24"/>
<area href="classha__ndbcluster.html" alt="ha_ndbcluster" shape="rect" coords="0,112,92,136"/>
<area href="classha__ndbinfo.html" alt="ha_ndbinfo" shape="rect" coords="102,112,194,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab5b14b11876fb5ac53a4cc7aceea6a2d"><td class="memItemLeft" align="right" valign="top"><a id="ab5b14b11876fb5ac53a4cc7aceea6a2d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>enum_range_scan_direction</b> { <b>RANGE_SCAN_ASC</b>, 
<b>RANGE_SCAN_DESC</b>
 }</td></tr>
<tr class="separator:ab5b14b11876fb5ac53a4cc7aceea6a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68580c3751fc08427f5ac48ef4b2d69"><td class="memItemLeft" align="right" valign="top"><a id="ab68580c3751fc08427f5ac48ef4b2d69"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NONE</b> =0, 
<b>INDEX</b>, 
<b>RND</b>
 }</td></tr>
<tr class="separator:ab68580c3751fc08427f5ac48ef4b2d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67af5473a36655c922682399d4c5b6ec"><td class="memItemLeft" align="right" valign="top"><a id="a67af5473a36655c922682399d4c5b6ec"></a>
typedef ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>Table_flags</b></td></tr>
<tr class="separator:a67af5473a36655c922682399d4c5b6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c241e50948859d98ceae6e39066838"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a>) (const <a class="el" href="structTABLE.html">TABLE</a> *, void *)</td></tr>
<tr class="separator:ad4c241e50948859d98ceae6e39066838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72cfeaceefd05a2f700c138c194770fc"><td class="memItemLeft" align="right" valign="top"><a id="a72cfeaceefd05a2f700c138c194770fc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unbind_psi</b> ()</td></tr>
<tr class="separator:a72cfeaceefd05a2f700c138c194770fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e335a403d8203854bc5b94111992b79"><td class="memItemLeft" align="right" valign="top"><a id="a1e335a403d8203854bc5b94111992b79"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rebind_psi</b> ()</td></tr>
<tr class="separator:a1e335a403d8203854bc5b94111992b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cadefb8724982848541e06a394917e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6cadefb8724982848541e06a394917e8">start_psi_batch_mode</a> ()</td></tr>
<tr class="separator:a6cadefb8724982848541e06a394917e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a860cb6d6cb731416080acc8f179e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab6a860cb6d6cb731416080acc8f179e0">end_psi_batch_mode</a> ()</td></tr>
<tr class="separator:ab6a860cb6d6cb731416080acc8f179e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae8f7f7b4f67773b73906143238dc9f"><td class="memItemLeft" align="right" valign="top"><a id="a9ae8f7f7b4f67773b73906143238dc9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b> (<a class="el" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share_arg)</td></tr>
<tr class="separator:a9ae8f7f7b4f67773b73906143238dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc340039f5cf37a26e7c3b53685794"><td class="memItemLeft" align="right" valign="top"><a id="a97fc340039f5cf37a26e7c3b53685794"></a>
virtual <a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> (const char *name, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:a97fc340039f5cf37a26e7c3b53685794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad6edb66592b200a7c7ac0f947dc66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a> ()</td></tr>
<tr class="separator:ab1ad6edb66592b200a7c7ac0f947dc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6facc9d1d0bda98c814660eaa9bad7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b6facc9d1d0bda98c814660eaa9bad7">init_with_fields</a> ()</td></tr>
<tr class="separator:a6b6facc9d1d0bda98c814660eaa9bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e02829386929734724b143391e0a11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5e02829386929734724b143391e0a11">ha_open</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const char *name, int mode, int test_if_locked)</td></tr>
<tr class="memdesc:ab5e02829386929734724b143391e0a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open database-handler.  <a href="#ab5e02829386929734724b143391e0a11">More...</a><br /></td></tr>
<tr class="separator:ab5e02829386929734724b143391e0a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28824cdff2c1812e282463c908e84c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a> (void)</td></tr>
<tr class="separator:ae28824cdff2c1812e282463c908e84c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af23462b249041a0db03c1c7139d76b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a> (uint idx, bool sorted)</td></tr>
<tr class="separator:a0af23462b249041a0db03c1c7139d76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6bd01057c6cdd86d2ea2ee4ea65ca3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a> ()</td></tr>
<tr class="separator:afa6bd01057c6cdd86d2ea2ee4ea65ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5c99736cb400350e007578889b8375"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a> (bool scan)</td></tr>
<tr class="separator:afb5c99736cb400350e007578889b8375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9bf34ac0a004d8c5c32267f20842f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a> ()</td></tr>
<tr class="separator:ad4d9bf34ac0a004d8c5c32267f20842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3743f3a48e7be751dbb2691be4c992a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a> (uchar *buf)</td></tr>
<tr class="separator:ad3743f3a48e7be751dbb2691be4c992a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd8615219b3e692e7d484d2ba6cfa86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a> (uchar *buf, uchar *pos)</td></tr>
<tr class="separator:abcd8615219b3e692e7d484d2ba6cfa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729d9c9c011527b81287574294887bf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a729d9c9c011527b81287574294887bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9be09b8d0b1c03c96eb95f79dd7c9"><td class="memItemLeft" align="right" valign="top"><a id="a3fa9be09b8d0b1c03c96eb95f79dd7c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_read_last_map</b> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a3fa9be09b8d0b1c03c96eb95f79dd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831321e8d33958db4fd4968de932acf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a> (uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:ac831321e8d33958db4fd4968de932acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c99e96a8350ff577a94529be9387a30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a> (uchar *buf)</td></tr>
<tr class="separator:a4c99e96a8350ff577a94529be9387a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb977dac0435158be227e45e04c8b798"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a> (uchar *buf)</td></tr>
<tr class="separator:abb977dac0435158be227e45e04c8b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd574a3025588e9b0cd49e0d6908e3b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a> (uchar *buf)</td></tr>
<tr class="separator:abd574a3025588e9b0cd49e0d6908e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7415f1744039a51ef15e923ef7da1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a> (uchar *buf)</td></tr>
<tr class="separator:a2a7415f1744039a51ef15e923ef7da1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f79360a45d50c6b558feb1c308c4157"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a> (uchar *buf, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a3f79360a45d50c6b558feb1c308c4157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d38f167906d8aaa9e560c71e595a42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">ha_reset</a> ()</td></tr>
<tr class="memdesc:a53d38f167906d8aaa9e560c71e595a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check handler usage and reset state of file to after 'open'.  <a href="#a53d38f167906d8aaa9e560c71e595a42">More...</a><br /></td></tr>
<tr class="separator:a53d38f167906d8aaa9e560c71e595a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ef9b6ab27156116f91bf50b1ac19f"><td class="memItemLeft" align="right" valign="top"><a id="a6e1ef9b6ab27156116f91bf50b1ac19f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_or_rnd_end</b> ()</td></tr>
<tr class="separator:a6e1ef9b6ab27156116f91bf50b1ac19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3015577f49008561db1d34ae750e70"><td class="memItemLeft" align="right" valign="top">Table_flags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6b3015577f49008561db1d34ae750e70">ha_table_flags</a> () const</td></tr>
<tr class="separator:a6b3015577f49008561db1d34ae750e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a99b5f8ae28bc5c374919396f8dcf08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a> (THD *thd, int lock_type)</td></tr>
<tr class="separator:a9a99b5f8ae28bc5c374919396f8dcf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e651543ba0dbb2257a50dc1cdb5ea9"><td class="memItemLeft" align="right" valign="top"><a id="ad8e651543ba0dbb2257a50dc1cdb5ea9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_write_row</b> (uchar *buf)</td></tr>
<tr class="separator:ad8e651543ba0dbb2257a50dc1cdb5ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6bb19636dda0f1537fe780b6aca17a"><td class="memItemLeft" align="right" valign="top"><a id="a1f6bb19636dda0f1537fe780b6aca17a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr class="separator:a1f6bb19636dda0f1537fe780b6aca17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e3b24f5bb5b2a8fa0c45732db8cdd"><td class="memItemLeft" align="right" valign="top"><a id="a3f0e3b24f5bb5b2a8fa0c45732db8cdd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_delete_row</b> (const uchar *buf)</td></tr>
<tr class="separator:a3f0e3b24f5bb5b2a8fa0c45732db8cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbcbef5b9b8ed0f76d700a29091ad3f"><td class="memItemLeft" align="right" valign="top"><a id="abfbcbef5b9b8ed0f76d700a29091ad3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_release_auto_increment</b> ()</td></tr>
<tr class="separator:abfbcbef5b9b8ed0f76d700a29091ad3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234580f9765751ce185182dd1edc3bdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">check_collation_compatibility</a> ()</td></tr>
<tr class="separator:a234580f9765751ce185182dd1edc3bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a8030a4a3928d216599e1c03e9b28c"><td class="memItemLeft" align="right" valign="top"><a id="a79a8030a4a3928d216599e1c03e9b28c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_check_for_upgrade</b> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a79a8030a4a3928d216599e1c03e9b28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56545ec9967544c80d5612f8ac9b8e6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a56545ec9967544c80d5612f8ac9b8e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28d70543d9566894b5a81d25eca2e8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ad28d70543d9566894b5a81d25eca2e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f09a15d46c019a621b0a65bb1ec89d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a> (ha_rows rows)</td></tr>
<tr class="separator:a3f09a15d46c019a621b0a65bb1ec89d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3cbf4a769155c994ed39f76433106"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a> ()</td></tr>
<tr class="separator:a30f3cbf4a769155c994ed39f76433106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c8ce82a564b0cbf6340dc9b74a9c23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:a49c8ce82a564b0cbf6340dc9b74a9c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef228137a11565f7d52a60ad802004"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a> ()</td></tr>
<tr class="separator:a1fef228137a11565f7d52a60ad802004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25394328a49d42bb45b3b263009f02c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25394328a49d42bb45b3b263009f02c7">ha_truncate</a> ()</td></tr>
<tr class="separator:a25394328a49d42bb45b3b263009f02c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a8a7650a41fd9a05a32521826ccd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a980a8a7650a41fd9a05a32521826ccd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc9e4971b8e768c102398da0656a7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a66cc9e4971b8e768c102398da0656a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169d5287bdf480f8cd20f758bb2d9bd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a> (THD *thd)</td></tr>
<tr class="separator:a169d5287bdf480f8cd20f758bb2d9bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb079b3dc59160ba828ef89b4463921"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a> (uint mode)</td></tr>
<tr class="separator:aeeb079b3dc59160ba828ef89b4463921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9c53758728e07eb37cbb65ea3ab50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a> (uint mode)</td></tr>
<tr class="separator:a36e9c53758728e07eb37cbb65ea3ab50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f75cf982985d21907140a17521cd6c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1f75cf982985d21907140a17521cd6c5">ha_discard_or_import_tablespace</a> (my_bool discard)</td></tr>
<tr class="separator:a1f75cf982985d21907140a17521cd6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee228a60527e81efd9a49ddfdd4850d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ee228a60527e81efd9a49ddfdd4850d">ha_rename_table</a> (const char *from, const char *to)</td></tr>
<tr class="separator:a6ee228a60527e81efd9a49ddfdd4850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28700a3bf1af24f9a31ebae51bf877db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28700a3bf1af24f9a31ebae51bf877db">ha_delete_table</a> (const char *name)</td></tr>
<tr class="separator:a28700a3bf1af24f9a31ebae51bf877db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcc37ec84386f5d6cc86448781666cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a> (const char *name)</td></tr>
<tr class="separator:a6bcc37ec84386f5d6cc86448781666cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14af5825a427ba6baac74b13223637f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a14af5825a427ba6baac74b13223637f8">ha_create</a> (const char *name, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a14af5825a427ba6baac74b13223637f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722462d7e71059a8ed1f43d0fb28366b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a722462d7e71059a8ed1f43d0fb28366b">ha_create_handler_files</a> (const char *name, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a722462d7e71059a8ed1f43d0fb28366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c090210fefb7e95d885688f5717028"><td class="memItemLeft" align="right" valign="top"><a id="ad4c090210fefb7e95d885688f5717028"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_next_insert_id_after_explicit_value</b> (ulonglong nr)</td></tr>
<tr class="separator:ad4c090210fefb7e95d885688f5717028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d2f9da11425e388640206b4d22241"><td class="memItemLeft" align="right" valign="top"><a id="a8a7d2f9da11425e388640206b4d22241"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_auto_increment</b> ()</td></tr>
<tr class="separator:a8a7d2f9da11425e388640206b4d22241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda4f1390385a4dc0bfd2981fee23e6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">print_error</a> (int error, myf errflag)</td></tr>
<tr class="separator:afda4f1390385a4dc0bfd2981fee23e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8ffd064ce683481494c7503ef820c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">get_error_message</a> (int error, String *buf)</td></tr>
<tr class="separator:afce8ffd064ce683481494c7503ef820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eede0999f8273864faa40c5e181793"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a> (int error)</td></tr>
<tr class="separator:ad5eede0999f8273864faa40c5e181793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20878b1fb8d31b91dbf53ac963d90f78"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">get_foreign_dup_key</a> (char *child_table_name, uint child_table_name_len, char *child_key_name, uint child_key_name_len)</td></tr>
<tr class="separator:a20878b1fb8d31b91dbf53ac963d90f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b117a976fc9423d2337da59f35d128c"><td class="memItemLeft" align="right" valign="top"><a id="a2b117a976fc9423d2337da59f35d128c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>change_table_ptr</b> (<a class="el" href="structTABLE.html">TABLE</a> *table_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr class="separator:a2b117a976fc9423d2337da59f35d128c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f8e5188e2bd9636a564bbc0c3fef86"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a65f8e5188e2bd9636a564bbc0c3fef86">scan_time</a> ()</td></tr>
<tr class="separator:a65f8e5188e2bd9636a564bbc0c3fef86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061b519fb16fbff126b0e21530973c2e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">read_time</a> (uint index, uint ranges, ha_rows rows)</td></tr>
<tr class="separator:a061b519fb16fbff126b0e21530973c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2ac6b2908a899c0ce230818bb7a993"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a> (uint keynr, double <a class="el" href="classhandler.html#ae5b7b96354fd25da35a940e656d91940">records</a>)</td></tr>
<tr class="separator:a4a2ac6b2908a899c0ce230818bb7a993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9380355a7eea5386ef061f36479258"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e9380355a7eea5386ef061f36479258">table_scan_cost</a> ()</td></tr>
<tr class="separator:a5e9380355a7eea5386ef061f36479258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5575d58c0acbb1924f7f3d3eb756612a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5575d58c0acbb1924f7f3d3eb756612a">index_scan_cost</a> (uint index, double ranges, double rows)</td></tr>
<tr class="separator:a5575d58c0acbb1924f7f3d3eb756612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d85fe55a71cc09c642592e771b662"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classCost__estimate.html">Cost_estimate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a196d85fe55a71cc09c642592e771b662">read_cost</a> (uint index, double ranges, double rows)</td></tr>
<tr class="separator:a196d85fe55a71cc09c642592e771b662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475f7fbe39f6ff0e9da2ac6c3d6c629e"><td class="memItemLeft" align="right" valign="top">virtual longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a475f7fbe39f6ff0e9da2ac6c3d6c629e">get_memory_buffer_size</a> () const</td></tr>
<tr class="separator:a475f7fbe39f6ff0e9da2ac6c3d6c629e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171927b3afde9e800755b834bd8d31bd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a171927b3afde9e800755b834bd8d31bd">table_in_memory_estimate</a> () const</td></tr>
<tr class="separator:a171927b3afde9e800755b834bd8d31bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375fdfc86f021f336777324dd5a98a02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a375fdfc86f021f336777324dd5a98a02">index_in_memory_estimate</a> (uint keyno) const</td></tr>
<tr class="separator:a375fdfc86f021f336777324dd5a98a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee356d2340552eb121d423fc01597f8"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">multi_range_read_info_const</a> (uint keyno, <a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint *bufsz, uint *flags, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:a5ee356d2340552eb121d423fc01597f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5add40a6cd7088ffef25a3816294b624"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">multi_range_read_info</a> (uint keyno, uint n_ranges, uint keys, uint *bufsz, uint *flags, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr class="separator:a5add40a6cd7088ffef25a3816294b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e8899f4bae262b6b91c7284f1d946e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init</a> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint mode, <a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *buf)</td></tr>
<tr class="separator:a33e8899f4bae262b6b91c7284f1d946e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3419071f3d4abf183dac95ef565adfff"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">multi_range_read_next</a> (char **range_info)</td></tr>
<tr class="separator:a3419071f3d4abf183dac95ef565adfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c43b5f1fb4c515d2c5842dcbc24fac"><td class="memItemLeft" align="right" valign="top"><a id="a29c43b5f1fb4c515d2c5842dcbc24fac"></a>
virtual const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keys_to_use_for_scanning</b> ()</td></tr>
<tr class="separator:a29c43b5f1fb4c515d2c5842dcbc24fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08686bccb46c2be2cc92ff2f75ab9540"><td class="memItemLeft" align="right" valign="top"><a id="a08686bccb46c2be2cc92ff2f75ab9540"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_transactions</b> () const</td></tr>
<tr class="separator:a08686bccb46c2be2cc92ff2f75ab9540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fd434bc44b88f4e47f44f02c877c91"><td class="memItemLeft" align="right" valign="top"><a id="a27fd434bc44b88f4e47f44f02c877c91"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>extra_rec_buf_length</b> () const</td></tr>
<tr class="separator:a27fd434bc44b88f4e47f44f02c877c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c5919d6a3f3098353f4517e2c81037"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a39c5919d6a3f3098353f4517e2c81037">is_ignorable_error</a> (int error)</td></tr>
<tr class="memdesc:a39c5919d6a3f3098353f4517e2c81037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an error can be ignored or not.  <a href="#a39c5919d6a3f3098353f4517e2c81037">More...</a><br /></td></tr>
<tr class="separator:a39c5919d6a3f3098353f4517e2c81037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37413b5d60b340ffe26a6713b65bab75"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a37413b5d60b340ffe26a6713b65bab75">is_fatal_error</a> (int error)</td></tr>
<tr class="memdesc:a37413b5d60b340ffe26a6713b65bab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an error is fatal or not.  <a href="#a37413b5d60b340ffe26a6713b65bab75">More...</a><br /></td></tr>
<tr class="separator:a37413b5d60b340ffe26a6713b65bab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe4a9e78c818aa2823c302f0fe65522"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9fe4a9e78c818aa2823c302f0fe65522">ha_records</a> (ha_rows *num_rows)</td></tr>
<tr class="separator:a9fe4a9e78c818aa2823c302f0fe65522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59e9a1d36d852f4dd5dd00bff5f1ae4"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">estimate_rows_upper_bound</a> ()</td></tr>
<tr class="separator:ae59e9a1d36d852f4dd5dd00bff5f1ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163a360c0cd4575ae207553b8d5c918d"><td class="memItemLeft" align="right" valign="top">virtual enum row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a163a360c0cd4575ae207553b8d5c918d">get_row_type</a> () const</td></tr>
<tr class="separator:a163a360c0cd4575ae207553b8d5c918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e51a7f02396ce5cef9cbe41a4a0a888"><td class="memItemLeft" align="right" valign="top"><a id="a1e51a7f02396ce5cef9cbe41a4a0a888"></a>
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> (uint key_number)</td></tr>
<tr class="separator:a1e51a7f02396ce5cef9cbe41a4a0a888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de97045e5381007565fd2b0da235c07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">column_bitmaps_signal</a> ()</td></tr>
<tr class="memdesc:a4de97045e5381007565fd2b0da235c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL signal that it changed the column bitmap.  <a href="#a4de97045e5381007565fd2b0da235c07">More...</a><br /></td></tr>
<tr class="separator:a4de97045e5381007565fd2b0da235c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf0aed6539181d465676ebc661f2b5"><td class="memItemLeft" align="right" valign="top"><a id="aacdf0aed6539181d465676ebc661f2b5"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_index</b> (void) const</td></tr>
<tr class="separator:aacdf0aed6539181d465676ebc661f2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488245f51aa4676c872bb0564dbe71f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">start_bulk_update</a> ()</td></tr>
<tr class="separator:a7488245f51aa4676c872bb0564dbe71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf7319a6498f655f8f07b1b34b12fc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">start_bulk_delete</a> ()</td></tr>
<tr class="separator:acdaf7319a6498f655f8f07b1b34b12fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886bf2fbf16de7e200e3ebc0765fb6e4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">exec_bulk_update</a> (uint *dup_key_found)</td></tr>
<tr class="separator:a886bf2fbf16de7e200e3ebc0765fb6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6c46d66ca282a4cbd6118e4c99e03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">end_bulk_update</a> ()</td></tr>
<tr class="separator:a2bf6c46d66ca282a4cbd6118e4c99e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f9f1ca2b5efc0b41e96c6b793d9bb1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">end_bulk_delete</a> ()</td></tr>
<tr class="separator:af5f9f1ca2b5efc0b41e96c6b793d9bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17ab5ed40c1eab55ce74ce2465c9bff"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad17ab5ed40c1eab55ce74ce2465c9bff">prepare_index_scan</a> (void)</td></tr>
<tr class="separator:ad17ab5ed40c1eab55ce74ce2465c9bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa111c313513f50300e9740aeb3e4cfc4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa111c313513f50300e9740aeb3e4cfc4">prepare_range_scan</a> (const key_range *start_key, const key_range *end_key)</td></tr>
<tr class="separator:aa111c313513f50300e9740aeb3e4cfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4906703169a1e43358e2d95f0d90e911"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4906703169a1e43358e2d95f0d90e911">prepare_index_key_scan_map</a> (const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a4906703169a1e43358e2d95f0d90e911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7605ac9185a544f444604f11d61f6722"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7605ac9185a544f444604f11d61f6722">has_gap_locks</a> () const</td></tr>
<tr class="separator:a7605ac9185a544f444604f11d61f6722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0be0637dfaf4fc4a2dc89334c350ec7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0be0637dfaf4fc4a2dc89334c350ec7">rpl_can_handle_stm_event</a> () const</td></tr>
<tr class="separator:af0be0637dfaf4fc4a2dc89334c350ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">read_range_first</a> (const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted)</td></tr>
<tr class="memdesc:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges. Store ranges for future calls to read_range_next.  <a href="#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">More...</a><br /></td></tr>
<tr class="separator:a3a0d596ff3ddc77b4f0ad990c4c4cb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4632aa56c9c66a57558f849f8e01271"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">read_range_next</a> ()</td></tr>
<tr class="memdesc:ae4632aa56c9c66a57558f849f8e01271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#ae4632aa56c9c66a57558f849f8e01271">More...</a><br /></td></tr>
<tr class="separator:ae4632aa56c9c66a57558f849f8e01271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7dfb95a0da2e828ac018aa2b4abe3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a> (const key_range *range, enum_range_scan_direction direction)</td></tr>
<tr class="separator:a4b7dfb95a0da2e828ac018aa2b4abe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef38e7407e87ba5d1ccde59c3e94bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a> (key_range *range)</td></tr>
<tr class="separator:af0ef38e7407e87ba5d1ccde59c3e94bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab767345668267e3c8881fab6e351e6c8"><td class="memItemLeft" align="right" valign="top"><a id="ab767345668267e3c8881fab6e351e6c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>compare_key_icp</b> (const key_range *range) const</td></tr>
<tr class="separator:ab767345668267e3c8881fab6e351e6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac3d9b9796d3bfb18b96a1989d6f516"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeac3d9b9796d3bfb18b96a1989d6f516">compare_key_in_buffer</a> (const uchar *buf) const</td></tr>
<tr class="separator:aeac3d9b9796d3bfb18b96a1989d6f516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab734678f90b9e7cc6b000047f7c89bb1"><td class="memItemLeft" align="right" valign="top"><a id="ab734678f90b9e7cc6b000047f7c89bb1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init</b> ()</td></tr>
<tr class="separator:ab734678f90b9e7cc6b000047f7c89bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72693b6e25765a4290f531f578bcf2eb"><td class="memItemLeft" align="right" valign="top"><a id="a72693b6e25765a4290f531f578bcf2eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ft_end</b> ()</td></tr>
<tr class="separator:a72693b6e25765a4290f531f578bcf2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109448e09ee2c456b1471b74bb9eb8e6"><td class="memItemLeft" align="right" valign="top"><a id="a109448e09ee2c456b1471b74bb9eb8e6"></a>
virtual FT_INFO *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init_ext</b> (uint flags, uint inx, String *key)</td></tr>
<tr class="separator:a109448e09ee2c456b1471b74bb9eb8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceb6075e1b3ad667596b30eea85feb6"><td class="memItemLeft" align="right" valign="top"><a id="a9ceb6075e1b3ad667596b30eea85feb6"></a>
virtual FT_INFO *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init_ext_with_hints</b> (uint inx, String *key, <a class="el" href="classFt__hints.html">Ft_hints</a> *hints)</td></tr>
<tr class="separator:a9ceb6075e1b3ad667596b30eea85feb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c965ae56bcceee3cf63ce0320a5d31b"><td class="memItemLeft" align="right" valign="top"><a id="a0c965ae56bcceee3cf63ce0320a5d31b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_read</b> (uchar *buf)</td></tr>
<tr class="separator:a0c965ae56bcceee3cf63ce0320a5d31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be2fa5d347252f8a28dce931654b76"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">rnd_pos_by_record</a> (uchar *record)</td></tr>
<tr class="separator:ac2be2fa5d347252f8a28dce931654b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff50b704d53d715d6b0fd3534c6107d8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">read_first_row</a> (uchar *buf, uint primary_key)</td></tr>
<tr class="separator:aff50b704d53d715d6b0fd3534c6107d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac874ad6fd5a2e6b97376befacb165"><td class="memItemLeft" align="right" valign="top"><a id="a33ac874ad6fd5a2e6b97376befacb165"></a>
virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>records_in_range</b> (uint inx, key_range *min_key, key_range *max_key)</td></tr>
<tr class="separator:a33ac874ad6fd5a2e6b97376befacb165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c1515e7a936fa9cbc19f93d43495b6"><td class="memItemLeft" align="right" valign="top"><a id="ad3c1515e7a936fa9cbc19f93d43495b6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (const uchar *record)=0</td></tr>
<tr class="separator:ad3c1515e7a936fa9cbc19f93d43495b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39a38e4a875151379cacd0da1a789c8"><td class="memItemLeft" align="right" valign="top"><a id="ab39a38e4a875151379cacd0da1a789c8"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>info</b> (uint)=0</td></tr>
<tr class="separator:ab39a38e4a875151379cacd0da1a789c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e746c224b70d3b03b2886ecf4563394"><td class="memItemLeft" align="right" valign="top"><a id="a7e746c224b70d3b03b2886ecf4563394"></a>
virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_key_hash_value</b> (<a class="el" href="classField.html">Field</a> **field_array)</td></tr>
<tr class="separator:a7e746c224b70d3b03b2886ecf4563394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7687330aaf0d97540db07ab436e349"><td class="memItemLeft" align="right" valign="top"><a id="a2b7687330aaf0d97540db07ab436e349"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra</b> (enum ha_extra_function operation)</td></tr>
<tr class="separator:a2b7687330aaf0d97540db07ab436e349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e72da94a7f5577f00ab5c89204ec1"><td class="memItemLeft" align="right" valign="top"><a id="a6b7e72da94a7f5577f00ab5c89204ec1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_opt</b> (enum ha_extra_function operation, ulong cache_size)</td></tr>
<tr class="separator:a6b7e72da94a7f5577f00ab5c89204ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2428788c2437e4e33c4b390cc697f7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">start_read_removal</a> (void)</td></tr>
<tr class="separator:a3e2428788c2437e4e33c4b390cc697f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d99c283e85e8d97460f07a781dabf"><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">end_read_removal</a> (void)</td></tr>
<tr class="separator:a517d99c283e85e8d97460f07a781dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d92f647a4ca5a3b7867fa5538242a6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">was_semi_consistent_read</a> ()</td></tr>
<tr class="separator:a54d92f647a4ca5a3b7867fa5538242a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e767094bff139a26743e9314df8476"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">try_semi_consistent_read</a> (bool)</td></tr>
<tr class="separator:ab3e767094bff139a26743e9314df8476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e6fd090f73a8e7e5e94769c9a10733"><td class="memItemLeft" align="right" valign="top"><a id="a48e6fd090f73a8e7e5e94769c9a10733"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_row</b> ()</td></tr>
<tr class="separator:a48e6fd090f73a8e7e5e94769c9a10733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c625117fcff640b7af11e7018519cd"><td class="memItemLeft" align="right" valign="top"><a id="a90c625117fcff640b7af11e7018519cd"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>start_stmt</b> (THD *thd, thr_lock_type lock_type)</td></tr>
<tr class="separator:a90c625117fcff640b7af11e7018519cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6af760a4ef09984a5cc1dc58db9a40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment</a> (ulonglong offset, ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value, ulonglong *nb_reserved_values)</td></tr>
<tr class="separator:aaf6af760a4ef09984a5cc1dc58db9a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f9bf8ee63f3b8312fdc31be3819ede"><td class="memItemLeft" align="right" valign="top"><a id="ab6f9bf8ee63f3b8312fdc31be3819ede"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_next_insert_id</b> (ulonglong id)</td></tr>
<tr class="separator:ab6f9bf8ee63f3b8312fdc31be3819ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b51670b2497f01f19f587a4a969386"><td class="memItemLeft" align="right" valign="top"><a id="a15b51670b2497f01f19f587a4a969386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>restore_auto_increment</b> (ulonglong <a class="el" href="handler_8cc.html#ae9f796d8fbc7dc812557a17547b8e69e">prev_insert_id</a>)</td></tr>
<tr class="separator:a15b51670b2497f01f19f587a4a969386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15661ad009adb5b5b616928ba57c1a3"><td class="memItemLeft" align="right" valign="top"><a id="ae15661ad009adb5b5b616928ba57c1a3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_create_info_for_frm</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:ae15661ad009adb5b5b616928ba57c1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58141e7b51aaf97bdf63ea68c411f401"><td class="memItemLeft" align="right" valign="top"><a id="a58141e7b51aaf97bdf63ea68c411f401"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>update_create_info</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr class="separator:a58141e7b51aaf97bdf63ea68c411f401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc92ca74cd6aca9a6070a186ced4cb"><td class="memItemLeft" align="right" valign="top"><a id="a1abc92ca74cd6aca9a6070a186ced4cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_old_types</b> ()</td></tr>
<tr class="separator:a1abc92ca74cd6aca9a6070a186ced4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b5fa7360fc536082f495ee7e09bcba"><td class="memItemLeft" align="right" valign="top"><a id="ab1b5fa7360fc536082f495ee7e09bcba"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>assign_to_keycache</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:ab1b5fa7360fc536082f495ee7e09bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061ab331631179647ccdbd71960ba37"><td class="memItemLeft" align="right" valign="top"><a id="a0061ab331631179647ccdbd71960ba37"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>preload_keys</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a0061ab331631179647ccdbd71960ba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc45e93a1b669fa750f73a617c46bac"><td class="memItemLeft" align="right" valign="top"><a id="a8bc45e93a1b669fa750f73a617c46bac"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>indexes_are_disabled</b> (void)</td></tr>
<tr class="separator:a8bc45e93a1b669fa750f73a617c46bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441afeebcb5b56e598fb7f860c9247d1"><td class="memItemLeft" align="right" valign="top"><a id="a441afeebcb5b56e598fb7f860c9247d1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>append_create_info</b> (String *packet)</td></tr>
<tr class="separator:a441afeebcb5b56e598fb7f860c9247d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda33331aacc500b1b974033cb64a869"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adda33331aacc500b1b974033cb64a869">is_fk_defined_on_table_or_index</a> (uint index)</td></tr>
<tr class="separator:adda33331aacc500b1b974033cb64a869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8712abc71df0d89559e2861c100a8e3e"><td class="memItemLeft" align="right" valign="top"><a id="a8712abc71df0d89559e2861c100a8e3e"></a>
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><b>get_foreign_key_create_info</b> ()</td></tr>
<tr class="separator:a8712abc71df0d89559e2861c100a8e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baab93a22543b707e6e59b9d59810d2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">can_switch_engines</a> ()</td></tr>
<tr class="separator:a6baab93a22543b707e6e59b9d59810d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81064e61d4c08261af409fb6ee34e3ca"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">get_foreign_key_list</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a81064e61d4c08261af409fb6ee34e3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9187eea9999eba802ee4ae01f91dda3b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">get_parent_foreign_key_list</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr class="separator:a9187eea9999eba802ee4ae01f91dda3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683eef70b4481c3bc0b10336e179de27"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a683eef70b4481c3bc0b10336e179de27">get_cascade_foreign_key_table_list</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__handler__tablename.html">st_handler_tablename</a> &gt; *fk_table_list)</td></tr>
<tr class="separator:a683eef70b4481c3bc0b10336e179de27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b038c18aeb8114376725e6f8d39871"><td class="memItemLeft" align="right" valign="top"><a id="a28b038c18aeb8114376725e6f8d39871"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>referenced_by_foreign_key</b> ()</td></tr>
<tr class="separator:a28b038c18aeb8114376725e6f8d39871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dfb73f9401996a25b9cf925db74149"><td class="memItemLeft" align="right" valign="top"><a id="a28dfb73f9401996a25b9cf925db74149"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init_table_handle_for_HANDLER</b> ()</td></tr>
<tr class="separator:a28dfb73f9401996a25b9cf925db74149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4457d47baa6d136af65e041da4fe9e0"><td class="memItemLeft" align="right" valign="top"><a id="aa4457d47baa6d136af65e041da4fe9e0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>free_foreign_key_create_info</b> (char *str)</td></tr>
<tr class="separator:aa4457d47baa6d136af65e041da4fe9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38f5d3f1e026a0af32b5542aa5ac2f9"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">table_type</a> () const =0</td></tr>
<tr class="separator:ad38f5d3f1e026a0af32b5542aa5ac2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d5e5b6dbbb0681cbac2ad881505c9"><td class="memItemLeft" align="right" valign="top">virtual const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext</a> () const =0</td></tr>
<tr class="separator:a748d5e5b6dbbb0681cbac2ad881505c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612375d87a4cbb6e7c190ea7d05cf945"><td class="memItemLeft" align="right" valign="top"><a id="a612375d87a4cbb6e7c190ea7d05cf945"></a>
virtual ulong&#160;</td><td class="memItemRight" valign="bottom"><b>index_flags</b> (uint idx, uint part, bool all_parts) const =0</td></tr>
<tr class="separator:a612375d87a4cbb6e7c190ea7d05cf945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee9c5a03956913d75de1fca3af7833a"><td class="memItemLeft" align="right" valign="top"><a id="a7ee9c5a03956913d75de1fca3af7833a"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_record_length</b> () const</td></tr>
<tr class="separator:a7ee9c5a03956913d75de1fca3af7833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493c1ac62569e6cc89cbfde66fea47f3"><td class="memItemLeft" align="right" valign="top"><a id="a493c1ac62569e6cc89cbfde66fea47f3"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_keys</b> () const</td></tr>
<tr class="separator:a493c1ac62569e6cc89cbfde66fea47f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adabba96b635533f31d5e38e6d2a74c"><td class="memItemLeft" align="right" valign="top"><a id="a1adabba96b635533f31d5e38e6d2a74c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_parts</b> () const</td></tr>
<tr class="separator:a1adabba96b635533f31d5e38e6d2a74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1b1d6fe7e717fe234c18915cb26e87"><td class="memItemLeft" align="right" valign="top"><a id="a9e1b1d6fe7e717fe234c18915cb26e87"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_length</b> () const</td></tr>
<tr class="separator:a9e1b1d6fe7e717fe234c18915cb26e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa0c2a89e52a27667973c1d5074dca7"><td class="memItemLeft" align="right" valign="top"><a id="a4fa0c2a89e52a27667973c1d5074dca7"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_part_length</b> () const</td></tr>
<tr class="separator:a4fa0c2a89e52a27667973c1d5074dca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a498859c2d47448100e5e703622bb"><td class="memItemLeft" align="right" valign="top"><a id="a672a498859c2d47448100e5e703622bb"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_record_length</b> () const</td></tr>
<tr class="separator:a672a498859c2d47448100e5e703622bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7b335988ea24ea8b685c4278442cf8"><td class="memItemLeft" align="right" valign="top"><a id="a9c7b335988ea24ea8b685c4278442cf8"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_keys</b> () const</td></tr>
<tr class="separator:a9c7b335988ea24ea8b685c4278442cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d5b6de2843435371dc9045403e3d07"><td class="memItemLeft" align="right" valign="top"><a id="a25d5b6de2843435371dc9045403e3d07"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_parts</b> () const</td></tr>
<tr class="separator:a25d5b6de2843435371dc9045403e3d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2216dba316fe13117f00e8d21cbdab"><td class="memItemLeft" align="right" valign="top"><a id="a0c2216dba316fe13117f00e8d21cbdab"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_length</b> () const</td></tr>
<tr class="separator:a0c2216dba316fe13117f00e8d21cbdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9209ad97772dc4c6c0398fe11296d3ac"><td class="memItemLeft" align="right" valign="top"><a id="a9209ad97772dc4c6c0398fe11296d3ac"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_part_length</b> () const</td></tr>
<tr class="separator:a9209ad97772dc4c6c0398fe11296d3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082d2a49764e8548b8104dc514877b3"><td class="memItemLeft" align="right" valign="top"><a id="ab082d2a49764e8548b8104dc514877b3"></a>
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_record_length</b> (uint options) const</td></tr>
<tr class="separator:ab082d2a49764e8548b8104dc514877b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a20da13aaa177f1a256e5fb63e7c78"><td class="memItemLeft" align="right" valign="top"><a id="a64a20da13aaa177f1a256e5fb63e7c78"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>low_byte_first</b> () const</td></tr>
<tr class="separator:a64a20da13aaa177f1a256e5fb63e7c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00ca688822b5d3c9db5ce5d6a982b44"><td class="memItemLeft" align="right" valign="top"><a id="ad00ca688822b5d3c9db5ce5d6a982b44"></a>
virtual ha_checksum&#160;</td><td class="memItemRight" valign="bottom"><b>checksum</b> () const</td></tr>
<tr class="separator:ad00ca688822b5d3c9db5ce5d6a982b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea4b726707284210cc365ad454add03"><td class="memItemLeft" align="right" valign="top"><a id="a6ea4b726707284210cc365ad454add03"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_crashed</b> () const</td></tr>
<tr class="separator:a6ea4b726707284210cc365ad454add03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca08387779d587f8d3ea84b965ddc391"><td class="memItemLeft" align="right" valign="top"><a id="aca08387779d587f8d3ea84b965ddc391"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>auto_repair</b> () const</td></tr>
<tr class="separator:aca08387779d587f8d3ea84b965ddc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272b467ea09dc8f1f10389d7238628c1"><td class="memItemLeft" align="right" valign="top"><a id="a272b467ea09dc8f1f10389d7238628c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_global_table_stats</b> ()</td></tr>
<tr class="separator:a272b467ea09dc8f1f10389d7238628c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44b5d08ef9b62044cf44f0e6674806a"><td class="memItemLeft" align="right" valign="top"><a id="ad44b5d08ef9b62044cf44f0e6674806a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_global_index_stats</b> ()</td></tr>
<tr class="separator:ad44b5d08ef9b62044cf44f0e6674806a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c19b28238d94f029351ecaee0aba007"><td class="memItemLeft" align="right" valign="top"><a id="a1c19b28238d94f029351ecaee0aba007"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_index_stats</b> (uint current_index)</td></tr>
<tr class="separator:a1c19b28238d94f029351ecaee0aba007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2447668275a831bcf73b5c00818254a6"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count</a> (void) const</td></tr>
<tr class="separator:a2447668275a831bcf73b5c00818254a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2502e460566f2c4b506cc1b30eb79e0a"><td class="memItemLeft" align="right" valign="top">virtual THR_LOCK_DATA **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock</a> (THD *thd, THR_LOCK_DATA **to, enum thr_lock_type lock_type)=0</td></tr>
<tr class="separator:a2502e460566f2c4b506cc1b30eb79e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d7cf309121ec10e4150860c8caa12a"><td class="memItemLeft" align="right" valign="top">virtual uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">table_cache_type</a> ()</td></tr>
<tr class="separator:ab4d7cf309121ec10e4150860c8caa12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42324038f030519d7476bf915780341"><td class="memItemLeft" align="right" valign="top">virtual my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af42324038f030519d7476bf915780341">register_query_cache_table</a> (THD *thd, char *table_key, size_t key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)</td></tr>
<tr class="memdesc:af42324038f030519d7476bf915780341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a named table with a call back function to the query cache.  <a href="#af42324038f030519d7476bf915780341">More...</a><br /></td></tr>
<tr class="separator:af42324038f030519d7476bf915780341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c885f4b3b5bf6d2878225a188b5599f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1c885f4b3b5bf6d2878225a188b5599f">primary_key_is_clustered</a> () const</td></tr>
<tr class="separator:a1c885f4b3b5bf6d2878225a188b5599f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff2afe807f7e2bbdddb397ee65626ee"><td class="memItemLeft" align="right" valign="top"><a id="a4ff2afe807f7e2bbdddb397ee65626ee"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_ref</b> (const uchar *ref1, const uchar *ref2)</td></tr>
<tr class="separator:a4ff2afe807f7e2bbdddb397ee65626ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e765264bd31e0519e03e1bd53d8c6d2"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">cond_push</a> (const <a class="el" href="classItem.html">Item</a> *cond)</td></tr>
<tr class="separator:a5e765264bd31e0519e03e1bd53d8c6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eb8d2966b848ec4beea5a25cba9dea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">cond_pop</a> ()</td></tr>
<tr class="separator:ac3eb8d2966b848ec4beea5a25cba9dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb554282443af443fc8aae4533e1407"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">idx_cond_push</a> (uint keyno, <a class="el" href="classItem.html">Item</a> *idx_cond)</td></tr>
<tr class="separator:a0bb554282443af443fc8aae4533e1407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc6ba204aa4d1bacc35d9d1d75ab15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a> ()</td></tr>
<tr class="separator:a41cc6ba204aa4d1bacc35d9d1d75ab15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86930bf10b20ad19b3df07e07d28116e"><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a86930bf10b20ad19b3df07e07d28116e">number_of_pushed_joins</a> () const</td></tr>
<tr class="separator:a86930bf10b20ad19b3df07e07d28116e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624f6946109f48559e92a9e7c1b86517"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a624f6946109f48559e92a9e7c1b86517">root_of_pushed_join</a> () const</td></tr>
<tr class="separator:a624f6946109f48559e92a9e7c1b86517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef865015edc575d0a50d1a6f5b13e4a"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaef865015edc575d0a50d1a6f5b13e4a">parent_of_pushed_join</a> () const</td></tr>
<tr class="separator:aaef865015edc575d0a50d1a6f5b13e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38213f889f5312cd3e452fc34d11a201"><td class="memItemLeft" align="right" valign="top"><a id="a38213f889f5312cd3e452fc34d11a201"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_pushed</b> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="separator:a38213f889f5312cd3e452fc34d11a201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f56e97f4fb1faebbc23145492bf541d"><td class="memItemLeft" align="right" valign="top"><a id="a5f56e97f4fb1faebbc23145492bf541d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_next_pushed</b> (uchar *buf)</td></tr>
<tr class="separator:a5f56e97f4fb1faebbc23145492bf541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d800c8dafbc9efde9af932305529e4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">check_if_incompatible_data</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, uint table_changes)</td></tr>
<tr class="separator:a36d800c8dafbc9efde9af932305529e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67890a9deb89b9ef0128601e7687fcba"><td class="memItemLeft" align="right" valign="top">virtual enum_alter_inplace_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a67890a9deb89b9ef0128601e7687fcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecf7f9bf265e6801b625768f0f2bbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad0ecf7f9bf265e6801b625768f0f2bbe">ha_prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:ad0ecf7f9bf265e6801b625768f0f2bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b182710a133be9561afc149cb6aa8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">ha_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a96b182710a133be9561afc149cb6aa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec170a4aa71186f9dc17358b55587c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ec170a4aa71186f9dc17358b55587c7">ha_commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:a6ec170a4aa71186f9dc17358b55587c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81b74b0b7b87de4f99ebe20c49dc44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">ha_notify_table_changed</a> ()</td></tr>
<tr class="separator:a5b81b74b0b7b87de4f99ebe20c49dc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd590a8a08e54f45fbbc250825764d1"><td class="memItemLeft" align="right" valign="top"><a id="acfd590a8a08e54f45fbbc250825764d1"></a>
MY_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acfd590a8a08e54f45fbbc250825764d1">ha_fast_update</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;update_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;update_values, <a class="el" href="classItem.html">Item</a> *conds)</td></tr>
<tr class="memdesc:acfd590a8a08e54f45fbbc250825764d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offload an update to the storage engine. See handler::fast_update() for details. <br /></td></tr>
<tr class="separator:acfd590a8a08e54f45fbbc250825764d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c0b213c30476cce68a11c0f00bb9c3"><td class="memItemLeft" align="right" valign="top"><a id="a84c0b213c30476cce68a11c0f00bb9c3"></a>
MY_NODISCARD int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a84c0b213c30476cce68a11c0f00bb9c3">ha_upsert</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;update_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;update_values)</td></tr>
<tr class="memdesc:a84c0b213c30476cce68a11c0f00bb9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offload an upsert to the storage engine. See handler::upsert() for details. <br /></td></tr>
<tr class="separator:a84c0b213c30476cce68a11c0f00bb9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac21f2d10c4463fb1d7e14882c6314f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a> ()</td></tr>
<tr class="memdesc:adac21f2d10c4463fb1d7e14882c6314f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key  <a href="#adac21f2d10c4463fb1d7e14882c6314f">More...</a><br /></td></tr>
<tr class="separator:adac21f2d10c4463fb1d7e14882c6314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dd7e44bc71120ace1e467ccb02ad06"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr class="separator:ac8dd7e44bc71120ace1e467ccb02ad06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24fcaab09a75e81702c2e2c34fa0b62"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">delete_all_rows</a> ()</td></tr>
<tr class="separator:ac24fcaab09a75e81702c2e2c34fa0b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fdf15d81c256d3e6a9643532ff2126"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">truncate</a> ()</td></tr>
<tr class="separator:a13fdf15d81c256d3e6a9643532ff2126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6916ee6d1e764fa795128fd46164f40d"><td class="memItemLeft" align="right" valign="top"><a id="a6916ee6d1e764fa795128fd46164f40d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a6916ee6d1e764fa795128fd46164f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dd48aaf0c97e43f02180b45517c4c2"><td class="memItemLeft" align="right" valign="top"><a id="a85dd48aaf0c97e43f02180b45517c4c2"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr class="separator:a85dd48aaf0c97e43f02180b45517c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1378edb4813d141f666ce2b9382a4"><td class="memItemLeft" align="right" valign="top"><a id="ac9c1378edb4813d141f666ce2b9382a4"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_and_repair</b> (THD *thd)</td></tr>
<tr class="separator:ac9c1378edb4813d141f666ce2b9382a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272e3a0622ad461a5a86c74ddb9289c6"><td class="memItemLeft" align="right" valign="top"><a id="a272e3a0622ad461a5a86c74ddb9289c6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>disable_indexes</b> (uint mode)</td></tr>
<tr class="separator:a272e3a0622ad461a5a86c74ddb9289c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22328b49eac2417561360bd00bbe8299"><td class="memItemLeft" align="right" valign="top"><a id="a22328b49eac2417561360bd00bbe8299"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>enable_indexes</b> (uint mode)</td></tr>
<tr class="separator:a22328b49eac2417561360bd00bbe8299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561768da16278d66deec08261111dbef"><td class="memItemLeft" align="right" valign="top"><a id="a561768da16278d66deec08261111dbef"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>discard_or_import_tablespace</b> (my_bool discard)</td></tr>
<tr class="separator:a561768da16278d66deec08261111dbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d474cf912188a562e9f419872031e"><td class="memItemLeft" align="right" valign="top"><a id="ac61d474cf912188a562e9f419872031e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>drop_table</b> (const char *name)</td></tr>
<tr class="separator:ac61d474cf912188a562e9f419872031e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741fbc5479d9ee0ccca766f3eca3703f"><td class="memItemLeft" align="right" valign="top"><a id="a741fbc5479d9ee0ccca766f3eca3703f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *name, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)=0</td></tr>
<tr class="separator:a741fbc5479d9ee0ccca766f3eca3703f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fe1bf5cf87a258787ca67a2add8bd1"><td class="memItemLeft" align="right" valign="top"><a id="a75fe1bf5cf87a258787ca67a2add8bd1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create_handler_files</b> (const char *name, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr class="separator:a75fe1bf5cf87a258787ca67a2add8bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370a0f787c1b936e475a5762b91350c"><td class="memItemLeft" align="right" valign="top"><a id="ae370a0f787c1b936e475a5762b91350c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_ha_share_ref</b> (<a class="el" href="classHandler__share.html">Handler_share</a> **arg_ha_share)</td></tr>
<tr class="separator:ae370a0f787c1b936e475a5762b91350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a271a4a135d110cf6f22ae8ce664664"><td class="memItemLeft" align="right" valign="top"><a id="a6a271a4a135d110cf6f22ae8ce664664"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_lock_type</b> () const</td></tr>
<tr class="separator:a6a271a4a135d110cf6f22ae8ce664664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d741fb837dacdddc29c1d7e912204"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af07d741fb837dacdddc29c1d7e912204">update_field_defs_with_zip_dict_info</a> (THD *thd, const char *part_name)</td></tr>
<tr class="separator:af07d741fb837dacdddc29c1d7e912204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f01ea7ce530c3a234e5d17363204f13"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5f01ea7ce530c3a234e5d17363204f13">rpl_lookup_rows</a> ()</td></tr>
<tr class="separator:a5f01ea7ce530c3a234e5d17363204f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade620586d26510ba599c3e7975e8cf39"><td class="memItemLeft" align="right" valign="top"><a id="ade620586d26510ba599c3e7975e8cf39"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_before_write_rows</b> ()</td></tr>
<tr class="separator:ade620586d26510ba599c3e7975e8cf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7bc641b76ed6ba8db016baea0d9f00"><td class="memItemLeft" align="right" valign="top"><a id="a5b7bc641b76ed6ba8db016baea0d9f00"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_after_write_rows</b> ()</td></tr>
<tr class="separator:a5b7bc641b76ed6ba8db016baea0d9f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06882513fd3b53eee1d20bd0a90d46"><td class="memItemLeft" align="right" valign="top"><a id="a6f06882513fd3b53eee1d20bd0a90d46"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_before_delete_rows</b> ()</td></tr>
<tr class="separator:a6f06882513fd3b53eee1d20bd0a90d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa3ebfc3bd1ffa26915db17c452837b"><td class="memItemLeft" align="right" valign="top"><a id="a6fa3ebfc3bd1ffa26915db17c452837b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_after_delete_rows</b> ()</td></tr>
<tr class="separator:a6fa3ebfc3bd1ffa26915db17c452837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f22d5f23dfc16185c7e8f8776fc7fc3"><td class="memItemLeft" align="right" valign="top"><a id="a7f22d5f23dfc16185c7e8f8776fc7fc3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_before_update_rows</b> ()</td></tr>
<tr class="separator:a7f22d5f23dfc16185c7e8f8776fc7fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a966e76173a3c1eb0d8afa8a9acce9"><td class="memItemLeft" align="right" valign="top"><a id="a44a966e76173a3c1eb0d8afa8a9acce9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rpl_after_update_rows</b> ()</td></tr>
<tr class="separator:a44a966e76173a3c1eb0d8afa8a9acce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dad27a5b6b7320e6270138f7d5a0a30"><td class="memItemLeft" align="right" valign="top"><a id="a6dad27a5b6b7320e6270138f7d5a0a30"></a>
virtual Partition_handler *&#160;</td><td class="memItemRight" valign="bottom"><b>get_partition_handler</b> ()</td></tr>
<tr class="separator:a6dad27a5b6b7320e6270138f7d5a0a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa6c449e2194c590eb53b6a6b5dbb362c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa6c449e2194c590eb53b6a6b5dbb362c">my_prepare_gcolumn_template</a> (THD *thd, const char *db_name, const char *table_name, <a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a> myc, void *ib_table)</td></tr>
<tr class="separator:aa6c449e2194c590eb53b6a6b5dbb362c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dd6a07c4f58be3273576d0cc813933"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a32dd6a07c4f58be3273576d0cc813933">my_eval_gcolumn_expr_with_open</a> (THD *thd, const char *db_name, const char *table_name, const MY_BITMAP *const fields, uchar *record)</td></tr>
<tr class="separator:a32dd6a07c4f58be3273576d0cc813933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b30a208b304f519e8d74070a41ac19"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a39b30a208b304f519e8d74070a41ac19">my_eval_gcolumn_expr</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const MY_BITMAP *const fields, uchar *record)</td></tr>
<tr class="separator:a39b30a208b304f519e8d74070a41ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSql__alloc"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSql__alloc')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSql__alloc.html">Sql_alloc</a></td></tr>
<tr class="memitem:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a193100cab44074df6f4f1507b333dcda"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t size)  throw ()</td></tr>
<tr class="separator:a193100cab44074df6f4f1507b333dcda inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a14b17bd7ec22fc7a7e5b56702e5630a6"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t size)  throw ()</td></tr>
<tr class="separator:a14b17bd7ec22fc7a7e5b56702e5630a6 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a13f2eacbb6adcee5c9ac94629e2863b3"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t size, MEM_ROOT *mem_root)  throw ()</td></tr>
<tr class="separator:a13f2eacbb6adcee5c9ac94629e2863b3 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a06adbd3404f702994fd10619c41267f0"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t size, MEM_ROOT *mem_root)  throw ()</td></tr>
<tr class="separator:a06adbd3404f702994fd10619c41267f0 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a1e428ed5b826482a49b1d8a1d246a579"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, size_t size)</td></tr>
<tr class="separator:a1e428ed5b826482a49b1d8a1d246a579 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a7c08622003a34134a56eccaf2d95c0b9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:a7c08622003a34134a56eccaf2d95c0b9 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="ab0c7ed4b5a1eb798f3af463eb84b1e3b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, MEM_ROOT *mem_root)</td></tr>
<tr class="separator:ab0c7ed4b5a1eb798f3af463eb84b1e3b inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_classSql__alloc"><td class="memItemLeft" align="right" valign="top"><a id="a6dd86b56cecc3919504cf5e1452f2511"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, size_t size)</td></tr>
<tr class="separator:a6dd86b56cecc3919504cf5e1452f2511 inherit pub_static_methods_classSql__alloc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a395bae75af9e51a116097a788b2cf57f"><td class="memItemLeft" align="right" valign="top"><a id="a395bae75af9e51a116097a788b2cf57f"></a>
<a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ht</b></td></tr>
<tr class="separator:a395bae75af9e51a116097a788b2cf57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c7037216007ba6140e6cff5162024d"><td class="memItemLeft" align="right" valign="top"><a id="a53c7037216007ba6140e6cff5162024d"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b></td></tr>
<tr class="separator:a53c7037216007ba6140e6cff5162024d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7501dc41ecb010069e8bc9d035aae6aa"><td class="memItemLeft" align="right" valign="top"><a id="a7501dc41ecb010069e8bc9d035aae6aa"></a>
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>dup_ref</b></td></tr>
<tr class="separator:a7501dc41ecb010069e8bc9d035aae6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df561df4b2b6552a7b42189feb0400a"><td class="memItemLeft" align="right" valign="top"><a id="a1df561df4b2b6552a7b42189feb0400a"></a>
<a class="el" href="classha__statistics.html">ha_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b></td></tr>
<tr class="separator:a1df561df4b2b6552a7b42189feb0400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec520eba79eb9f182c534e82c60ebc6"><td class="memItemLeft" align="right" valign="top"><a id="a9ec520eba79eb9f182c534e82c60ebc6"></a>
range_seq_t&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_iter</b></td></tr>
<tr class="separator:a9ec520eba79eb9f182c534e82c60ebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51e423645829d3e540c109556931fa"><td class="memItemLeft" align="right" valign="top"><a id="a2a51e423645829d3e540c109556931fa"></a>
<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_funcs</b></td></tr>
<tr class="separator:a2a51e423645829d3e540c109556931fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52372127bd238a7f622190316ba8124f"><td class="memItemLeft" align="right" valign="top"><a id="a52372127bd238a7f622190316ba8124f"></a>
<a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>multi_range_buffer</b></td></tr>
<tr class="separator:a52372127bd238a7f622190316ba8124f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a476dfe8526807dfc820c4b09f7a6d1"><td class="memItemLeft" align="right" valign="top"><a id="a1a476dfe8526807dfc820c4b09f7a6d1"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>ranges_in_seq</b></td></tr>
<tr class="separator:a1a476dfe8526807dfc820c4b09f7a6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff4dfb21c4583b55afc4fe5aba50389"><td class="memItemLeft" align="right" valign="top"><a id="adff4dfb21c4583b55afc4fe5aba50389"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_is_output_sorted</b></td></tr>
<tr class="separator:adff4dfb21c4583b55afc4fe5aba50389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2632d137c3a17fa583f08db5681e80a"><td class="memItemLeft" align="right" valign="top"><a id="af2632d137c3a17fa583f08db5681e80a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_have_range</b></td></tr>
<tr class="separator:af2632d137c3a17fa583f08db5681e80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2347edc229832e533d1fb73b236e32b"><td class="memItemLeft" align="right" valign="top"><a id="af2347edc229832e533d1fb73b236e32b"></a>
KEY_MULTI_RANGE&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_cur_range</b></td></tr>
<tr class="separator:af2347edc229832e533d1fb73b236e32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d698fe9901f0f487c9618ddbb0f1be"><td class="memItemLeft" align="right" valign="top"><a id="a28d698fe9901f0f487c9618ddbb0f1be"></a>
key_range *&#160;</td><td class="memItemRight" valign="bottom"><b>end_range</b></td></tr>
<tr class="separator:a28d698fe9901f0f487c9618ddbb0f1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3186b7c7a70634a8e9758ed51708359c"><td class="memItemLeft" align="right" valign="top"><a id="a3186b7c7a70634a8e9758ed51708359c"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>errkey</b></td></tr>
<tr class="separator:a3186b7c7a70634a8e9758ed51708359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad5efc62f32ef66b55667fd8370ef33"><td class="memItemLeft" align="right" valign="top"><a id="a5ad5efc62f32ef66b55667fd8370ef33"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>key_used_on_scan</b></td></tr>
<tr class="separator:a5ad5efc62f32ef66b55667fd8370ef33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f2838eebffef46663c19f85d2ad2cc"><td class="memItemLeft" align="right" valign="top"><a id="a29f2838eebffef46663c19f85d2ad2cc"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>active_index</b></td></tr>
<tr class="separator:a29f2838eebffef46663c19f85d2ad2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64def328ff0ca7e391b217c2d3a758ec"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a></td></tr>
<tr class="separator:a64def328ff0ca7e391b217c2d3a758ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943005f89e7a6d5cee246e1c5b46e9ab"><td class="memItemLeft" align="right" valign="top"><a id="a943005f89e7a6d5cee246e1c5b46e9ab"></a>
FT_INFO *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_handler</b></td></tr>
<tr class="separator:a943005f89e7a6d5cee246e1c5b46e9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae346e9156bcf1dd515eef535c40ca601"><td class="memItemLeft" align="right" valign="top"><a id="ae346e9156bcf1dd515eef535c40ca601"></a>
enum handler:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>inited</b></td></tr>
<tr class="separator:ae346e9156bcf1dd515eef535c40ca601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd47d68a7b406d8777396a657095d5e8"><td class="memItemLeft" align="right" valign="top"><a id="afd47d68a7b406d8777396a657095d5e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>implicit_emptied</b></td></tr>
<tr class="separator:afd47d68a7b406d8777396a657095d5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2f8d7155cb44162bb4181cb09f2f3"><td class="memItemLeft" align="right" valign="top"><a id="a0ed2f8d7155cb44162bb4181cb09f2f3"></a>
const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_cond</b></td></tr>
<tr class="separator:a0ed2f8d7155cb44162bb4181cb09f2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b3d956f73649657bad389acfad5f0b"><td class="memItemLeft" align="right" valign="top"><a id="ae9b3d956f73649657bad389acfad5f0b"></a>
<a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond</b></td></tr>
<tr class="separator:ae9b3d956f73649657bad389acfad5f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc8d81143d1c9c10b976711fe44cf37"><td class="memItemLeft" align="right" valign="top"><a id="a4dc8d81143d1c9c10b976711fe44cf37"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond_keyno</b></td></tr>
<tr class="separator:a4dc8d81143d1c9c10b976711fe44cf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02710c45cf96dacef1109b49de048ee"><td class="memItemLeft" align="right" valign="top"><a id="ae02710c45cf96dacef1109b49de048ee"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>rows_read</b></td></tr>
<tr class="separator:ae02710c45cf96dacef1109b49de048ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d78935307f2f6fc1d918ddc30ef8d7"><td class="memItemLeft" align="right" valign="top"><a id="a77d78935307f2f6fc1d918ddc30ef8d7"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>rows_changed</b></td></tr>
<tr class="separator:a77d78935307f2f6fc1d918ddc30ef8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73622d661f0eb2a305f8bff3a9b99c18"><td class="memItemLeft" align="right" valign="top"><a id="a73622d661f0eb2a305f8bff3a9b99c18"></a>
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>index_rows_read</b> [MAX_KEY]</td></tr>
<tr class="separator:a73622d661f0eb2a305f8bff3a9b99c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ab295e407d8a5c50087fed0f4fcd18"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a></td></tr>
<tr class="separator:a62ab295e407d8a5c50087fed0f4fcd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd2cafd83ae60562649bf9688aebf1"><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a></td></tr>
<tr class="separator:a05dd2cafd83ae60562649bf9688aebf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540a47a05c03724f1102aaaa623131e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDiscrete__interval.html">Discrete_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a></td></tr>
<tr class="separator:a1540a47a05c03724f1102aaaa623131e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfcef0738a89138c8f41ded8da17c0a"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a></td></tr>
<tr class="separator:acdfcef0738a89138c8f41ded8da17c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e7cba3fe3bf9731a91be82983cc35"><td class="memItemLeft" align="right" valign="top">PSI_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a></td></tr>
<tr class="separator:a881e7cba3fe3bf9731a91be82983cc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae5b7b96354fd25da35a940e656d91940"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae5b7b96354fd25da35a940e656d91940">records</a> (ha_rows *num_rows)</td></tr>
<tr class="separator:ae5b7b96354fd25da35a940e656d91940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c2b258691e5baac8dd22d19c084b37"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">index_read_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:af8c2b258691e5baac8dd22d19c084b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#af8c2b258691e5baac8dd22d19c084b37">More...</a><br /></td></tr>
<tr class="separator:af8c2b258691e5baac8dd22d19c084b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba0c549a00023dd44682cd9452cf830"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">index_read_idx_map</a> (uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr class="memdesc:acba0c549a00023dd44682cd9452cf830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#acba0c549a00023dd44682cd9452cf830">More...</a><br /></td></tr>
<tr class="separator:acba0c549a00023dd44682cd9452cf830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca48f687872e10a4fdc35b418d98b761"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">index_next</a> (uchar *buf)</td></tr>
<tr class="separator:aca48f687872e10a4fdc35b418d98b761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab892ae78db6437119d2d25621118b7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">index_prev</a> (uchar *buf)</td></tr>
<tr class="separator:a1ab892ae78db6437119d2d25621118b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37bd518c53c966459632584c34855d0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">index_first</a> (uchar *buf)</td></tr>
<tr class="separator:af37bd518c53c966459632584c34855d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d62ffab7408a031b13e547eb58be09"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">index_last</a> (uchar *buf)</td></tr>
<tr class="separator:aa1d62ffab7408a031b13e547eb58be09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5459b92420f74e6f88dec137e1941d22"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">index_next_same</a> (uchar *buf, const uchar *key, uint keylen)</td></tr>
<tr class="separator:a5459b92420f74e6f88dec137e1941d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae069d5991214e1fdf14cc44fd865a180"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">index_read_last_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr class="memdesc:ae069d5991214e1fdf14cc44fd865a180"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="#ae069d5991214e1fdf14cc44fd865a180">More...</a><br /></td></tr>
<tr class="separator:ae069d5991214e1fdf14cc44fd865a180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b748cb37f18c1db0a6dfc016a32b86"><td class="memItemLeft" align="right" valign="top"><a id="a76b748cb37f18c1db0a6dfc016a32b86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_using_full_unique_key</b> (uint active_index, key_part_map keypart_map, enum ha_rkey_function find_flag) const</td></tr>
<tr class="separator:a76b748cb37f18c1db0a6dfc016a32b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe486748715adbe6f7d6b9a9228cdf4"><td class="memItemLeft" align="right" valign="top"><a id="a5fe486748715adbe6f7d6b9a9228cdf4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_using_prohibited_gap_locks</b> (<a class="el" href="structTABLE.html">TABLE</a> *table, bool using_full_primary_key) const</td></tr>
<tr class="separator:a5fe486748715adbe6f7d6b9a9228cdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03831da80c8a99422edd4b4ab84fa55a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a03831da80c8a99422edd4b4ab84fa55a">prepare_index_key_scan</a> (const uchar *key, uint key_len)</td></tr>
<tr class="separator:a03831da80c8a99422edd4b4ab84fa55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cb9c94ca93dbfbb7e92822caba82a1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">rnd_next</a> (uchar *buf)=0</td></tr>
<tr class="separator:a48cb9c94ca93dbfbb7e92822caba82a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf659edd9d870e90c8974ae0eba7a082"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">rnd_pos</a> (uchar *buf, uchar *pos)=0</td></tr>
<tr class="separator:adf659edd9d870e90c8974ae0eba7a082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25b3931a457f1821ba55ae9cce79d98"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:ab25b3931a457f1821ba55ae9cce79d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b4c3a8fe1c89c6ccfec1f4b144754a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr class="separator:a90b4c3a8fe1c89c6ccfec1f4b144754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0786a5f57ccd3c97bff07b1afeae9c06"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr class="separator:a0786a5f57ccd3c97bff07b1afeae9c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aaaf2105e60ca590b79fae82e48960"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed</a> ()</td></tr>
<tr class="separator:a26aaaf2105e60ca590b79fae82e48960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25b44b50ac64192d6cfef591252ed7"><td class="memItemLeft" align="right" valign="top"><a id="aad25b44b50ac64192d6cfef591252ed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_statistic_increment</b> (ulonglong SSV::*offset) const</td></tr>
<tr class="separator:aad25b44b50ac64192d6cfef591252ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df65ee64bcedb5a4b34bf752b2fab08"><td class="memItemLeft" align="right" valign="top"><a id="a9df65ee64bcedb5a4b34bf752b2fab08"></a>
THD *&#160;</td><td class="memItemRight" valign="bottom"><b>ha_thd</b> (void) const</td></tr>
<tr class="separator:a9df65ee64bcedb5a4b34bf752b2fab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69803cd29d92bfecd97212354212c516"><td class="memItemLeft" align="right" valign="top">PSI_table_share *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a69803cd29d92bfecd97212354212c516">ha_table_share_psi</a> (const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share) const</td></tr>
<tr class="separator:a69803cd29d92bfecd97212354212c516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bf8fa32d87654794e6b1c3b3fb8d32"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">rename_table</a> (const char *from, const char *to)</td></tr>
<tr class="separator:a58bf8fa32d87654794e6b1c3b3fb8d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53ec34116b901cc08e5a87f5ec681a6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">delete_table</a> (const char *name)</td></tr>
<tr class="separator:ae53ec34116b901cc08e5a87f5ec681a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccf806316a9d88a7130d70e7637e8e5"><td class="memItemLeft" align="right" valign="top"><a id="a4ccf806316a9d88a7130d70e7637e8e5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read</b> (uchar *buf, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr class="separator:a4ccf806316a9d88a7130d70e7637e8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90af353b21f935dc95212e1cfef50452"><td class="memItemLeft" align="right" valign="top"><a id="a90af353b21f935dc95212e1cfef50452"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_last</b> (uchar *buf, const uchar *key, uint key_len)</td></tr>
<tr class="separator:a90af353b21f935dc95212e1cfef50452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf21a8ad4be872bbfe94f5cb40abca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHandler__share.html">Handler_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a> ()</td></tr>
<tr class="separator:a13bf21a8ad4be872bbfe94f5cb40abca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24470ac1d4ac336cedbe7c245d321c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a> (<a class="el" href="classHandler__share.html">Handler_share</a> *arg_ha_share)</td></tr>
<tr class="separator:ab24470ac1d4ac336cedbe7c245d321c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a39db9dc1cca31f4a3ec0e0e1d7300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a> ()</td></tr>
<tr class="separator:aa3a39db9dc1cca31f4a3ec0e0e1d7300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059bbed3de416b3bea51c69dc064e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a> ()</td></tr>
<tr class="separator:a8059bbed3de416b3bea51c69dc064e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ae2613bd83c495f55fe2ce05a9df2d86f"><td class="memItemLeft" align="right" valign="top"><a id="ae2613bd83c495f55fe2ce05a9df2d86f"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_using_full_key</b> (key_part_map keypart_map, uint <a class="el" href="group__Query__Optimizer.html#ga6609ac0420a8a415d5a57cc6659f460d">actual_key_parts</a>)</td></tr>
<tr class="separator:ae2613bd83c495f55fe2ce05a9df2d86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3b094cfe680aa06a7d8b70194415aa3b"><td class="memItemLeft" align="right" valign="top"><a id="a3b094cfe680aa06a7d8b70194415aa3b"></a>
<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table_share</b></td></tr>
<tr class="separator:a3b094cfe680aa06a7d8b70194415aa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0d051d1ef534891b27612cc4ff56f7"><td class="memItemLeft" align="right" valign="top"><a id="abb0d051d1ef534891b27612cc4ff56f7"></a>
<a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table</b></td></tr>
<tr class="separator:abb0d051d1ef534891b27612cc4ff56f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98743b18a24c8baef7e22a11df74d6c9"><td class="memItemLeft" align="right" valign="top"><a id="a98743b18a24c8baef7e22a11df74d6c9"></a>
Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_flags</b></td></tr>
<tr class="separator:a98743b18a24c8baef7e22a11df74d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44b6a4c101f982cd13a344dce5a870"><td class="memItemLeft" align="right" valign="top"><a id="adf44b6a4c101f982cd13a344dce5a870"></a>
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>estimation_rows_to_insert</b></td></tr>
<tr class="separator:adf44b6a4c101f982cd13a344dce5a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011df14ecc738037499572c304d8ee90"><td class="memItemLeft" align="right" valign="top"><a id="a011df14ecc738037499572c304d8ee90"></a>
<a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>range_key_part</b></td></tr>
<tr class="separator:a011df14ecc738037499572c304d8ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272c3d9b40a9e7c5de20ed390d23a636"><td class="memItemLeft" align="right" valign="top"><a id="a272c3d9b40a9e7c5de20ed390d23a636"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>eq_range</b></td></tr>
<tr class="separator:a272c3d9b40a9e7c5de20ed390d23a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a159ca294d8dafe32405e6ad546e6a4"><td class="memItemLeft" align="right" valign="top"><a id="a1a159ca294d8dafe32405e6ad546e6a4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>in_range_check_pushed_down</b></td></tr>
<tr class="separator:a1a159ca294d8dafe32405e6ad546e6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0e1b518f74dfed5dde6f5f902f264f39"><td class="memItemLeft" align="right" valign="top"><a id="a0e1b518f74dfed5dde6f5f902f264f39"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Partition_handler</b></td></tr>
<tr class="separator:a0e1b518f74dfed5dde6f5f902f264f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576b2e6999b5b4fbe40abb7870fe33b2"><td class="memItemLeft" align="right" valign="top"><a id="a576b2e6999b5b4fbe40abb7870fe33b2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DsMrr_impl</b></td></tr>
<tr class="separator:a576b2e6999b5b4fbe40abb7870fe33b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">The handler class is the interface for dynamically loadable storage engines. Do not add ifdefs and take care when adding or changing virtual functions to avoid vtable confusion</p>
<p class="">Functions in this class accept and return table columns data. Two data representation formats are used:</p><ol type="1">
<li>TableRecordFormat - Used to pass [partial] table records to/from storage engine</li>
<li>KeyTupleFormat - used to pass index search tuples (aka "keys") to storage engine. See opt_range.cc for description of this format.</li>
</ol>
<h1>TableRecordFormat </h1>
<p class="">[Warning: this description is work in progress and may be incomplete] The table record is stored in a fixed-size buffer:</p>
<p class="">record: null_bytes, column1_data, column2_data, ...</p>
<p class="">The offsets of the parts of the buffer are also fixed: every column has an offset to its column{i}_data, and if it is nullable it also has its own bit in null_bytes.</p>
<p class="">The record buffer only includes data about columns that are marked in the relevant column set (table-&gt;read_set and/or table-&gt;write_set, depending on the situation). &lt;not-sure&gt;It could be that it is required that null bits of non-present columns are set to 1&lt;/not-sure&gt;</p>
<p class="">VARIOUS EXCEPTIONS AND SPECIAL CASES</p>
<p class="">f the table has no nullable columns, then null_bytes is still present, its length is one byte &lt;not-sure&gt; which must be set to 0xFF at all times. &lt;/not-sure&gt;</p>
<p class="">If the table has columns of type BIT, then certain bits from those columns may be stored in null_bytes as well. Grep around for <a class="el" href="classField__bit.html">Field_bit</a> for details.</p>
<p class="">For blob columns (see <a class="el" href="classField__blob.html">Field_blob</a>), the record buffer stores length of the data, following by memory pointer to the blob data. The pointer is owned by the storage engine and is valid until the next operation.</p>
<p class="">If a blob column has NULL value, then its length and blob data pointer must be set to 0. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad4c241e50948859d98ceae6e39066838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c241e50948859d98ceae6e39066838">&#9670;&nbsp;</a></span>my_gcolumn_template_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* handler::my_gcolumn_template_callback_t) (const <a class="el" href="structTABLE.html">TABLE</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Callback function that will be called by my_prepare_gcolumn_template once the table has been opened. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a748d5e5b6dbbb0681cbac2ad881505c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748d5e5b6dbbb0681cbac2ad881505c9">&#9670;&nbsp;</a></span>bas_ext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char** handler::bas_ext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If frm_error() is called then we will use this to find out what file extentions exist for the storage engine. This is also used by the default rename_table and delete_table method in <a class="el" href="handler_8cc.html" title="Handler-calling-functions.">handler.cc</a>.</p>
<p class="">For engines that have two file name extentions (separate meta/index file and data file), the order of elements is relevant. First element of engine file name extentions array should be meta/index file extention. Second element - data file extention. This order is assumed by prepare_for_repair() when REPAIR <a class="el" href="structTABLE.html">TABLE</a> ... USE_FRM is issued. </p>

<p>Implemented in <a class="el" href="classha__ndbcluster.html#ade5341ce688c24b5885145f821cdf249">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#ae7153997d64cb4e94ce23ecfb92714fb">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="ac8dd7e44bc71120ace1e467ccb02ad06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dd7e44bc71120ace1e467ccb02ad06">&#9670;&nbsp;</a></span>bulk_update_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::bulk_update_row </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">This method is similar to update_row, however the handler doesn't need to execute the updates at this point in time. The handler can be certain that another call to bulk_update_row will occur OR a call to exec_bulk_update before the set of updates in this query is concluded.</p>
<p class="">Note: If HA_ERR_FOUND_DUPP_KEY is returned, the handler must read all columns of the row so MySQL can create an error message. If the columns required for the error message are not read, the error message will contain garbage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_data</td><td>Old record </td></tr>
    <tr><td class="paramname">new_data</td><td>New record </td></tr>
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a89cbc7ca67dcd89d07693186f5de7ca5">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a6baab93a22543b707e6e59b9d59810d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6baab93a22543b707e6e59b9d59810d2">&#9670;&nbsp;</a></span>can_switch_engines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::can_switch_engines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Used in ALTER <a class="el" href="structTABLE.html">TABLE</a> to check if changing storage engine is allowed.</p>
<dl class="section note"><dt>Note</dt><dd>Called without holding thr_lock.c lock.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Changing storage engine is allowed. </td></tr>
    <tr><td class="paramname">false</td><td>Changing storage engine not allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a3fe3719d8dd1d5f41467250d632abd3c">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a41cc6ba204aa4d1bacc35d9d1d75ab15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cc6ba204aa4d1bacc35d9d1d75ab15">&#9670;&nbsp;</a></span>cancel_pushed_idx_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::cancel_pushed_idx_cond </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Reset information about pushed index conditions </p>

</div>
</div>
<a id="a234580f9765751ce185182dd1edc3bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234580f9765751ce185182dd1edc3bdb">&#9670;&nbsp;</a></span>check_collation_compatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::check_collation_compatibility </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check for incompatible collation changes.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ADMIN_NEEDS_UPGRADE</td><td>Table may have data requiring upgrade. </td></tr>
    <tr><td class="paramname">0</td><td>No upgrade required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36d800c8dafbc9efde9af932305529e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d800c8dafbc9efde9af932305529e4">&#9670;&nbsp;</a></span>check_if_incompatible_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::check_if_incompatible_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Part of old, deprecated in-place ALTER API. </p>

</div>
</div>
<a id="a67890a9deb89b9ef0128601e7687fcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67890a9deb89b9ef0128601e7687fcba">&#9670;&nbsp;</a></span>check_if_supported_inplace_alter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum_alter_inplace_result handler::check_if_supported_inplace_alter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Check if a storage engine supports a particular alter table in-place</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ALTER_ERROR</td><td>Unexpected error. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NOT_SUPPORTED</td><td>Not supported, must use copy. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_EXCLUSIVE_LOCK</td><td>Supported, but requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</td><td>Supported, but requires SNW lock during main phase. Prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK</td><td>Supported, but requires SNW lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE</td><td>Supported, concurrent reads/writes allowed. However, prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK</td><td>Supported, concurrent reads/writes allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The default implementation uses the old in-place ALTER API to determine if the storage engine supports in-place ALTER or not.</dd>
<dd>
Called without holding thr_lock.c lock. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a178fe8e973508932db3d3d6ca3a625a9">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a4de97045e5381007565fd2b0da235c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de97045e5381007565fd2b0da235c07">&#9670;&nbsp;</a></span>column_bitmaps_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::column_bitmaps_signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>MySQL signal that it changed the column bitmap. </p>
<p class="">Signal that the table-&gt;read_set and table-&gt;write_set table maps changed The handler is allowed to set additional bits in the above map in this call. Normally the handler should ignore all calls until we have done a <a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init()</a> or <a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init()</a>, write_row(), update_row or delete_row() as there may be several calls to this routine.</p>
<p class="">USAGE This is for handlers that needs to setup their own column bitmaps. Normally the handler should set up their own column bitmaps in index_init() or rnd_init() and in any <a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07" title="MySQL signal that it changed the column bitmap.">column_bitmaps_signal()</a> call after this.</p>
<p class="">The handler is allowd to do changes to the bitmap after a index_init or rnd_init() call is made as after this, MySQL will not use the bitmap for any program logic checking. </p>

</div>
</div>
<a id="a0786a5f57ccd3c97bff07b1afeae9c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0786a5f57ccd3c97bff07b1afeae9c06">&#9670;&nbsp;</a></span>commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Commit or rollback the changes made during <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> and <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> inside the storage engine. Note that in case of rollback the allowed level of concurrency during this operation will be the same as for <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> and thus might be higher than during <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a>. (For example, concurrent writes were blocked during prepare, but might not be during rollback).</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function with commit= true reports error, it will be called again with commit= false.</dd>
<dd>
In case of partitioning, this function might be called for rollback without <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> having been called first. Also partitioned tables sets ha_alter_info-&gt;group_commit_ctx to a NULL terminated array of the partitions handlers and if all of them are committed as one, then group_commit_ctx should be set to NULL to indicate to the partitioning handler that all partitions handlers are committed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">commit</td><td>True =&gt; Commit, False =&gt; Rollback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#af55db4a0efc9c99947b72b4bfc83b8ad">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="af0ef38e7407e87ba5d1ccde59c3e94bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ef38e7407e87ba5d1ccde59c3e94bb">&#9670;&nbsp;</a></span>compare_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::compare_key </td>
          <td>(</td>
          <td class="paramtype">key_range *&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Compare if found key (in row) is over max-value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>range to compare to row. May be 0 for no range</td></tr>
  </table>
  </dd>
</dl>
<p>key.cc::key_cmp()</p>
<dl class="section return"><dt>Returns</dt><dd>The return value is SIGN(key_in_row - range_key):</dd></dl>
<ul>
<li>0 : <a class="el" href="classKey.html">Key</a> is equal to range or 'range' == 0 (no range)</li>
<li>-1 : <a class="el" href="classKey.html">Key</a> is less than range</li>
<li>1 : <a class="el" href="classKey.html">Key</a> is larger than range </li>
</ul>

</div>
</div>
<a id="aeac3d9b9796d3bfb18b96a1989d6f516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac3d9b9796d3bfb18b96a1989d6f516">&#9670;&nbsp;</a></span>compare_key_in_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::compare_key_in_buffer </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check if the key in the given buffer (which is not necessarily TABLE::record[0]) is within range. Called by the storage engine to avoid reading too many rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the buffer that holds the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if the key is within the range </td></tr>
    <tr><td class="paramname">0</td><td>if the key is equal to the end_range key, and key_compare_result_on_equal is 0 </td></tr>
    <tr><td class="paramname">1</td><td>if the key is outside the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3eb8d2966b848ec4beea5a25cba9dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3eb8d2966b848ec4beea5a25cba9dea">&#9670;&nbsp;</a></span>cond_pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::cond_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Pop the top condition from the condition stack of the handler instance.</p>
<p class="">Pops the top if condition stack, if stack is not empty. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a0de805435e8251f27ba3394052f6b1c7">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a5e765264bd31e0519e03e1bd53d8c6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e765264bd31e0519e03e1bd53d8c6d2">&#9670;&nbsp;</a></span>cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classItem.html">Item</a>* handler::cond_push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Push condition down to the table handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to be pushed. The condition tree must not be modified by the by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 'remainder' condition that caller must use to filter out records. NULL means the handler will not return rows that do not match the passed condition.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The pushed conditions form a stack (from which one can remove the last pushed condition using cond_pop). The table handler filters out rows using (pushed_cond1 AND pushed_cond2 AND ... AND pushed_condN) or less restrictive condition, depending on handler's capabilities.</dd></dl>
<p>handler-&gt;<a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42" title="Check handler usage and reset state of file to after &#39;open&#39;.">ha_reset()</a> call empties the condition stack. Calls to rnd_init/rnd_end, index_init/index_end etc do not affect the condition stack. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a2285b3af9153f052ef6ba0cfc3bacea1">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="ac24fcaab09a75e81702c2e2c34fa0b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24fcaab09a75e81702c2e2c34fa0b62">&#9670;&nbsp;</a></span>delete_all_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::delete_all_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">This is called to delete all rows in a table If the handler don't support this, then this function will return HA_ERR_WRONG_COMMAND and MySQL will delete the rows one by one. </p>

</div>
</div>
<a id="ae53ec34116b901cc08e5a87f5ec681a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53ec34116b901cc08e5a87f5ec681a6">&#9670;&nbsp;</a></span>delete_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Delete a table in the engine. Called for base as well as temporary tables.</p>
<p class="">Delete all files with extension from <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Base name of table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>We assume that the handler may return more extensions than was actually used for the file.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If we successfully deleted at least one file from base_ext and didn't get any other errors than ENOENT </td></tr>
    <tr><td class="paramname">!0</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a4d32721908372dc62c490e14a005e03c">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="af5f9f1ca2b5efc0b41e96c6b793d9bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f9f1ca2b5efc0b41e96c6b793d9bb1">&#9670;&nbsp;</a></span>end_bulk_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::end_bulk_delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Execute all outstanding deletes and close down the bulk delete.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bf6c46d66ca282a4cbd6118e4c99e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf6c46d66ca282a4cbd6118e4c99e03">&#9670;&nbsp;</a></span>end_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::end_bulk_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Perform any needed clean-up, no outstanding updates are there at the moment. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a3c3b80b72e921059f62aed3eda1db911">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="ab6a860cb6d6cb731416080acc8f179e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a860cb6d6cb731416080acc8f179e0">&#9670;&nbsp;</a></span>end_psi_batch_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::end_psi_batch_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">End a batch started with <code>start_psi_batch_mode</code>. </p>

</div>
</div>
<a id="a517d99c283e85e8d97460f07a781dabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517d99c283e85e8d97460f07a781dabf">&#9670;&nbsp;</a></span>end_read_removal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows handler::end_read_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">End read (before write) removal and return the number of rows really written </p><dl class="section see"><dt>See also</dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a81e58b0a19c7cc7d857a3f00e039ae37">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="ae59e9a1d36d852f4dd5dd00bff5f1ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59e9a1d36d852f4dd5dd00bff5f1ae4">&#9670;&nbsp;</a></span>estimate_rows_upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows handler::estimate_rows_upper_bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Return upper bound of current number of records in the table (max. of how many records one will retrieve when doing a full table scan) If upper bound is not known, HA_POS_ERROR should be returned as a max possible upper bound. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a59555b02c52fc703e99a41d3ee3a04c3">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#a343b6837bb14a74236095276dec644dd">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="a886bf2fbf16de7e200e3ebc0765fb6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886bf2fbf16de7e200e3ebc0765fb6e4">&#9670;&nbsp;</a></span>exec_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::exec_bulk_update </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">After this call all outstanding updates must be performed. The number of duplicate key errors are reported in the duplicate key parameter. It is allowed to continue to the batched update after this call, the handler has to wait until end_bulk_update with changing state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a5c9f552924c7168373ab0d1c2ba0e049">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="aaf6af760a4ef09984a5cc1dc58db9a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6af760a4ef09984a5cc1dc58db9a40">&#9670;&nbsp;</a></span>get_auto_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::get_auto_increment </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Reserves an interval of auto_increment values from the handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>offset (modulus increment) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">increment</td><td>increment between calls </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_desired_values</td><td>how many values we want </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_value</td><td>the first value reserved by the handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_reserved_values</td><td>how many values the handler reserved</td></tr>
  </table>
  </dd>
</dl>
<p>offset and increment means that we want values to be of the form offset + N * increment, where N&gt;=0 is integer. If the function sets *first_value to ULLONG_MAX it means an error. If the function sets *nb_reserved_values to ULLONG_MAX it means it has reserved to "positive infinite". </p>

</div>
</div>
<a id="a683eef70b4481c3bc0b10336e179de27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683eef70b4481c3bc0b10336e179de27">&#9670;&nbsp;</a></span>get_cascade_foreign_key_table_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::get_cascade_foreign_key_table_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__handler__tablename.html">st_handler_tablename</a> &gt; *&#160;</td>
          <td class="paramname"><em>fk_table_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the list of tables which are direct or indirect parents in foreign key with cascading actions for this table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the set of parent tables connected by FK clause that can modify the given table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fk_table_list</td><td><a class="el" href="classList.html">List</a> of parent tables (including indirect parents). Elements of the list as well as buffers for database and schema names are allocated from the current memory root.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handler error code or zero for success </dd></dl>

</div>
</div>
<a id="ad5eede0999f8273864faa40c5e181793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eede0999f8273864faa40c5e181793">&#9670;&nbsp;</a></span>get_dup_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint handler::get_dup_key </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>key if error because of duplicated keys </dd></dl>

</div>
</div>
<a id="afce8ffd064ce683481494c7503ef820c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce8ffd064ce683481494c7503ef820c">&#9670;&nbsp;</a></span>get_error_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::get_error_message </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Return an error message specific to this handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code previously returned by handler </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to String where to add error message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this is a temporary error </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a31a5f675ffb30d67ba91bb1cb9ec9dc8">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#ab3693b75133ce5d4e4861ef5627ebbdc">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="a20878b1fb8d31b91dbf53ac963d90f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20878b1fb8d31b91dbf53ac963d90f78">&#9670;&nbsp;</a></span>get_foreign_dup_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::get_foreign_dup_key </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>child_table_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_key_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>child_key_name_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Retrieves the names of the table and the key for which there was a duplicate entry in the case of HA_ERR_FOREIGN_DUPLICATE_KEY.</p>
<p class="">If any of the table or key name is not available this method will return false and will not change any of child_table_name or child_key_name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_table_name[out]</td><td>Table name </td></tr>
    <tr><td class="paramname">child_table_name_len[in]</td><td>Table name buffer size </td></tr>
    <tr><td class="paramname">child_key_name[out]</td><td><a class="el" href="classKey.html">Key</a> name </td></tr>
    <tr><td class="paramname">child_key_name_len[in]</td><td><a class="el" href="classKey.html">Key</a> name buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>table and key names were available and were written into the corresponding out parameters. </td></tr>
    <tr><td class="paramname">false</td><td>table and key names were not available, the out parameters were not touched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81064e61d4c08261af409fb6ee34e3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81064e61d4c08261af409fb6ee34e3ca">&#9670;&nbsp;</a></span>get_foreign_key_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::get_foreign_key_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the list of foreign keys in this table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the set of foreign keys where this table is the dependent or child table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handler error code or zero for success. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a3b97152a2ce0d7e7622de70daae4171b">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a13bf21a8ad4be872bbfe94f5cb40abca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bf21a8ad4be872bbfe94f5cb40abca">&#9670;&nbsp;</a></span>get_ha_share_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHandler__share.html">Handler_share</a> * handler::get_ha_share_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get an initialized ha_share.</p>
<dl class="section return"><dt>Returns</dt><dd>Initialized ha_share </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>ha_share is not yet initialized. </td></tr>
    <tr><td class="paramname">!=</td><td>NULL previous initialized ha_share.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If not a temp table, then LOCK_ha_data must be held. </dd></dl>

</div>
</div>
<a id="a475f7fbe39f6ff0e9da2ac6c3d6c629e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475f7fbe39f6ff0e9da2ac6c3d6c629e">&#9670;&nbsp;</a></span>get_memory_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual longlong handler::get_memory_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Return an estimate on the amount of memory the storage engine will use for caching data in memory. If this is unknown or the storage engine does not cache data in memory -1 is returned. </p>

</div>
</div>
<a id="a9187eea9999eba802ee4ae01f91dda3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9187eea9999eba802ee4ae01f91dda3b">&#9670;&nbsp;</a></span>get_parent_foreign_key_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::get_parent_foreign_key_list </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the list of foreign keys referencing this table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the set of foreign keys where this table is the referenced or parent table.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handler error code or zero for success. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a8ef2926a38b2b39387ad40c55708faa2">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a163a360c0cd4575ae207553b8d5c918d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163a360c0cd4575ae207553b8d5c918d">&#9670;&nbsp;</a></span>get_row_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum row_type handler::get_row_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get the row type from the storage engine. If this method returns ROW_TYPE_NOT_USED, the information in HA_CREATE_INFO should be used. </p>

</div>
</div>
<a id="a66cc9e4971b8e768c102398da0656a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cc9e4971b8e768c102398da0656a7f">&#9670;&nbsp;</a></span>ha_analyze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_analyze </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Analyze table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::analyze() </dd></dl>

</div>
</div>
<a id="a49c8ce82a564b0cbf6340dc9b74a9c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c8ce82a564b0cbf6340dc9b74a9c23">&#9670;&nbsp;</a></span>ha_bulk_update_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_bulk_update_row </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Bulk update row: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">handler::bulk_update_row()</a> </dd></dl>

</div>
</div>
<a id="a56545ec9967544c80d5612f8ac9b8e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56545ec9967544c80d5612f8ac9b8e6e">&#9670;&nbsp;</a></span>ha_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_check </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">to be actually called to get 'check()' functionality</p>
<p class="">Performs checks upon the table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread doing CHECK <a class="el" href="structTABLE.html">TABLE</a> operation </td></tr>
    <tr><td class="paramname">check_opt</td><td>options from the parser</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ADMIN_OK</td><td>Successful upgrade </td></tr>
    <tr><td class="paramname">HA_ADMIN_NEEDS_UPGRADE</td><td>Table has structures requiring upgrade </td></tr>
    <tr><td class="paramname">HA_ADMIN_NEEDS_ALTER</td><td>Table has structures requiring ALTER <a class="el" href="structTABLE.html">TABLE</a> </td></tr>
    <tr><td class="paramname">HA_ADMIN_NOT_IMPLEMENTED</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169d5287bdf480f8cd20f758bb2d9bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169d5287bdf480f8cd20f758bb2d9bd1">&#9670;&nbsp;</a></span>ha_check_and_repair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::ha_check_and_repair </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Check and repair table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::check_and_repair() </dd></dl>

</div>
</div>
<a id="ae28824cdff2c1812e282463c908e84c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28824cdff2c1812e282463c908e84c2">&#9670;&nbsp;</a></span>ha_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Close handler. </p>

</div>
</div>
<a id="a6ec170a4aa71186f9dc17358b55587c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec170a4aa71186f9dc17358b55587c7">&#9670;&nbsp;</a></span>ha_commit_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::ha_commit_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Public function wrapping the actual handler call. Allows us to enforce asserts regardless of handler implementation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a id="a14af5825a427ba6baac74b13223637f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14af5825a427ba6baac74b13223637f8">&#9670;&nbsp;</a></span>ha_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create a table in the engine: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::create() </dd></dl>

</div>
</div>
<a id="a722462d7e71059a8ed1f43d0fb28366b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722462d7e71059a8ed1f43d0fb28366b">&#9670;&nbsp;</a></span>ha_create_handler_files()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_create_handler_files </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>action_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Create handler files for CREATE <a class="el" href="structTABLE.html">TABLE</a>: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::create_handler_files() </dd></dl>

</div>
</div>
<a id="a1fef228137a11565f7d52a60ad802004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fef228137a11565f7d52a60ad802004">&#9670;&nbsp;</a></span>ha_delete_all_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_delete_all_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Delete all rows: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">handler::delete_all_rows()</a> </dd></dl>

</div>
</div>
<a id="a28700a3bf1af24f9a31ebae51bf877db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28700a3bf1af24f9a31ebae51bf877db">&#9670;&nbsp;</a></span>ha_delete_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_delete_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Delete table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler::delete_table()</a> </dd></dl>

</div>
</div>
<a id="aeeb079b3dc59160ba828ef89b4463921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb079b3dc59160ba828ef89b4463921">&#9670;&nbsp;</a></span>ha_disable_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_disable_indexes </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Disable indexes: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::disable_indexes() </dd></dl>

</div>
</div>
<a id="a1f75cf982985d21907140a17521cd6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f75cf982985d21907140a17521cd6c5">&#9670;&nbsp;</a></span>ha_discard_or_import_tablespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_discard_or_import_tablespace </td>
          <td>(</td>
          <td class="paramtype">my_bool&#160;</td>
          <td class="paramname"><em>discard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Discard or import tablespace: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::discard_or_import_tablespace() </dd></dl>

</div>
</div>
<a id="a6bcc37ec84386f5d6cc86448781666cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bcc37ec84386f5d6cc86448781666cb">&#9670;&nbsp;</a></span>ha_drop_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_drop_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Drop table in the engine: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::drop_table() </dd></dl>

</div>
</div>
<a id="a36e9c53758728e07eb37cbb65ea3ab50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e9c53758728e07eb37cbb65ea3ab50">&#9670;&nbsp;</a></span>ha_enable_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_enable_indexes </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Enable indexes: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::enable_indexes() </dd></dl>

</div>
</div>
<a id="a30f3cbf4a769155c994ed39f76433106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f3cbf4a769155c994ed39f76433106">&#9670;&nbsp;</a></span>ha_end_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_end_bulk_insert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">End bulk insert.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Failure (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a99b5f8ae28bc5c374919396f8dcf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a99b5f8ae28bc5c374919396f8dcf08">&#9670;&nbsp;</a></span>ha_external_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_external_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">These functions represent the public interface to <em>users</em> of the handler class, hence they are <em>not</em> virtual. For the inheritance interface, see the (private) functions write_row(), update_row(), and delete_row() below. </p>

</div>
</div>
<a id="afa6bd01057c6cdd86d2ea2ee4ea65ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6bd01057c6cdd86d2ea2ee4ea65ca3">&#9670;&nbsp;</a></span>ha_index_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">End use of index.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd574a3025588e9b0cd49e0d6908e3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd574a3025588e9b0cd49e0d6908e3b8">&#9670;&nbsp;</a></span>ha_index_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_first </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reads the first row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0af23462b249041a0db03c1c7139d76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af23462b249041a0db03c1c7139d76b">&#9670;&nbsp;</a></span>ha_index_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_init </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Initialize use of index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index to use </td></tr>
    <tr><td class="paramname">sorted</td><td>Use sorted order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a7415f1744039a51ef15e923ef7da1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7415f1744039a51ef15e923ef7da1b">&#9670;&nbsp;</a></span>ha_index_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reads the last row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c99e96a8350ff577a94529be9387a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c99e96a8350ff577a94529be9387a30">&#9670;&nbsp;</a></span>ha_index_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reads the next row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f79360a45d50c6b558feb1c308c4157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f79360a45d50c6b558feb1c308c4157">&#9670;&nbsp;</a></span>ha_index_next_same()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_next_same </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reads the next same row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="classKey.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keylen</td><td>Length of key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb977dac0435158be227e45e04c8b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb977dac0435158be227e45e04c8b798">&#9670;&nbsp;</a></span>ha_index_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_prev </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Reads the previous row via index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac831321e8d33958db4fd4968de932acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac831321e8d33958db4fd4968de932acf">&#9670;&nbsp;</a></span>ha_index_read_idx_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_idx_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Initializes an index and read it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">handler::ha_index_read_map</a>. </dd></dl>

</div>
</div>
<a id="a729d9c9c011527b81287574294887bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729d9c9c011527b81287574294887bf3">&#9670;&nbsp;</a></span>ha_index_read_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_index_read_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Read [part of] row via [part of] index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer where store the data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="classKey.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keypart_map</td><td>Which part of key to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">find_flag</td><td>Direction/condition on key usage</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success (found a record, and function has set table-&gt;status to 0) </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found (function has set table-&gt;status to STATUS_NOT_FOUND). End of index passed. </td></tr>
    <tr><td class="paramname">HA_ERR_KEY_NOT_FOUND</td><td>Row not found (function has set table-&gt;status to STATUS_NOT_FOUND). Index cursor positioned. </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Positions an index cursor to the index specified in the handle. Fetches the row if available. If the key value is null, begin at the first key of the index. ha_index_read_map can be restarted without calling index_end on the previous index scan and without calling ha_index_init. In this case the ha_index_read_map is on the same index as the previous ha_index_scan. This is particularly used in conjunction with multi read ranges. </dd></dl>

</div>
</div>
<a id="a96b182710a133be9561afc149cb6aa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b182710a133be9561afc149cb6aa8f">&#9670;&nbsp;</a></span>ha_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::ha_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Public function wrapping the actual handler call. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a id="a5b81b74b0b7b87de4f99ebe20c49dc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b81b74b0b7b87de4f99ebe20c49dc44">&#9670;&nbsp;</a></span>ha_notify_table_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_notify_table_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Public function wrapping the actual handler call. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed()</a> </dd></dl>

</div>
</div>
<a id="ab5e02829386929734724b143391e0a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e02829386929734724b143391e0a11">&#9670;&nbsp;</a></span>ha_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>test_if_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open database-handler. </p>
<p class="">IMPLEMENTATION Try O_RDONLY if cannot open as O_RDWR Don't wait for locks if not HA_OPEN_WAIT_IF_LOCKED is set </p>

</div>
</div>
<a id="a980a8a7650a41fd9a05a32521826ccd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980a8a7650a41fd9a05a32521826ccd5">&#9670;&nbsp;</a></span>ha_optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_optimize </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Optimize table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::optimize() </dd></dl>

</div>
</div>
<a id="ad0ecf7f9bf265e6801b625768f0f2bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ecf7f9bf265e6801b625768f0f2bbe">&#9670;&nbsp;</a></span>ha_prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::ha_prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Public functions wrapping the actual handler call. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a id="a9fe4a9e78c818aa2823c302f0fe65522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe4a9e78c818aa2823c302f0fe65522">&#9670;&nbsp;</a></span>ha_records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_records </td>
          <td>(</td>
          <td class="paramtype">ha_rows *&#160;</td>
          <td class="paramname"><em>num_rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Public function wrapping the actual handler call, and doing error checking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_rows</td><td>number of rows in table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ee228a60527e81efd9a49ddfdd4850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee228a60527e81efd9a49ddfdd4850d">&#9670;&nbsp;</a></span>ha_rename_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Rename table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler::rename_table()</a> </dd></dl>

</div>
</div>
<a id="ad28d70543d9566894b5a81d25eca2e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28d70543d9566894b5a81d25eca2e8e">&#9670;&nbsp;</a></span>ha_repair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_repair </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Repair table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd>handler::repair() </dd></dl>

</div>
</div>
<a id="a53d38f167906d8aaa9e560c71e595a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d38f167906d8aaa9e560c71e595a42">&#9670;&nbsp;</a></span>ha_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check handler usage and reset state of file to after 'open'. </p>
<dl class="section note"><dt>Note</dt><dd>can be called regardless of it is locked or not. </dd></dl>

</div>
</div>
<a id="ad4d9bf34ac0a004d8c5c32267f20842f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d9bf34ac0a004d8c5c32267f20842f">&#9670;&nbsp;</a></span>ha_rnd_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">End use of random access.</p>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb5c99736cb400350e007578889b8375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5c99736cb400350e007578889b8375">&#9670;&nbsp;</a></span>ha_rnd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Initialize table for random read or scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>if true: Initialize for random scans through <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">rnd_next()</a> if false: Initialize for random reads through <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">rnd_pos()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3743f3a48e7be751dbb2691be4c992a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3743f3a48e7be751dbb2691be4c992a">&#9670;&nbsp;</a></span>ha_rnd_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Read next row via random scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to read the row into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcd8615219b3e692e7d484d2ba6cfa86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd8615219b3e692e7d484d2ba6cfa86">&#9670;&nbsp;</a></span>ha_rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_rnd_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Read row via random scan from position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to read the row into </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>Position from position() call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f09a15d46c019a621b0a65bb1ec89d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f09a15d46c019a621b0a65bb1ec89d3">&#9670;&nbsp;</a></span>ha_start_bulk_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::ha_start_bulk_insert </td>
          <td>(</td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Start bulk insert.</p>
<p class="">Allow the handler to optimize for multiple row insert.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Estimated rows to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b3015577f49008561db1d34ae750e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3015577f49008561db1d34ae750e70">&#9670;&nbsp;</a></span>ha_table_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Table_flags handler::ha_table_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">The cached_table_flags is set at ha_open and ha_external_lock </p>

</div>
</div>
<a id="a69803cd29d92bfecd97212354212c516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69803cd29d92bfecd97212354212c516">&#9670;&nbsp;</a></span>ha_table_share_psi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PSI_table_share * handler::ha_table_share_psi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Acquire the instrumented table information from a table share. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>a table share </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instrumented table share, or NULL. </dd></dl>

</div>
</div>
<a id="a25394328a49d42bb45b3b263009f02c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25394328a49d42bb45b3b263009f02c7">&#9670;&nbsp;</a></span>ha_truncate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handler::ha_truncate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Truncate table: public interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">handler::truncate()</a> </dd></dl>

</div>
</div>
<a id="a7605ac9185a544f444604f11d61f6722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7605ac9185a544f444604f11d61f6722">&#9670;&nbsp;</a></span>has_gap_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::has_gap_locks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Query storage engine to see if it supports gap locks on this table. </p>

</div>
</div>
<a id="a0bb554282443af443fc8aae4533e1407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb554282443af443fc8aae4533e1407">&#9670;&nbsp;</a></span>idx_cond_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classItem.html">Item</a>* handler::idx_cond_push </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>idx_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Push down an index condition to the handler.</p>
<p class="">The server will use this method to push down a condition it wants the handler to evaluate when retrieving records using a specified index. The pushed index condition will only refer to fields from this handler that is contained in the index (but it may also refer to fields in other handlers). Before the handler evaluates the condition it must read the content of the index entry into the record buffer.</p>
<p class="">The handler is free to decide if and how much of the condition it will take responsibility for evaluating. Based on this evaluation it should return the part of the condition it will not evaluate. If it decides to evaluate the entire condition it should return NULL. If it decides not to evaluate any part of the condition it should return a pointer to the same condition as given as argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>the index number to evaluate the condition on </td></tr>
    <tr><td class="paramname">idx_cond</td><td>the condition to be evaluated by the handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The part of the pushed condition that the handler decides not to evaluate </dd></dl>

</div>
</div>
<a id="af37bd518c53c966459632584c34855d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37bd518c53c966459632584c34855d0">&#9670;&nbsp;</a></span>index_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_first </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a1d3598345c3543f684c566f79a61cedc">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a375fdfc86f021f336777324dd5a98a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375fdfc86f021f336777324dd5a98a02">&#9670;&nbsp;</a></span>index_in_memory_estimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double handler::index_in_memory_estimate </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Return an estimate of how much of the index that is currently stored in main memory.</p>
<p class="">This estimate should be the fraction of the index that currently is available in a main memory buffer. The estimate should be in the range from 0.0 (nothing in memory) to 1.0 (entire index in memory).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>the index to get an estimate for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fraction of the index in main memory buffer </dd></dl>

</div>
</div>
<a id="aa1d62ffab7408a031b13e547eb58be09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d62ffab7408a031b13e547eb58be09">&#9670;&nbsp;</a></span>index_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_last </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a6f6e9347ec700ee952a998fa88ae68b2">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="aca48f687872e10a4fdc35b418d98b761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca48f687872e10a4fdc35b418d98b761">&#9670;&nbsp;</a></span>index_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a865afdc25ee4ca42fafde872e476e0ff">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a5459b92420f74e6f88dec137e1941d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5459b92420f74e6f88dec137e1941d22">&#9670;&nbsp;</a></span>index_next_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::index_next_same </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

</div>
</div>
<a id="a4a2ac6b2908a899c0ce230818bb7a993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2ac6b2908a899c0ce230818bb7a993">&#9670;&nbsp;</a></span>index_only_read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double handler::index_only_read_time </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This function is deprecated and will be removed in a future version. Use <a class="el" href="classhandler.html#a5575d58c0acbb1924f7f3d3eb756612a">index_scan_cost()</a> instead. </dd></dl>
<p class="">Calculate cost of 'index only' scan for given index and number of records</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>Index number </td></tr>
    <tr><td class="paramname">records</td><td>Estimated number of records to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is assumed that we will read trough the whole key range and that all key blocks are half full (normally things are much better). It is also assumed that each time we read the next key from the index, the handler performs a random seek, thus the cost is proportional to the number of blocks read.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Estimated cost of 'index only' scan </dd></dl>

</div>
</div>
<a id="a1ab892ae78db6437119d2d25621118b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab892ae78db6437119d2d25621118b7">&#9670;&nbsp;</a></span>index_prev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_prev </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a824559f84d7f256052f0394e9276774f">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="acba0c549a00023dd44682cd9452cf830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba0c549a00023dd44682cd9452cf830">&#9670;&nbsp;</a></span>index_read_idx_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::index_read_idx_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

</div>
</div>
<a id="ae069d5991214e1fdf14cc44fd865a180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae069d5991214e1fdf14cc44fd865a180">&#9670;&nbsp;</a></span>index_read_last_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read_last_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following functions works like index_read, but it find the last row with the current key value or prefix. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

</div>
</div>
<a id="af8c2b258691e5baac8dd22d19c084b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c2b258691e5baac8dd22d19c084b37">&#9670;&nbsp;</a></span>index_read_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::index_read_map </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if success (found a record, and function has set table-&gt;status to 0); non-zero if no record (function has set table-&gt;status to STATUS_NOT_FOUND). </dd></dl>

</div>
</div>
<a id="a5575d58c0acbb1924f7f3d3eb756612a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5575d58c0acbb1924f7f3d3eb756612a">&#9670;&nbsp;</a></span>index_scan_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCost__estimate.html">Cost_estimate</a> handler::index_scan_cost </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Cost estimate for reading a number of ranges from an index.</p>
<p class="">The cost estimate will only include the cost of reading data that is contained in the index. If the records need to be read, use <a class="el" href="classhandler.html#a196d85fe55a71cc09c642592e771b662">read_cost()</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>The ranges parameter is currently ignored and is not taken into account in the cost estimate.</dd>
<dd>
For this version it is recommended that storage engines continue to override <a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time()</a> instead of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index number </td></tr>
    <tr><td class="paramname">ranges</td><td>the number of ranges to be read </td></tr>
    <tr><td class="paramname">rows</td><td>total number of rows to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated cost </dd></dl>

</div>
</div>
<a id="ab1ad6edb66592b200a7c7ac0f947dc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ad6edb66592b200a7c7ac0f947dc66">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">This is called after create to allow us to set up cached variables </p>

</div>
</div>
<a id="a6b6facc9d1d0bda98c814660eaa9bad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6facc9d1d0bda98c814660eaa9bad7">&#9670;&nbsp;</a></span>init_with_fields()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::init_with_fields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">For MyRocks, secondary initialization that happens after frm is parsed into field information from within open_binary_frm. MyRocks uses this secondary init phase to analyze the key and field definitions to determine if it can expose the HA_PRIMARY_KEY_IN_READ_INDEX flag on the table as it only supports that behavior for certain types of key combinations. Return values: false success, true failure. </p>

</div>
</div>
<a id="a90b4c3a8fe1c89c6ccfec1f4b144754a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b4c3a8fe1c89c6ccfec1f4b144754a">&#9670;&nbsp;</a></span>inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a>. The level of concurrency allowed during this operation depends on the return value from <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called with commit= false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a5ff1e368997d6822e3285080fade11fe">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a37413b5d60b340ffe26a6713b65bab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37413b5d60b340ffe26a6713b65bab75">&#9670;&nbsp;</a></span>is_fatal_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::is_fatal_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an error is fatal or not. </p>
<p class="">This method is used to analyze the error to see whether the error is fatal or not. A fatal error is an error that will not be possible to handle with SP handlers and will not be subject to retry attempts on the slave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code received from the handler interface (HA_ERR_...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the error is fatal or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the error is fatal </td></tr>
    <tr><td class="paramname">false</td><td>the error is not fatal</td></tr>
  </table>
  </dd>
</dl>
<p>This method is used to analyse the error to see whether the error is fatal or not. Further comments in header file. </p>

</div>
</div>
<a id="adda33331aacc500b1b974033cb64a869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda33331aacc500b1b974033cb64a869">&#9670;&nbsp;</a></span>is_fk_defined_on_table_or_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::is_fk_defined_on_table_or_index </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If index == MAX_KEY then a check for table is made and if index &lt; MAX_KEY then a check is made if the table has foreign keys and if a foreign key uses this index (and thus the index cannot be dropped).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to check if foreign key uses it</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Foreign key defined on table or index </td></tr>
    <tr><td class="paramname">FALSE</td><td>No foreign key defined </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a6adf9b7e7b7357f464a01f9a7ed2a1ee">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a39c5919d6a3f3098353f4517e2c81037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c5919d6a3f3098353f4517e2c81037">&#9670;&nbsp;</a></span>is_ignorable_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::is_ignorable_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an error can be ignored or not. </p>
<p class="">This method is used to analyze the error to see whether the error is ignorable or not. Such errors will be reported as warnings instead of errors for IGNORE statements. This means that the statement will not abort, but instead continue to the next row.</p>
<p class="">HA_ERR_FOUND_DUP_UNIQUE is a special case in MyISAM that means the same thing as HA_ERR_FOUND_DUP_KEY, but can in some cases lead to a slightly different error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code received from the handler interface (HA_ERR_...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the error is ignorablel or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the error is ignorable </td></tr>
    <tr><td class="paramname">false</td><td>the error is not ignorable</td></tr>
  </table>
  </dd>
</dl>
<p>This method is used to analyse the error to see whether the error is ignorable or not. Further comments in header file. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a95efd97175c4d0f4e5548473b6759e31">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a2447668275a831bcf73b5c00818254a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2447668275a831bcf73b5c00818254a6">&#9670;&nbsp;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint handler::lock_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count()</a> can return &gt; 1 if the table is MERGE or partitioned. </dd></dl>

</div>
</div>
<a id="aa3a39db9dc1cca31f4a3ec0e0e1d7300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a39db9dc1cca31f4a3ec0e0e1d7300">&#9670;&nbsp;</a></span>lock_shared_ha_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::lock_shared_ha_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Take a lock for protecting shared handler data. </p>

</div>
</div>
<a id="a5add40a6cd7088ffef25a3816294b624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5add40a6cd7088ffef25a3816294b624">&#9670;&nbsp;</a></span>multi_range_read_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows handler::multi_range_read_info </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get cost and other information about MRR scan over some sequence of ranges</p>
<p class="">Calculate estimated cost and other information about an MRR scan for some sequence of ranges.</p>
<p class="">The ranges themselves will be known only at execution phase. When this function is called we only know number of ranges and a (rough) E(<a class="el" href="classhandler.html#ae5b7b96354fd25da35a940e656d91940">records</a>) within those ranges.</p>
<p class="">Currently this function is only called for "n-keypart singlepoint" ranges, i.e. each range is "keypart1=someconst1 AND ... AND keypartN=someconstN"</p>
<p class="">The flags parameter is a combination of those flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION, HA_MRR_LIMITS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramname">n_ranges</td><td>Estimated number of ranges (i.e. intervals) in the range sequence. </td></tr>
    <tr><td class="paramname">n_rows</td><td>Estimated total number of records contained within all of the ranges </td></tr>
    <tr><td class="paramname">bufsz[in,out]</td><td>IN: Size of the buffer available for use OUT: Size of the buffer that will be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramname">flags[in,out]</td><td>A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramname">cost[out]</td><td>Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
    <tr><td class="paramname">other</td><td>Error or can't perform the requested scan </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#af561f07d996700a18cd0eb636a14f32e">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a5ee356d2340552eb121d423fc01597f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee356d2340552eb121d423fc01597f8">&#9670;&nbsp;</a></span>multi_range_read_info_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows handler::multi_range_read_info_const </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get cost and other information about MRR scan over a known list of ranges</p>
<p class="">Calculate estimated cost and other information about an MRR scan for given sequence of ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramname">seq</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;<a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init()</a> </td></tr>
    <tr><td class="paramname">n_ranges_arg</td><td>Number of ranges in the sequence, or 0 if the caller can't efficiently determine it </td></tr>
    <tr><td class="paramname">bufsz[in,out]</td><td>IN: Size of the buffer available for use OUT: Size of the buffer that is expected to be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramname">flags[in,out]</td><td>A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramname">cost[out]</td><td>Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method (or an overriding one in a derived class) must check for thd-&gt;killed and return HA_POS_ERROR if it is not zero. This is required for a user to be able to interrupt the calculation by killing the connection/query.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_POS_ERROR</td><td>Error or the engine is unable to perform the requested scan. Values of OUT parameters are undefined. </td></tr>
    <tr><td class="paramname">other</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#abc8e0c56a5a9150ece910a132a05e826">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a33e8899f4bae262b6b91c7284f1d946e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e8899f4bae262b6b91c7284f1d946e">&#9670;&nbsp;</a></span>multi_range_read_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::multi_range_read_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Initialize the MRR scan</p>
<p class="">Initialize the MRR scan. This function may do heavyweight scan initialization like row prefetching/sorting/etc (NOTE: but better not do it here as we may not need it, e.g. if we never satisfy WHERE clause on previous tables. For many implementations it would be natural to do such initializations in the first multi_read_range_next() call)</p>
<p class="">mode is a combination of the following flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;<a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init()</a> </td></tr>
    <tr><td class="paramname">n_ranges</td><td>Number of ranges in the sequence </td></tr>
    <tr><td class="paramname">mode</td><td>Flags, see the description section for the details </td></tr>
    <tr><td class="paramname">buf</td><td>INOUT: memory buffer to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>One must have called index_init() before calling this function. Several <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init()</a> calls may be made in course of one query.</dd></dl>
<p>Until WL#2623 is done (see its text, section 3.2), the following will also hold: The caller will guarantee that if "seq-&gt;init == mrr_ranges_array_init" then seq_init_param is an array of n_ranges KEY_MULTI_RANGE structures. This property will only be used by NDB handler until WL#2623 is done.</p>
<p class=""><br />
 Buffer memory management is done according to the following scenario: The caller allocates the buffer and provides it to the callee by filling the members of HANDLER_BUFFER structure. The callee consumes all or some fraction of the provided buffer space, and sets the HANDLER_BUFFER members accordingly. The callee may use the buffer memory until the next <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init()</a> call is made, all records have been read, or until index_end() call is made, whichever comes first.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#aba9c67b0e6bdfc66f40e30b0bccecabf">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a3419071f3d4abf183dac95ef565adfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3419071f3d4abf183dac95ef565adfff">&#9670;&nbsp;</a></span>multi_range_read_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::multi_range_read_next </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Get next record in MRR scan</p>
<p class="">Default MRR implementation: read the next record</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_info</td><td>OUT Undefined if HA_MRR_NO_ASSOCIATION flag is in effect Otherwise, the opaque value associated with the range that contains the returned record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a63ab7aa4c5bedaae4a2edb452da67fc8">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a39b30a208b304f519e8d74070a41ac19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b30a208b304f519e8d74070a41ac19">&#9670;&nbsp;</a></span>my_eval_gcolumn_expr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::my_eval_gcolumn_expr </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MY_BITMAP *const&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Callback for computing generated column values.</p>
<p class="">Storage engines that need to have virtual column values for a row can use this function to get the values computed. The storage engine must have filled in the values for the base columns that the virutal columns depend on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">table</td><td>table object </td></tr>
    <tr><td class="paramname">fields</td><td>bitmap of field index of evaluated generated column </td></tr>
    <tr><td class="paramname">record</td><td>buff of base columns generated column depends. After calling this function, it will be used to return the value of the generated columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>in case of error </td></tr>
    <tr><td class="paramname">false</td><td>on success.</td></tr>
  </table>
  </dd>
</dl>
<p>Evaluate generated Column's value. If the engine has to write an index entry to its UNDO log (in a DELETE or UPDATE), and the index is on a virtual generated column, engine needs to calculate the column's value. This variant of <a class="el" href="classhandler.html#a39b30a208b304f519e8d74070a41ac19">handler::my_eval_gcolumn_expr()</a> is used by client threads which have a <a class="el" href="structTABLE.html">TABLE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table</td><td>mysql table object </td></tr>
    <tr><td class="paramname">fields</td><td>bitmap of field index of evaluated generated column </td></tr>
    <tr><td class="paramname">record</td><td>buff of base columns generated column depends. After calling this function, it will be used to return the value of generated column.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>in case of error </td></tr>
    <tr><td class="paramname">false</td><td>on success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32dd6a07c4f58be3273576d0cc813933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32dd6a07c4f58be3273576d0cc813933">&#9670;&nbsp;</a></span>my_eval_gcolumn_expr_with_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::my_eval_gcolumn_expr_with_open </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MY_BITMAP *const&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Callback for generated columns processing. Will open the table, in the server <em>only</em>, and call my_eval_gcolumn_expr_helper() to do the actual processing. This function is a variant of the other <a class="el" href="classhandler.html#a39b30a208b304f519e8d74070a41ac19">handler::my_eval_gcolumn_expr()</a> but is intended for use when no <a class="el" href="structTABLE.html">TABLE</a> object already exists - e.g. from purge threads.</p>
<p class="">Note! The call to <a class="el" href="group__Data__Dictionary.html#ga35659d6f0f8a6d39ee3f3db7c233df52">open_table_uncached()</a> must be made with the last argument (open_in_engine) set to false. Failing to do so will cause deadlocks and incorrect behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">db_name</td><td>Database containing the table to open </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table to open </td></tr>
    <tr><td class="paramname">fields</td><td><a class="el" href="classBitmap.html">Bitmap</a> of field index of evaluated generated column </td></tr>
    <tr><td class="paramname">record</td><td>Record buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of error, false otherwise. </dd></dl>

</div>
</div>
<a id="aa6c449e2194c590eb53b6a6b5dbb362c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c449e2194c590eb53b6a6b5dbb362c">&#9670;&nbsp;</a></span>my_prepare_gcolumn_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handler::my_prepare_gcolumn_template </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandler.html#ad4c241e50948859d98ceae6e39066838">my_gcolumn_template_callback_t</a>&#160;</td>
          <td class="paramname"><em>myc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ib_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Callback to allow InnoDB to prepare a template for generated column processing. This function will open the table without opening in the engine and call the provided function with the <a class="el" href="structTABLE.html">TABLE</a> object made. The function will then close the <a class="el" href="structTABLE.html">TABLE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">db_name</td><td>Name of database containing the table </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table to open </td></tr>
    <tr><td class="paramname">myc</td><td>InnoDB function to call for processing <a class="el" href="structTABLE.html">TABLE</a> </td></tr>
    <tr><td class="paramname">ib_table</td><td>Argument for InnoDB function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true in case of error, false otherwise. </dd></dl>

</div>
</div>
<a id="a26aaaf2105e60ca590b79fae82e48960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26aaaf2105e60ca590b79fae82e48960">&#9670;&nbsp;</a></span>notify_table_changed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::notify_table_changed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Notify the storage engine that the table structure (.FRM) has been updated.</p>
<dl class="section note"><dt>Note</dt><dd>No errors are allowed during <a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a2e656837653854c38ee70a7cb46515c6">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a86930bf10b20ad19b3df07e07d28116e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86930bf10b20ad19b3df07e07d28116e">&#9670;&nbsp;</a></span>number_of_pushed_joins()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint handler::number_of_pushed_joins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Reports #tables included in pushed join which this handler instance is part of. ==0 -&gt; Not pushed </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a6aaba12f45b013e5dc180f40463e802a">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="aaef865015edc575d0a50d1a6f5b13e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef865015edc575d0a50d1a6f5b13e4a">&#9670;&nbsp;</a></span>parent_of_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structTABLE.html">TABLE</a>* handler::parent_of_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If this handler instance is a child in a pushed join sequence returned <a class="el" href="structTABLE.html">TABLE</a> instance being my parent? </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a9faa32fde75fed4ebafffd11b6c5638e">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a03831da80c8a99422edd4b4ab84fa55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03831da80c8a99422edd4b4ab84fa55a">&#9670;&nbsp;</a></span>prepare_index_key_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::prepare_index_key_scan </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Notify storage engine about imminent index read with key length. </p>

</div>
</div>
<a id="a4906703169a1e43358e2d95f0d90e911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4906703169a1e43358e2d95f0d90e911">&#9670;&nbsp;</a></span>prepare_index_key_scan_map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::prepare_index_key_scan_map </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Notify storage engine about imminent index read with a bitmap of used key parts. </p>

</div>
</div>
<a id="ad17ab5ed40c1eab55ce74ce2465c9bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17ab5ed40c1eab55ce74ce2465c9bff">&#9670;&nbsp;</a></span>prepare_index_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::prepare_index_scan </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Notify storage engine about imminent index scan where a large number of rows is expected to be returned. Does not replace nor call index_init. </p>

</div>
</div>
<a id="ab25b3931a457f1821ba55ae9cce79d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25b3931a457f1821ba55ae9cce79d98">&#9670;&nbsp;</a></span>prepare_inplace_alter_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::prepare_inplace_alter_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Allows the storage engine to update internal structures with concurrent writes blocked. If <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter()</a> returns HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE or HA_ALTER_INPLACE_SHARED_AFTER_PREPARE, this function is called with exclusive lock otherwise the same level of locking as for <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> will be used.</p>
<dl class="section note"><dt>Note</dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called with commit= false.</dd>
<dd>
For partitioning, failing to prepare one partition, means that <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called to roll back changes for all partitions. This means that <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> might be called without <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> having been called first for a given partition.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a3d7235ae7ee13ad3a572af0fd5c15291">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="aa111c313513f50300e9740aeb3e4cfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa111c313513f50300e9740aeb3e4cfc4">&#9670;&nbsp;</a></span>prepare_range_scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::prepare_range_scan </td>
          <td>(</td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>end_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Notify storage engine about imminent index range scan. </p>

</div>
</div>
<a id="a1c885f4b3b5bf6d2878225a188b5599f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c885f4b3b5bf6d2878225a188b5599f">&#9670;&nbsp;</a></span>primary_key_is_clustered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::primary_key_is_clustered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Check if the primary key is clustered or not.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Primary key (if there is one) is a clustered key covering all fields </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#abf1a2f928fcc952bbe31d8c496ef0dce">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="afda4f1390385a4dc0bfd2981fee23e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda4f1390385a4dc0bfd2981fee23e6c">&#9670;&nbsp;</a></span>print_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::print_error </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">myf&#160;</td>
          <td class="paramname"><em>errflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Print error that we got from handler function.</p>
<dl class="section note"><dt>Note</dt><dd>In case of delete table it's only safe to use the following parts of the 'table' structure:<ul>
<li>table-&gt;s-&gt;path</li>
<li>table-&gt;alias </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#ab4b4b9ed3726be8a4a0887785a5ed530">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a196d85fe55a71cc09c642592e771b662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196d85fe55a71cc09c642592e771b662">&#9670;&nbsp;</a></span>read_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCost__estimate.html">Cost_estimate</a> handler::read_cost </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Cost estimate for reading a set of ranges from the table using an index to access it.</p>
<dl class="section note"><dt>Note</dt><dd>For this version it is recommended that storage engines continue to override <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">read_time()</a> instead of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index number </td></tr>
    <tr><td class="paramname">ranges</td><td>the number of ranges to be read </td></tr>
    <tr><td class="paramname">rows</td><td>total number of rows to be read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated cost </dd></dl>

</div>
</div>
<a id="aff50b704d53d715d6b0fd3534c6107d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff50b704d53d715d6b0fd3534c6107d8">&#9670;&nbsp;</a></span>read_first_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::read_first_row </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>primary_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Read first row (only) from a table.</p>
<p class="">This is never called for InnoDB tables, as these table types has the HA_STATS_RECORDS_IS_EXACT set. </p>

</div>
</div>
<a id="a3a0d596ff3ddc77b4f0ad990c4c4cb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">&#9670;&nbsp;</a></span>read_range_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::read_range_first </td>
          <td>(</td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read first row between two ranges. Store ranges for future calls to read_range_next. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a4ebf9b2b84870f08b62e5e3f5465aae8">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="ae4632aa56c9c66a57558f849f8e01271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4632aa56c9c66a57558f849f8e01271">&#9670;&nbsp;</a></span>read_range_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::read_range_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="section note"><dt>Note</dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#ac4ca12e4aa287eaf6a50c43219a1c776">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a061b519fb16fbff126b0e21530973c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061b519fb16fbff126b0e21530973c2e">&#9670;&nbsp;</a></span>read_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double handler::read_time </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">The cost of reading a set of ranges from the table using an index to access it.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This function is deprecated and will be removed in a future version. Use <a class="el" href="classhandler.html#a196d85fe55a71cc09c642592e771b662">read_cost()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index number. </td></tr>
    <tr><td class="paramname">ranges</td><td>The number of ranges to be read. </td></tr>
    <tr><td class="paramname">rows</td><td>Total number of rows to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used to calculate the total cost of scanning a table using an index by calling it using read_time(index, 1, table_size). </p>

</div>
</div>
<a id="ae5b7b96354fd25da35a940e656d91940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b7b96354fd25da35a940e656d91940">&#9670;&nbsp;</a></span>records()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::records </td>
          <td>(</td>
          <td class="paramtype">ha_rows *&#160;</td>
          <td class="paramname"><em>num_rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Number of rows in table. It will only be called if (table_flags() &amp; (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT)) != 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_rows</td><td>number of rows in table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>for OK, one of the HA_xxx values in case of error. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a31757e2658abd318909a0d190a3795c0">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="af42324038f030519d7476bf915780341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42324038f030519d7476bf915780341">&#9670;&nbsp;</a></span>register_query_cache_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual my_bool handler::register_query_cache_table </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qc_engine_callback *&#160;</td>
          <td class="paramname"><em>engine_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>engine_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a named table with a call back function to the query cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_key</td><td>A pointer to the table name in the table cache </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_length</td><td>The length of the table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_callback</td><td>The pointer to the storage engine call back function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_data</td><td>Storage engine specific data which could be anything</td></tr>
  </table>
  </dd>
</dl>
<p>This method offers the storage engine, the possibility to store a reference to a table name which is going to be used with query cache. The method is called each time a statement is written to the cache and can be used to verify if a specific statement is cachable. It also offers the possibility to register a generic (but static) call back function which is called each time a statement is matched against the query cache.</p>
<dl class="section note"><dt>Note</dt><dd>If engine_data supplied with this function is different from engine_data supplied with the callback function, and the callback returns FALSE, a table invalidation on the current table will occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Upon success the engine_callback will point to the storage engine call back function, if any, and engine_data will point to any storage engine data used in the specific implementation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Success </td></tr>
    <tr><td class="paramname">FALSE</td><td>The specified table or current statement should not be cached </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#abef3e8ffe1d4b952fc59b356d3d5f142">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a58bf8fa32d87654794e6b1c3b3fb8d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bf8fa32d87654794e6b1c3b3fb8d32">&#9670;&nbsp;</a></span>rename_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int handler::rename_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Default <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">rename_table()</a> and <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">delete_table()</a> rename/delete files with a given name and extensions from <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext()</a>.</p>
<p class="">These methods can be overridden, but their default implementation provide useful functionality. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a5609bf8b91966dacc3610fc7ceffc314">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a48cb9c94ca93dbfbb7e92822caba82a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cb9c94ca93dbfbb7e92822caba82a1">&#9670;&nbsp;</a></span>rnd_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_next </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implemented in <a class="el" href="classha__ndbcluster.html#adc93bae43a800cc5ba5057b306136de1">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#aafb71ce870019170b8949672a26387c3">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="adf659edd9d870e90c8974ae0eba7a082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf659edd9d870e90c8974ae0eba7a082">&#9670;&nbsp;</a></span>rnd_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_pos </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implemented in <a class="el" href="classha__ndbcluster.html#a8980053ce56e386ced321a1ad88d1cc2">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#a3c82928e6d10f1e83b118cc6fa7ce088">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="ac2be2fa5d347252f8a28dce931654b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be2fa5d347252f8a28dce931654b76">&#9670;&nbsp;</a></span>rnd_pos_by_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::rnd_pos_by_record </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">This function only works for handlers having HA_PRIMARY_KEY_REQUIRED_FOR_POSITION set. It will return the row with the PK given in the record argument. </p>

</div>
</div>
<a id="a624f6946109f48559e92a9e7c1b86517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624f6946109f48559e92a9e7c1b86517">&#9670;&nbsp;</a></span>root_of_pushed_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structTABLE.html">TABLE</a>* handler::root_of_pushed_join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">If this handler instance is part of a pushed join sequence returned <a class="el" href="structTABLE.html">TABLE</a> instance being root of the pushed query? </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#abf2a5948eca40262f5d533d7c57ca414">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="af0be0637dfaf4fc4a2dc89334c350ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0be0637dfaf4fc4a2dc89334c350ec7">&#9670;&nbsp;</a></span>rpl_can_handle_stm_event()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::rpl_can_handle_stm_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Query storage engine to see if it can support handling specific replication method in its current configuration. </p>

</div>
</div>
<a id="a5f01ea7ce530c3a234e5d17363204f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f01ea7ce530c3a234e5d17363204f13">&#9670;&nbsp;</a></span>rpl_lookup_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::rpl_lookup_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Determine whether the storage engine asks for row-based replication that may skip the lookup of the old row image.</p>
<dl class="section return"><dt>Returns</dt><dd>true if old rows should be read (the default) false if old rows should not be read </dd></dl>

</div>
</div>
<a id="a65f8e5188e2bd9636a564bbc0c3fef86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f8e5188e2bd9636a564bbc0c3fef86">&#9670;&nbsp;</a></span>scan_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double handler::scan_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This function is deprecated and will be removed in a future version. Use <a class="el" href="classhandler.html#a5e9380355a7eea5386ef061f36479258">table_scan_cost()</a> instead. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a21574780af8b6cdc0bbcf8dc5ccb5164">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a4b7dfb95a0da2e828ac018aa2b4abe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7dfb95a0da2e828ac018aa2b4abe3a">&#9670;&nbsp;</a></span>set_end_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::set_end_range </td>
          <td>(</td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_range_scan_direction&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Set the end position for a range scan. This is used for checking for when to end the range scan and by the ICP code to determine that the next record is within the current range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The end value for the range scan </td></tr>
    <tr><td class="paramname">direction</td><td>Direction of the range scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24470ac1d4ac336cedbe7c245d321c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24470ac1d4ac336cedbe7c245d321c9">&#9670;&nbsp;</a></span>set_ha_share_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::set_ha_share_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHandler__share.html">Handler_share</a> *&#160;</td>
          <td class="paramname"><em>arg_ha_share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Set ha_share to be used by all instances of the same table/partition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ha_share</td><td><a class="el" href="classHandler__share.html">Handler_share</a> to be shared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If not a temp table, then LOCK_ha_data must be held. </dd></dl>

</div>
</div>
<a id="acdaf7319a6498f655f8f07b1b34b12fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaf7319a6498f655f8f07b1b34b12fc">&#9670;&nbsp;</a></span>start_bulk_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::start_bulk_delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Bulk delete used by handler </td></tr>
    <tr><td class="paramname">1</td><td>Bulk delete not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7488245f51aa4676c872bb0564dbe71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7488245f51aa4676c872bb0564dbe71f">&#9670;&nbsp;</a></span>start_bulk_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::start_bulk_update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Bulk update used by handler </td></tr>
    <tr><td class="paramname">1</td><td>Bulk update not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#aa852a48bce2fe6fbbe70b83022d74ed2">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a6cadefb8724982848541e06a394917e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cadefb8724982848541e06a394917e8">&#9670;&nbsp;</a></span>start_psi_batch_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handler::start_psi_batch_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Put the handler in 'batch' mode when collecting table io instrumented events. When operating in batch mode:</p><ul>
<li>a single start event is generated in the performance schema.</li>
<li>all table io performed between <code>start_psi_batch_mode</code> and <code>end_psi_batch_mode</code> is not instrumented: the number of rows affected is counted instead in <code>m_psi_numrows</code>.</li>
<li>a single end event is generated in the performance schema when the batch mode ends with <code>end_psi_batch_mode</code>. </li>
</ul>

</div>
</div>
<a id="a3e2428788c2437e4e33c4b390cc697f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2428788c2437e4e33c4b390cc697f7">&#9670;&nbsp;</a></span>start_read_removal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::start_read_removal </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Start read (before write) removal on the current table. </p><dl class="section see"><dt>See also</dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a55b76e2e6595d838981a54951aa3f002">ha_ndbcluster</a>.</p>

</div>
</div>
<a id="a2502e460566f2c4b506cc1b30eb79e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2502e460566f2c4b506cc1b30eb79e0a">&#9670;&nbsp;</a></span>store_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual THR_LOCK_DATA** handler::store_lock </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THR_LOCK_DATA **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Is not invoked for non-transactional temporary tables.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a> can return more than one lock if the table is MERGE or partitioned.</dd>
<dd>
that one can NOT rely on table-&gt;in_use in <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a>. It may refer to a different thread if called from <a class="el" href="group__Locking.html#gad2320fa808c9d6523790e796d57e2331">mysql_lock_abort_for_thread()</a>.</dd>
<dd>
If the table is MERGE, <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a> can return less locks than <a class="el" href="classhandler.html#a2447668275a831bcf73b5c00818254a6">lock_count()</a> claimed. This can happen when the MERGE children are not attached when this is called from another thread. </dd></dl>

<p>Implemented in <a class="el" href="classha__ndbcluster.html#a5bc14d2819ddbc2d616e11db49d669de">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#a7169a09db353528ca14a979b01e56eb6">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="ab4d7cf309121ec10e4150860c8caa12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d7cf309121ec10e4150860c8caa12a">&#9670;&nbsp;</a></span>table_cache_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8 handler::table_cache_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Type of table for caching query </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#ac3a23eb89230938663a59fcf8fbe908b">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#ab23949e133485226e2c90e78eb914b60">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="a171927b3afde9e800755b834bd8d31bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171927b3afde9e800755b834bd8d31bd">&#9670;&nbsp;</a></span>table_in_memory_estimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double handler::table_in_memory_estimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Return an estimate of how much of the table that is currently stored in main memory.</p>
<p class="">This estimate should be the fraction of the table that currently is available in a main memory buffer. The estimate should be in the range from 0.0 (nothing in memory) to 1.0 (entire table in memory).</p>
<dl class="section return"><dt>Returns</dt><dd>The fraction of the table in main memory buffer </dd></dl>

</div>
</div>
<a id="a5e9380355a7eea5386ef061f36479258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9380355a7eea5386ef061f36479258">&#9670;&nbsp;</a></span>table_scan_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCost__estimate.html">Cost_estimate</a> handler::table_scan_cost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Cost estimate for doing a complete table scan.</p>
<dl class="section note"><dt>Note</dt><dd>For this version it is recommended that storage engines continue to override <a class="el" href="classhandler.html#a65f8e5188e2bd9636a564bbc0c3fef86">scan_time()</a> instead of this function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated cost </dd></dl>

</div>
</div>
<a id="ad38f5d3f1e026a0af32b5542aa5ac2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38f5d3f1e026a0af32b5542aa5ac2f9">&#9670;&nbsp;</a></span>table_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* handler::table_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">The following can be called without an open handler </p>

<p>Implemented in <a class="el" href="classha__ndbcluster.html#a96d160419836ac20e131570a32e1c4a8">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#a4f8caa0e516e62ccce4a5f2a52590548">ha_ndbinfo</a>.</p>

</div>
</div>
<a id="a13fdf15d81c256d3e6a9643532ff2126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fdf15d81c256d3e6a9643532ff2126">&#9670;&nbsp;</a></span>truncate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int handler::truncate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Quickly remove all rows from a table.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This method is responsible for implementing MySQL's TRUNCATE <a class="el" href="structTABLE.html">TABLE</a> statement, which is a DDL operation. As such, a engine can bypass certain integrity checks and in some cases avoid fine-grained locking (e.g. row locks) which would normally be required for a DELETE statement.</dd>
<dd>
Typically, truncate is not used if it can result in integrity violation. For example, truncate is not used when a foreign key references the table, but it might be used if foreign key checks are disabled.</dd>
<dd>
Engine is responsible for resetting the auto-increment counter.</dd>
<dd>
The table is locked in exclusive mode. </dd></dl>

</div>
</div>
<a id="ab3e767094bff139a26743e9314df8476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e767094bff139a26743e9314df8476">&#9670;&nbsp;</a></span>try_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::try_semi_consistent_read </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Tell the engine whether it should avoid unnecessary lock waits. If yes, in an UPDATE or DELETE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. </p>

</div>
</div>
<a id="a8059bbed3de416b3bea51c69dc064e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8059bbed3de416b3bea51c69dc064e79">&#9670;&nbsp;</a></span>unlock_shared_ha_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::unlock_shared_ha_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">Release lock for protecting ha_share. </p>

</div>
</div>
<a id="af07d741fb837dacdddc29c1d7e912204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07d741fb837dacdddc29c1d7e912204">&#9670;&nbsp;</a></span>update_field_defs_with_zip_dict_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void handler::update_field_defs_with_zip_dict_info </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>part_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">This method is supposed to fill field definition objects with compression dictionary info (name and data). If the handler does not support compression dictionaries this method should be left empty (not overloaded).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">part_name</td><td>Full table name (including partition part). Optional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adac21f2d10c4463fb1d7e14882c6314f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac21f2d10c4463fb1d7e14882c6314f">&#9670;&nbsp;</a></span>use_hidden_primary_key()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void handler::use_hidden_primary_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key </p>
<p class=""><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f" title="use_hidden_primary_key() is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY...">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key </p>

</div>
</div>
<a id="a54d92f647a4ca5a3b7867fa5538242a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d92f647a4ca5a3b7867fa5538242a6">&#9670;&nbsp;</a></span>was_semi_consistent_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handler::was_semi_consistent_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p class="">In an UPDATE or DELETE, if the row under the cursor was locked by another transaction, and the engine used an optimistic read of the last committed row value under the cursor, then the engine returns 1 from this function. MySQL must NOT try to update this optimistic value. If the optimistic value does not match the WHERE condition, MySQL can decide to skip over this row. Currently only works for InnoDB. This can be used to avoid unnecessary lock waits.</p>
<p class="">If this method returns nonzero, it will also signal the storage engine that the next read will be a locking re-read of the row. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1540a47a05c03724f1102aaaa623131e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1540a47a05c03724f1102aaaa623131e">&#9670;&nbsp;</a></span>auto_inc_interval_for_cur_row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDiscrete__interval.html">Discrete_interval</a> handler::auto_inc_interval_for_cur_row</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class=""><a class="el" href="structInterval.html">Interval</a> returned by <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a> and being consumed by the inserter. </p>

</div>
</div>
<a id="acdfcef0738a89138c8f41ded8da17c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfcef0738a89138c8f41ded8da17c0a">&#9670;&nbsp;</a></span>auto_inc_intervals_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint handler::auto_inc_intervals_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Number of reserved auto-increment intervals. Serves as a heuristic when we have no estimation of how many records the statement will insert: the more intervals we have reserved, the bigger the next one. Reset in handler::ha_release_auto_increment(). </p>

</div>
</div>
<a id="a05dd2cafd83ae60562649bf9688aebf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd2cafd83ae60562649bf9688aebf1">&#9670;&nbsp;</a></span>insert_id_for_cur_row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong handler::insert_id_for_cur_row</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">insert id for the current row (<em>autogenerated</em>; if not autogenerated, it's 0). At first successful insertion, this variable is stored into THD::first_successful_insert_id_in_cur_stmt. </p>

</div>
</div>
<a id="a881e7cba3fe3bf9731a91be82983cc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881e7cba3fe3bf9731a91be82983cc35">&#9670;&nbsp;</a></span>m_psi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PSI_table* handler::m_psi</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Instrumented table associated with this handler. </p>

</div>
</div>
<a id="a62ab295e407d8a5c50087fed0f4fcd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ab295e407d8a5c50087fed0f4fcd18">&#9670;&nbsp;</a></span>next_insert_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong handler::next_insert_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">next_insert_id is the next value which should be inserted into the auto_increment column: in a inserting-multi-row statement (like INSERT SELECT), for the first row where the autoinc value is not specified by the statement, <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a> called and asked to generate a value, next_insert_id is set to the next value, then for all other rows next_insert_id is used (and increased each time) without calling <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a>. </p>

</div>
</div>
<a id="a64def328ff0ca7e391b217c2d3a758ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64def328ff0ca7e391b217c2d3a758ec">&#9670;&nbsp;</a></span>ref_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint handler::ref_length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">Length of ref (1-8 or the clustered key length) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="handler_8h_source.html">handler.h</a></li>
<li><a class="el" href="handler_8cc.html">handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
